<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 西门吹风</title>
    <link>https://helixs.github.io/posts/</link>
    <description>Recent content in Posts on 西门吹风</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 03 Nov 2021 18:27:33 +0800</lastBuildDate><atom:link href="https://helixs.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>My First Post</title>
      <link>https://helixs.github.io/posts/my-first-post/</link>
      <pubDate>Wed, 03 Nov 2021 18:27:33 +0800</pubDate>
      
      <guid>https://helixs.github.io/posts/my-first-post/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Flutter Web使用的一些心得和一些问题</title>
      <link>https://helixs.github.io/posts/2021-04-27-flutter-web%E4%BD%BF%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BF%83%E5%BE%97%E5%92%8C%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</link>
      <pubDate>Tue, 27 Apr 2021 02:12:57 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2021-04-27-flutter-web%E4%BD%BF%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BF%83%E5%BE%97%E5%92%8C%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</guid>
      <description>公司这段时间新建了一个网站项目，因为是新项目，选择技术栈来说是比较值得探讨的问题，因为前端缺人，本身我们组又是移动应用开发为主，虽然前端也会，毕竟不是一直从事前端开发，不能那么快速将项目上线。刚好前不久Flutter2.0发布了，FlutterWeb也开启了正式之路，然后我就跟同事们说要不就用这玩意儿吧，来吃肉(填坑？)。然后大家就欣然同意。
FlutterWeb实现原理基本上和移动应用一个道理，默认情况下都是使用的调用Canvaskit+skia引擎调用WebGL实现绘制。也可以使用html+css+canvas进行渲染，这样少了Skia引擎，会让包大小少2mb左右，不过展示的样式可能就是根据浏览器默认渲染的方式进行了，差别还是蛮大的。
1、使用默认Canvaskit渲染方式，会在打开应用之初加载字体1秒钟内，出现中文字体乱码问题！！！关于这个问题，我们暂时智能使用html的方式进行官方目前还没有什么有效的解决方式，问题在这里https://github.com/flutter/flutter/issues/73628 出现问题的主要原因是，自绘引擎需要字体库支持，FlutterWeb 默认会使用Noto字体，因为一般电脑上都不会带有这个字体，所以会在线寻找这个字体，比如google或者一些第三方字体库网站，导致加载缓慢和乱码。当然还有办法可以解决这个问题，就是将字体放到本地资源库，比如将Noto字体作为默认字体一起打包到web网站上，下载速度就快了很多,你也可以换一些自己的中文字体(注意版权问题)，不会出现乱码情况。坏处就是还是会增加一些服务器的负担。
 2、应用体积过大，我们大概做了十几个页面吧，打包下来最后会生成main.dart.js文件，搞下来已经7mb了，而且没办法拆分，意思就是你打开这个网站就等于加载了几乎整个应用渲染逻辑！更意味着打开网站下载js，执行js，渲染js 是你不得不面对的三道速度墙！记得如果你真的要用它，放到生产环境时候要给nginx或者其他方式实现brotli或者gzip压缩来减少传输时间！当然官方现在也没有很好的解决办法来如何拆分它！https://github.com/flutter/flutter/issues/46589 3、因为FlutterWeb是自绘引擎，默认是不支持文字选中和复制了，如果你需要文字选中和复制需要使用SelectableText ，从体验上来讲，还是有那么不太舒服哦，跟原生Web标准还是差很多。如果你的网页需要允许用户进行大量的复制操作，请谨慎尝试。
4、如果你的网页需要提高标签值被爬的难度，那么它可能是比较好的一个办法，一堆js等着你去解析吧。
问题待续….
根据上面的信息，我大概确定的是它目前定位基本上和nativeApp一个级别的WebApp，也可以直接生成webApp应用给浏览器保留，所以他不合适用来做很多传统的WebPage应用了。</description>
    </item>
    
    <item>
      <title>美国发动伊拉克战争的一种猜想</title>
      <link>https://helixs.github.io/posts/2021-04-19-%E7%BE%8E%E5%9B%BD%E5%8F%91%E5%8A%A8%E4%BC%8A%E6%8B%89%E5%85%8B%E6%88%98%E4%BA%89%E7%9A%84%E4%B8%80%E7%A7%8D%E7%8C%9C%E6%83%B3/</link>
      <pubDate>Mon, 19 Apr 2021 05:55:28 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2021-04-19-%E7%BE%8E%E5%9B%BD%E5%8F%91%E5%8A%A8%E4%BC%8A%E6%8B%89%E5%85%8B%E6%88%98%E4%BA%89%E7%9A%84%E4%B8%80%E7%A7%8D%E7%8C%9C%E6%83%B3/</guid>
      <description>&amp;lt;p&amp;gt; 美国人从未在他们公开的国家战略中谈论过这个话题。据说，上一任美联储主席格林斯潘就职当天，就曾告诫他的同僚：在这里（美联储）你们可以谈论一切，就是不许谈论美元。这是禁忌，美国人对这一关乎美国国家生存的话题讳莫如深。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 美国人在过去40年里，找到了一种在他们看来是最好的，也最便捷的国家生存方式，那就是用金融手段从全球向美国转移财富。美国人发现自己可以不用生产其他的产品，只生产一样东西就可以致富，就可以过得比世上所有人都好，这个方式就是印刷美元。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 从罗马帝国到大英帝国，基本上都是以一种相似的方式完成帝国积累财富、消耗财富的过程。这种方式是什么呢？就是占领别国的领土，掠夺别国的资源，奴役别国的人民。这就是经典的殖民帝国模式。但是两次世界大战的教训，使美国意识到，必须避免重蹈古典帝国模式的覆辙。因为一次大战德国向老牌殖民帝国挑战，想要获取自己的生存空间，结果失败了。20多年后德国再度崛起，再次向老牌殖民帝国发起挑战，又再度失败了。美国毫无疑问记取了这个历史教训：如果一个国家的崛起，一定要从老牌殖民帝国那里虎口夺食的话，就不可避免地会发生战争，而其结果只能是两败俱伤，最后徒使他人得利。美国就是两次大战最大的获利者。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; “布雷顿森林体系”的实质：全世界的货币锁定美元，而美元锁定黄金。美国政府向全世界承诺，每35美元可以兑换一盎司黄金，那个时候的美国可以说是志得意满，因为这个时候的美国有世界上最大的黄金储备，世界上80%的黄金都捏在美国人手里，与此同时，美国还拥有世界上最强大的生产能力和军事机器。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 没有足够多的黄金你就不能印足够多的美元！因为你对全世界有承诺，你是全世界的基准货币，你必须保持美元的稳定。这使美国陷入了空前的窘境。 1&amp;lt;b&amp;gt;&amp;lt;i&amp;gt;971年8月15日，当时的美国总统尼克松宣布：美元跟黄金脱钩。这一失信之举意味着美国可以不受黄金的羁绊，随意加印美元了。&amp;lt;/i&amp;gt;&amp;lt;/b&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 半年后，研究报告《黄金非货币化的影响》出炉。这份具有良知的报告中提醒美国政府，美元跟黄金脱钩，在短时间内对美国有好处，因为美国可以在全世界还没回过神来时多印钞票，用没有黄金背书的纸币去占全世界的便宜。但长期看，这对美国和全世界都决不是什么好事，尤其对美国，无疑是饮鸩止渴。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 而美国政府俨然如醍醐灌顶，大彻大悟！他们根本不理会作者迈克尔·赫德森的警告，对报告反其意而用之。既然这么干短期对美国有好处，干吗不把它变成一个长期的好处，让美国人永久享用呢？当然，这首先需要与黄金脱钩后完全变成一张绿纸的美元，在全世界面前，仍然保持它的信用。这就意味着美元必须保持它的霸权地位。&amp;lt;b&amp;gt;&amp;lt;i&amp;gt;怎样才能保持美元的霸权地位呢？美国政府认为最重要的是两根支柱，一根是美国强大的科技创新力。另一根是美国强大的军事实力。&amp;lt;/i&amp;gt;&amp;lt;/b&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 但美国人知道，与黄金脱钩后的美元，最好与世界上最重要的大宗商品挂钩，才能确保美元的地位稳如磐石。机会很快就来了。1973年的10月6日，第四次中东战争爆发。一开始，&amp;lt;a class=&amp;quot; wrap external&amp;quot; href=&amp;quot;https://link.zhihu.com/?target=https%3A//www.baidu.com/s%3Fwd%3D%25E5%259F%2583%25E5%258F%258A%25E4%25BA%25BA%26tn%3D44039180_cpr%26fenlei%3Dmv6quAkxTZn0IZRqIHckPjm4nH00T1Y3nvcknhnsP1mvrHDvuW0s0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3EPH6zrHfzP16kPWfkrjDdPW0d&amp;quot; target=&amp;quot;_blank&amp;quot; rel=&amp;quot;nofollow noopener noreferrer&amp;quot; data-za-detail-view-id=&amp;quot;1043&amp;quot;&amp;gt;埃及人&amp;lt;/a&amp;gt;和叙利亚人两线出击，打了&amp;lt;a class=&amp;quot; wrap external&amp;quot; href=&amp;quot;https://link.zhihu.com/?target=https%3A//www.baidu.com/s%3Fwd%3D%25E4%25BB%25A5%25E8%2589%25B2%25E5%2588%2597%26tn%3D44039180_cpr%26fenlei%3Dmv6quAkxTZn0IZRqIHckPjm4nH00T1Y3nvcknhnsP1mvrHDvuW0s0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3EPH6zrHfzP16kPWfkrjDdPW0d&amp;quot; target=&amp;quot;_blank&amp;quot; rel=&amp;quot;nofollow noopener noreferrer&amp;quot; data-za-detail-view-id=&amp;quot;1043&amp;quot;&amp;gt;以色列&amp;lt;/a&amp;gt;一个措手不及，但不久后战况逆转，&amp;lt;a class=&amp;quot; wrap external&amp;quot; href=&amp;quot;https://link.zhihu.com/?target=https%3A//www.baidu.com/s%3Fwd%3D%25E4%25BB%25A5%25E8%2589%25B2%25E5%2588%2597%26tn%3D44039180_cpr%26fenlei%3Dmv6quAkxTZn0IZRqIHckPjm4nH00T1Y3nvcknhnsP1mvrHDvuW0s0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3EPH6zrHfzP16kPWfkrjDdPW0d&amp;quot; target=&amp;quot;_blank&amp;quot; rel=&amp;quot;nofollow noopener noreferrer&amp;quot; data-za-detail-view-id=&amp;quot;1043&amp;quot;&amp;gt;以色列&amp;lt;/a&amp;gt;反占上风。这让阿拉伯世界非常郁闷。坐拥石油的阿拉伯人决定，在战场上得不到的东西，就从其他地方去获得。于是，欧佩克——国际石油输出国组织——决定用石油做武器，抬高油价打击西方。这个办法果然比战争来得更有效，很快西方就承受不住了。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 这时，美国当时的财政部长西蒙秘密地飞到了沙特，去见沙特的石油大臣，也是首任欧佩克秘书长，告诉他：你们想把油价打多高我们不管， 但是要想不让美国人与你们为敌，你们必须接受一个条件，就是&amp;lt;b&amp;gt;&amp;lt;i&amp;gt;全球的石油交易用美元结算&amp;lt;/i&amp;gt;&amp;lt;/b&amp;gt;。这位沙特的石油大臣与整个世界一样，对美国人这一招棋的深远机心并不了然，于是就一口答应了美国人的要求，从此，全世界的石油交易与美元挂钩，而美元的信用也就在此后40年里，牢牢地与全球的能源需求挂上了钩。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 走到这一步，美国人设计出的这个新型帝国渐渐开始显现出轮廓，这就是人类帝国史上从未出现过的金融殖民帝国。美国人发现，比起当年德国人虎口夺食去争取一个国家的生存空间这种愚蠢做法来，更高明的办法，应该是通过让世人几乎觉察不到的方式，乖乖地让他们把手中财富交出来，而又不制造仇恨。要达此目的，没有比金融殖民更好的办法了，这办法可以把全世界都纳入美国的金融体系中，然后，像拧开自来水水龙头一样让财富滚滚流入美国人的口袋。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 美国人用比较优势理论把全世界分成了两块，一块是美国，美国人认为它的优势就在于生产美元；另一块是全世界。全世界的优势在哪儿呢？比如，中国人，你的比较优势就在于你有大量的廉价劳动力。由美国人作为一方，全世界作为另一方，由美国人负责生产美元，而全世界负责生产用美元交换的产品，这就是美国人主导的全球产业大分工的本质，从此，全球化浪潮席卷全球。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 美国用自己的金融体系，把全世界与美国紧紧捆绑在一起，这种由美国向世界输出美元，而世界向美国提供产品的交易模式，其结果就是全球财富快速向美国集中，这也就是美国在1990年前的200多年里，GDP最高时才不过达到7万亿美元，而在最近的短短20年里，GDP居然翻了一番，达到14万亿的根本原因。当然，美国人比全世界都清楚，用这种方式聚敛的财富，仅仅靠全球产业大分工是不够的，甚至再加上石油与美元挂钩也还不够，还需要一个非常强有力的手段，如果没有这个手段，美国不足以从世人手中掠走那么多的财富，而这个手段就是天下第一的军事实力。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; &amp;lt;b&amp;gt;&amp;lt;i&amp;gt;美国人为什么要打伊拉克战争？答曰：为了石油。&amp;lt;/i&amp;gt;&amp;lt;/b&amp;gt;那么，接下来的问题是：为什么美国占领伊拉克后，却不从伊拉克免费拉走一桶石油？当美国打下伊拉克时，首先出现的是什么情况？全球油价飙升。油价飙升，交易又以美元结算，意味着什么呢？意味着油价的飙升拉高了全球的美元需求，也就是说，&amp;lt;b&amp;gt;&amp;lt;i&amp;gt;美国人通过战争打出了全球的美元需求&amp;lt;/i&amp;gt;&amp;lt;/b&amp;gt;。打伊拉克战争之前，一桶石油38美元，打完了之后接近150美元，等于一场战争把美元的需求打高了近三倍。这样一来，美国政府就能以给全世界提供流动性的名义，开动印钞机，印刷更多的美元，而美国政府不是慈善家，不会白白把美元给你，你必须拿你的产品去换，从而再一次加入实物换绿纸的游戏。此时美国政府的印钞行为可以说名正言顺。更多的美元流到了其他国家的手里，流到了产油国的手里，也流到了需要购买石油的国家手里。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 这么多美元攥在这些国家手里能干什么呢？除了作为财富的符号让人开心外，就是变为废纸的前景让人担心，因为美元正以日新月异的速度在贬值，天天在贬值，天天都在变成废纸，这个时候&amp;lt;b&amp;gt;&amp;lt;i&amp;gt;你唯一的选择，就是美国人早就为你准备好的选择：购买美国的国债。&amp;lt;/i&amp;gt;&amp;lt;/b&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 购买美国国债使巨量的美元回流美国，也使美国成了全世界最大的债务国。那么，美国为什么需要让流向全世界的美元，再以购买美国国债的方式回流美国呢？一个几乎没有储蓄率的美国，必须始终保持资本项目的顺差，而这个顺差的额度在2001年前后的时候，大约是每年7000亿美元左右，也就是说，需要每天净流入美国20亿美元。因此，美国需要大量的世界资本回流美国，大部分美国人刷卡透支的好日子才能为继， &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 为了保持资本项下的顺差，美国会不惜动用战争手段，去打坏别国、别的地区的投资环境，像驱赶羊群一样，把美元驱赶回美国。所以说，表面上看，两次伊拉克战争都和石油有关，但实际上主要是和美元有关。因为只要在产油区打仗，油价就会上升，美元的需求也就会随之上升。如此一来，美国人就可以开动印钞机，印更多的美元，从全球换回更多的实物财富，道理就这么简单。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 美国打科索沃的真正动机到底是什么？这场战争发生的时间是1999年3月，但耐人寻味的是，1999年1月1日，发生了另一个重大事件：欧元正式启动。当时欧元和美元的汇率是1∶1.</description>
    </item>
    
    <item>
      <title>Mariadb安装设置root密码</title>
      <link>https://helixs.github.io/posts/2021-04-02-mariadb%E5%AE%89%E8%A3%85%E8%AE%BE%E7%BD%AEroot%E5%AF%86%E7%A0%81/</link>
      <pubDate>Fri, 02 Apr 2021 07:02:08 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2021-04-02-mariadb%E5%AE%89%E8%A3%85%E8%AE%BE%E7%BD%AEroot%E5%AF%86%E7%A0%81/</guid>
      <description>启动远程连接
红色部分是用户名和远程登录的密码，和本地密码不同。
 </description>
    </item>
    
    <item>
      <title>LinkedHashMap图解</title>
      <link>https://helixs.github.io/posts/2021-03-30-linkedhashmap%E5%9B%BE%E8%A7%A3/</link>
      <pubDate>Tue, 30 Mar 2021 12:32:42 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2021-03-30-linkedhashmap%E5%9B%BE%E8%A7%A3/</guid>
      <description>跟hashMap的区别就是所有node节点增加了after和before属性 形成了双向链表，通过牺牲空间来保证有序性。</description>
    </item>
    
    <item>
      <title>LeetCode之在数组中计算某个两个数和等于目标值</title>
      <link>https://helixs.github.io/posts/2021-03-26-leetcode%E4%B9%8B%E5%9C%A8%E6%95%B0%E7%BB%84%E4%B8%AD%E8%AE%A1%E7%AE%97%E6%9F%90%E4%B8%AA%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%92%8C%E7%AD%89%E4%BA%8E%E7%9B%AE%E6%A0%87%E5%80%BC/</link>
      <pubDate>Fri, 26 Mar 2021 06:33:01 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2021-03-26-leetcode%E4%B9%8B%E5%9C%A8%E6%95%B0%E7%BB%84%E4%B8%AD%E8%AE%A1%E7%AE%97%E6%9F%90%E4%B8%AA%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%92%8C%E7%AD%89%E4%BA%8E%E7%9B%AE%E6%A0%87%E5%80%BC/</guid>
      <description>链接：https://leetcode-cn.com/problems/two-sum
我的第一想法 双循环
再看看大神
 看到没，循环只有一次，通过每次预推断补数，就直接下个循环判断有没有就行了。</description>
    </item>
    
    <item>
      <title>AndroidStudio通过Gradle查看第三方依赖关系</title>
      <link>https://helixs.github.io/posts/2021-02-19-androidstudio%E9%80%9A%E8%BF%87gradle%E6%9F%A5%E7%9C%8B%E7%AC%AC%E4%B8%89%E6%96%B9%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB/</link>
      <pubDate>Fri, 19 Feb 2021 07:27:02 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2021-02-19-androidstudio%E9%80%9A%E8%BF%87gradle%E6%9F%A5%E7%9C%8B%E7%AC%AC%E4%B8%89%E6%96%B9%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB/</guid>
      <description>进行Android开发我们经常遇到一些依赖冲突，以及库版本号不一致导致出现各种问题。往往就下面这张图只是看到了你所有的依赖项，并不知道这些依赖都是从哪里来的，除非你进去一个个查看pow.xml那么蠢了。
                       看了半天也不知道是从哪里依赖的。
有个简单的方法，打开gradle工具，找到项目下如app模块-&amp;gt;Tasks-&amp;gt;help-&amp;gt;dependencies-&amp;gt;双击                         那么他会执行 :app:dependencies命令,会打印出依赖项及子依赖项
                      往上说的那些什么插件的都是老方法了，新版的studio没办法直观反映</description>
    </item>
    
    <item>
      <title>计算机中图像视频及色彩生成原理</title>
      <link>https://helixs.github.io/posts/2021-02-09-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E5%9B%BE%E5%83%8F%E5%8F%8A%E8%89%B2%E5%BD%A9%E7%94%9F%E6%88%90%E5%8E%9F%E7%90%86/</link>
      <pubDate>Tue, 09 Feb 2021 05:58:37 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2021-02-09-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E5%9B%BE%E5%83%8F%E5%8F%8A%E8%89%B2%E5%BD%A9%E7%94%9F%E6%88%90%E5%8E%9F%E7%90%86/</guid>
      <description>本人对图像和视频知识方面基本上是个小白，饶有兴致的看看资料，把觉得有用的东西记录下来，资料均为网上收集。
视频技术的实践介绍：图像、视频、编解码器（av1、vp9、h265）等（ffmpeg编码） 有多语言翻译。https://github.com/leandromoreira/digital_video_introduction 拜耳阵列
https://www.cnblogs.com/morikokyuro/p/13256701.html https://zh.wikipedia.org/wiki/%E6%8B%9C%E7%88%BE%E6%BF%BE%E8%89%B2%E9%8F%A1 RGB和YUV关系和区别
https://blog.csdn.net/asahinokawa/article/details/80596655 https://www.cnblogs.com/yunlambert/p/11234971.html https://www.cnblogs.com/justkong/p/6570914.html YUV 420 444 421 422 如何理解
https://blog.csdn.net/xueyushenzhou/article/details/40817949 视频编码中的I/P/B帧
https://www.cnblogs.com/yongdaimi/p/10676309.html https://blog.csdn.net/abcjennifer/article/details/6577934 </description>
    </item>
    
    <item>
      <title>Android_RecyclerView设置最大数量高度</title>
      <link>https://helixs.github.io/posts/2020-05-08-android_recyclerview%E8%AE%BE%E7%BD%AE%E6%9C%80%E5%A4%A7%E6%95%B0%E9%87%8F%E9%AB%98%E5%BA%A6/</link>
      <pubDate>Fri, 08 May 2020 09:16:12 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2020-05-08-android_recyclerview%E8%AE%BE%E7%BD%AE%E6%9C%80%E5%A4%A7%E6%95%B0%E9%87%8F%E9%AB%98%E5%BA%A6/</guid>
      <description>有这么一个需求，一个列表要满足一个条件
1、列表少于等于5条，列表的高度跟随item的数量变化而变化
2、如果超过5条，按照最大5条的高度显示，并支持滚动
所以基本的由于item高度不能定死，所以支持设置recyclerView高度是wrap_content
然后具体操作看了下源码，大部分计算都是在LayoutManager中，找到这里
主要是通过这个方法测量子控件叠加的高度，方法居然给我是私有的，没办法继承，不然我就直接控制循环数量了。转而求其次，实现setMeasuredDimension方法
哈哈，是不是超级简单，具体用法
 </description>
    </item>
    
    <item>
      <title>Android源码一步一步分析系列之Retrofit</title>
      <link>https://helixs.github.io/posts/2020-04-26-android%E6%BA%90%E7%A0%81%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8Bretrofit/</link>
      <pubDate>Sun, 26 Apr 2020 05:36:46 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2020-04-26-android%E6%BA%90%E7%A0%81%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8Bretrofit/</guid>
      <description>Retrofit是原Square大神JakeWharton面向Android和Java平台的http客户端。
那么我们常用的Retrofit+Okhttp的关系是什么呢？其实Retrofit需要依赖Okhttp，就如同Okhttp依赖OkIO一样，Retrofit当使用Http请求时候方面了我们的结构化配置。
Okhttp：
Android为我们提供了两种HTTP交互的方式：HttpURLConnection和Apache HTTP Client（ Android 6.0——API 23已经不支持该方式了 ），虽然两者都支持HTTPS，流的上传和下载，配置超时IPv6和连接池，已足够满足我们各种HTTP请求的需求。但更高效的使用HTTP可以让我们的应用运行更快、更节省流量。这就诞生了Okhttp及Retrofit等HTTP库。OKHttp是一款高效的HTTP库，支持连接同一地址的链接共享同一个socket，通过连接池来减小响应延迟，还有透明的GZIP压缩，请求缓存等优势。OkHttp存在以下的特点：
 支持HTTP2/SPDY socket自动选择最好路线，并支持自动重连 拥有自动维护的socket连接池，减少握手次数 拥有队列线程池，轻松写并发 拥有Interceptors轻松处理请求与响应（比如透明GZIP压缩,LOGGING） 基于Headers的缓存策略  Retrofit:retrofit就是对okhttp做了一层封装。把网络请求都交给给了Okhttp，我们只需要通过简单的配置就能使用retrofit来进行网络请求了。Retrofit框架存在的优势：
 Retrofit使用注解方式，大大简化了我们的URL拼写形式，而且注解含义一目了然，简单易懂； Retrofit使用简单，结构层次分明，每一步都能清晰的表达出之所以要使用的寓意； Retrofit支持同步和异步执行，使得请求变得异常简单，只要调用enqueue/execute即可完成； Retrofit更大自由度的支持我们自定义的业务逻辑，如自定义Converters。 Retrofit支持多种文件解析(Gson,Json,XML,Protobuf) Retrofit支持RxJava  我们来看如何使用
基于com.squareup.retrofit2:retrofit:2.8.1.
看到没，是不是很方便呢，我们只需配置一个baseUrl，放置一个接口配置清单，我们就可以进行简单的网络请求了。
分析源码
下面这张图是Retrofit常用依赖包
    adapter和converter根据自己实际情况进行调整
看看retrofit的东西，哟，不是很多，说明我们看它更加容易
                http下面都是一堆注解，什么http方法 HEAD QUERY 等等非常丰富，retrofit运行过程中会反射获取这些类型再进行合理的封装。
看看Retrofit中的成员变量
Retrofit的Builder模式初始化
在1和2中我们看到了使用平台
Platform里面的东西其实不多，就是Callback的执行器和一些跟JAVA8特性相关，跟Retrofit核心关系不是很大。
createSerivce
这里面用到了动态代理模式，可以学习一下。
下面我们就来看看ServiceMethod是怎么获取的
1、RequestFactory
2、HttpServiceMethod
我们生成了RequestFactory后就马上调用了 HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory);</description>
    </item>
    
    <item>
      <title>Android源码一步一步分析系列之OkHttp(6)——CallServerInterceptor</title>
      <link>https://helixs.github.io/posts/2020-04-10-android%E6%BA%90%E7%A0%81%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8Bokhttp6-callserverinterceptor/</link>
      <pubDate>Fri, 10 Apr 2020 10:02:31 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2020-04-10-android%E6%BA%90%E7%A0%81%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8Bokhttp6-callserverinterceptor/</guid>
      <description>终于来到了最后一个拦截器，主要是通过上一个拦截器建立起来的连接通道通过交换机进行数据 包装发送 和 接受解包。
 写入请求 Header 如果请求头的 Expect: 100-continue 时，只发送请求头 根据返回的结果判断是否继续请求流程 写入请求体，完成请求 得到响应头，构建初步响应 构建响应体，完成最终响应 返回响应  下一篇就开始看看Sink和RequestBody及ResponseBody</description>
    </item>
    
    <item>
      <title>Android源码一步一步分析系列之OkHttp(5)——ConnectInterceptor</title>
      <link>https://helixs.github.io/posts/2020-04-10-android%E6%BA%90%E7%A0%81%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8Bokhttp5-connectinterceptor/</link>
      <pubDate>Fri, 10 Apr 2020 06:17:06 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2020-04-10-android%E6%BA%90%E7%A0%81%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8Bokhttp5-connectinterceptor/</guid>
      <description>ConnectInterceptor拦截器里面的东西不多，主要是调用了连接池里面的东西。
为什么需要这个拦截器，当我们每次发送一次Http请求的时候，如果每次都进行TCP3次握手，耗费的时间和精力是很多的。
在Http1.1中通过增加了head字段Connection和Keep-Alive来告诉服务器保持一个常在连接通道，那么后面很多的request请求在这个时间范围内都可以用这个连接进行发送。
这个拦截器就是来干这个事的。
我们下面来看看
进入newExchange
进入find
进入findHealthyConnection
进入findConnection
进入RealConnectionPool.transmitterAcquirePooledConnection
进入RealConnectionPool.isEligible
isEligible返回后进入 Transmitter.acquireConnectionNoEvents(connection);
告一段落
 在findConnection方法后面，会有一个put方法把创建新的连接加入到连接池connectionPool中，进入put方法
 连接池的代码较多，主要就是复用连接，创建连接，保存连接，移除连接的操作。
 </description>
    </item>
    
    <item>
      <title>Android源码一步一步分析系列之OkHttp(4)——CacheInterceptor</title>
      <link>https://helixs.github.io/posts/2020-04-09-android%E6%BA%90%E7%A0%81%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8Bokhttp3-cacheinterceptor/</link>
      <pubDate>Thu, 09 Apr 2020 05:16:19 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2020-04-09-android%E6%BA%90%E7%A0%81%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8Bokhttp3-cacheinterceptor/</guid>
      <description>CacheInterceptor主要是处理缓存的拦截器，其实他不是自己的一些什么缓存机制。基本上还是根据http的缓存协议基础上，进行缓存本地化的改造操作。
我们要了解缓存就必须理解Http缓存协议—彻底弄懂HTTP缓存机制及原理如果大家对缓存协议不清楚，最好看一下上面的内容，Okhttp缓存就是根据它的协议进行开发的，没有太大的改造。
CacheInterceptor流程
&amp;lt;pre class=&amp;quot;EnlighterJSRAW&amp;quot; data-enlighter-language=&amp;quot;java&amp;quot; data-enlighter-theme=&amp;quot;atomic&amp;quot;&amp;gt;/*  Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the &amp;ldquo;License&amp;rdquo;); you may not use this file except in compliance with the License. You may obtain a copy of the License at *  http://www.</description>
    </item>
    
    <item>
      <title>Android源码一步一步分析系列之OkHttp(3)——BridgeInterceptor</title>
      <link>https://helixs.github.io/posts/2020-04-07-android%E6%BA%90%E7%A0%81%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8Bokhttp3-bridgeinterceptor/</link>
      <pubDate>Tue, 07 Apr 2020 10:09:27 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2020-04-07-android%E6%BA%90%E7%A0%81%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8Bokhttp3-bridgeinterceptor/</guid>
      <description>了解更多请看
Android源码一步一步分析系列之OkHttp(1)——揭开面纱Android源码一步一步分析系列之OkHttp(2)——RetryAndFollowUpInterceptor BridgeInterceptor这个拦截器类容比较简单 主要是包装head和处理压缩数据的
 </description>
    </item>
    
    <item>
      <title>每日一篇leetcode之-矩阵旋转</title>
      <link>https://helixs.github.io/posts/2020-04-07-%E6%AF%8F%E6%97%A5%E4%B8%80%E7%AF%87leetcode%E4%B9%8B-%E7%9F%A9%E9%98%B5/</link>
      <pubDate>Tue, 07 Apr 2020 08:18:18 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2020-04-07-%E6%AF%8F%E6%97%A5%E4%B8%80%E7%AF%87leetcode%E4%B9%8B-%E7%9F%A9%E9%98%B5/</guid>
      <description>来源https://leetcode-cn.com/problems/rotate-matrix-lcci/ 解题思路 这里的N*N矩阵就会一个二维数组，并且行数=列数。操作旋转90度。我们发现一个很有意思的规律
转换后，现数据列数=总行数-原数据行数-1 ，现数据行数=原数据列数直接上代码吧
总的来说，注意一下深拷贝的问题，其实还是很简单啦。
 </description>
    </item>
    
    <item>
      <title>Android源码一步一步分析系列之OkHttp(2)——RetryAndFollowUpInterceptor</title>
      <link>https://helixs.github.io/posts/2020-04-07-android%E6%BA%90%E7%A0%81%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8Bokhttp2-retryandfollowupinterceptor/</link>
      <pubDate>Tue, 07 Apr 2020 05:38:46 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2020-04-07-android%E6%BA%90%E7%A0%81%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8Bokhttp2-retryandfollowupinterceptor/</guid>
      <description>可以看一下上一篇文章
Android源码一步一步分析系列之OkHttp(1)——揭开面纱   RetryAndFollowUpInterceptor拦截器是满足一定条件下用来处理失败重试和重定向的一些操作。
 </description>
    </item>
    
    <item>
      <title>Android源码一步一步分析系列之OkHttp(1)——揭开面纱</title>
      <link>https://helixs.github.io/posts/2020-04-02-android%E6%BA%90%E7%A0%81%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8Bokhttp1-%E6%8F%AD%E5%BC%80%E9%9D%A2%E7%BA%B1/</link>
      <pubDate>Thu, 02 Apr 2020 10:53:46 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2020-04-02-android%E6%BA%90%E7%A0%81%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8Bokhttp1-%E6%8F%AD%E5%BC%80%E9%9D%A2%E7%BA%B1/</guid>
      <description>说来很惭愧，做了这么多年Android没有仔仔细细的看过Okhttp源代码，空余时间都在学习些周边的技术。现在按照新手方式看一步写一步。
OkHttp就是一种HTTP客户端连接，它有如下特性：
 HTTP/2多路复用Socket到同一个主机，共享链接。 采用连接池技术，可以有效的减少Http链接数量。 无缝集成GZIP压缩技术。 支持Response Cache，避免重复请求。 域名多IP支持。  OkHttp会自动管理HTTP连接的生命周期：
 操作Response.body().string()等类型的API，OkHttp会自动将该HTTP连接加入到ConnectionPool中或者直接释放连接 如果采用stream方式操作流，则需要自己手动关闭，否则会发生HTTP连接泄漏（OkHttp通过WeakReference机制，尽最大努力管理这些泄漏的HTTP连接） OkHttp不读取Resonse#Head#Keep-Alive属性来决定该HTTP连接是否能复用，而是直接加入到ConnectionPool进行复用 当从ConnectionPool中获取HTTP连接的时候，OkHttp发现该HTTP连接已经失效，则关闭该连接，并且重新选择一个HTTP连接进行复用  GET 请求 基于3.14版本，最新的4.x版本全部都使用了kotlin编写。实在话，kotlin是门好语言，不过看代码还是java比较舒服
OkHttpClient
开启一个同步请求 开启一个异步请求  </description>
    </item>
    
    <item>
      <title>Android SAF储存访问框架</title>
      <link>https://helixs.github.io/posts/2020-03-30-android-saf%E5%82%A8%E5%AD%98%E8%AE%BF%E9%97%AE%E6%A1%86%E6%9E%B6/</link>
      <pubDate>Mon, 30 Mar 2020 07:22:04 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2020-03-30-android-saf%E5%82%A8%E5%AD%98%E8%AE%BF%E9%97%AE%E6%A1%86%E6%9E%B6/</guid>
      <description>Android 4.4（API 级别 19）引入了存储访问框架 (SAF)。借助 SAF，用户可轻松在其所有首选文档存储提供程序中浏览并打开文档、图像及其他文件。用户可通过易用的标准界面，以统一方式在所有应用和提供程序中浏览文件，以及访问最近使用的文件。
云存储服务或本地存储服务可实现封装其服务的 ``DocumentsProvider ，进而参与此生态系统。只需几行代码，便可将需要访问提供程序文档的客户端应用与 SAF 进行集成。
简单的来说，不需要自己主动读取sdcard的媒体和文档，系统给你统一的UI，统一的选择器，让你获取资料。
SAF 包含以下内容：
 文档提供程序 — 一种内容提供程序，可让存储服务（如 Google Drive）显示其管理的文件。文档提供程序以 ``DocumentsProvider 类的子类形式实现。文档提供程序的架构基于传统的文件层次结构，但其实际的数据存储方式由您决定。Android 平台包含若干内置文档提供程序，如 Downloads、Images 和 Videos。 客户端应用 — 一种自定义应用，它会调用 [ACTION\_OPEN\_DOCUMENT][2] 或 ACTION_CREATE_DOCUMENT ACTION_OPEN_DOCUMENT_TREE这三种Intent的Action,来实现打开，创建文档，以及打开文档树。 选择器 — 一种系统界面，可让用户访问所有满足客户端应用搜索条件的文档提供程序内的文档。           左边是我们的客户端， 中间SystemUI 选择器， 右边是我们的文档提供程序 就是实现了_DocumentsProvider 的提供方_
在 Android 4.3 及更低版本中，如果您想让应用从其他应用中检索文件，则该应用必须调用 [ACTION_PICK][4] 或 ACTION_GET_CONTENT 等 Intent。然后，用户必须选择一个要从中选取文件的应用，并且所选应用必须提供用户界面，以便用户浏览和选取可用文件。
在 Android 4.4 及更高版本中，您还可选择使用 ``ACTION_OPEN_DOCUMENT Intent，此 Intent 会显示由系统控制的选择器界面，以便用户浏览其他应用提供的所有文件。借助此界面，用户便可从任何受支持的应用中选取文件。
[ACTION\_OPEN\_DOCUMENT][2] 并非用于代替 ACTION_GET_CONTENT 。您应根据应用需求选择所使用的 Intent：</description>
    </item>
    
    <item>
      <title>每日一篇leetcode之-按摩师</title>
      <link>https://helixs.github.io/posts/2020-03-24-%E6%AF%8F%E6%97%A5%E4%B8%80%E7%AF%87leetcode%E4%B9%8B-%E6%8C%89%E6%91%A9%E5%B8%88/</link>
      <pubDate>Tue, 24 Mar 2020 09:00:00 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2020-03-24-%E6%AF%8F%E6%97%A5%E4%B8%80%E7%AF%87leetcode%E4%B9%8B-%E6%8C%89%E6%91%A9%E5%B8%88/</guid>
      <description>一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。给定一个预约请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。
注意：本题相对原题稍作改动
 示例 1：
输入： [1,2,3,1]
输出： 4
解释： 选择 1 号预约和 3 号预约，总时长 = 1 + 3 = 4。
示例 2：
输入： [2,7,9,3,1]
输出： 12
解释： 选择 1 号预约、 3 号预约和 5 号预约，总时长 = 2 + 9 + 1 = 12。
示例 3：
输入： [2,1,4,5,3,1,1,3]
输出： 12
解释： 选择 1 号预约、 3 号预约、 5 号预约和 8 号预约，总时长 = 2 + 4 + 3 + 3 = 12。
来源：力扣（LeetCode）</description>
    </item>
    
    <item>
      <title>每日一篇leetcode之-买卖股票的最佳时机 II</title>
      <link>https://helixs.github.io/posts/2020-03-19-%E6%AF%8F%E6%97%A5%E4%B8%80%E7%AF%87leetcode%E4%B9%8B-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-ii/</link>
      <pubDate>Thu, 19 Mar 2020 10:34:57 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2020-03-19-%E6%AF%8F%E6%97%A5%E4%B8%80%E7%AF%87leetcode%E4%B9%8B-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-ii/</guid>
      <description>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。
设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。
**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
示例 1:
输入:
输出:
解释:
示例 2:
输入:
输出:
解释:
示例 3:
输入:
输出:
解释:
来自leetcode https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/ 分析：
1、[p1…..pn]为连续的交易日价格数组
2、必须买入在接下来的任意一天卖出，不可同时持有股票。
3、可以任意多次购买，但不能违背要求2
4、利润最大化
分析这张图
              可以看一下利润最大化只能是将所有的爬坡阶段加起来，中间下坡就是亏钱，所以不考虑。
 </description>
    </item>
    
    <item>
      <title>每日一篇leetcode之-最长回文串</title>
      <link>https://helixs.github.io/posts/2020-03-19-%E6%AF%8F%E6%97%A5%E4%B8%80%E7%AF%87leetcode%E4%B9%8B-2/</link>
      <pubDate>Thu, 19 Mar 2020 07:25:17 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2020-03-19-%E6%AF%8F%E6%97%A5%E4%B8%80%E7%AF%87leetcode%E4%B9%8B-2/</guid>
      <description>给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。
在构造过程中，请注意区分大小写。比如 &amp;quot;Aa&amp;quot; 不能当做一个回文字符串。
注意:
假设字符串的长度不会超过 1010。
示例 1:
题目来源 https://leetcode-cn.com/problems/longest-palindrome/ 开始解题，以来就直接想到了Hash表，表节点直接表示字符数量，要求是英文字母大小写，就是26*2=52个空间节点。上代码：
这个方法很像我前两天写的hash表拼接单词每日一篇leetcode之-拼写单词下面是官方的答案 感觉一般般
 </description>
    </item>
    
    <item>
      <title>每日一篇leetcode之-矩形重叠</title>
      <link>https://helixs.github.io/posts/2020-03-18-%E6%AF%8F%E6%97%A5%E4%B8%80%E7%AF%87leetcode%E4%B9%8B/</link>
      <pubDate>Wed, 18 Mar 2020 06:07:51 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2020-03-18-%E6%AF%8F%E6%97%A5%E4%B8%80%E7%AF%87leetcode%E4%B9%8B/</guid>
      <description>矩形以列表 [x1, y1, x2, y2] 的形式表示，其中 (x1, y1) 为左下角的坐标，(x2, y2) 是右上角的坐标。
如果相交的面积为正，则称两矩形重叠。需要明确的是，只在角或边接触的两个矩形不构成重叠。
给出两个矩形，判断它们是否重叠并返回结果。
 示例 1：
输入：rec1 = [0,0,2,2], rec2 = [1,1,3,3]
输出：true
示例 2：
输入：rec1 = [0,0,1,1], rec2 = [1,0,2,1]
输出：false
_ _
提示：
两个矩形 rec1 和 rec2 都以含有四个整数的列表的形式给出。
矩形中的所有坐标都处于 -10^9 和 10^9 之间。
x 轴默认指向右，y 轴默认指向上。
你可以仅考虑矩形是正放的情况。
来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/rectangle-overlap 
未参考的解答思路 花了一个草图来想象两个矩形
            矩形A1 矩形A2，按照A2不动的标准来跟A1作比较，如果两个不想交就说明需要满足两个XY方向条件
[A1(x1)≤A2(x0)||A1(x0)≥A2(x1)]&amp;amp;&amp;amp;[A1(y1)≤A2(y0)||A1(y0)≥A2(y1)]
计算了半天发现错了，因为不必满足所有条件，因为满足其中一个就行了，画蛇添足</description>
    </item>
    
    <item>
      <title>每日一篇leetcode之-拼写单词</title>
      <link>https://helixs.github.io/posts/2020-03-17-%E6%AF%8F%E6%97%A5%E4%B8%80%E7%AF%87leetcode%E4%B9%8B%E6%8B%BC%E5%86%99%E5%8D%95%E8%AF%8D/</link>
      <pubDate>Tue, 17 Mar 2020 07:18:37 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2020-03-17-%E6%AF%8F%E6%97%A5%E4%B8%80%E7%AF%87leetcode%E4%B9%8B%E6%8B%BC%E5%86%99%E5%8D%95%E8%AF%8D/</guid>
      <description>给你一份『词汇表』（字符串数组） words 和一张『字母表』（字符串） chars。
假如你可以用 chars 中的『字母』（字符）拼写出 words 中的某个『单词』（字符串），那么我们就认为你掌握了这个单词。
注意：每次拼写时，chars 中的每个字母都只能用一次。
返回词汇表 words 中你掌握的所有单词的 长度之和。
 示例 1：
输入：words = [“cat”,”bt”,”hat”,”tree”], chars = “atach”
输出：6
解释：
可以形成字符串 “cat” 和 “hat”，所以答案是 3 + 3 = 6。
示例 2：
输入：words = [“hello”,”world”,”leetcode”], chars = “welldonehoneyr”
输出：10
解释：
可以形成字符串 “hello” 和 “world”，所以答案是 5 + 5 = 10。
_ _
提示：
1 &amp;lt;= words.length &amp;lt;= 1000
1 &amp;lt;= words[i].length, chars.length &amp;lt;= 100
所有字符串中都仅包含小写英文字母
通过次数21,660提交次数31,246</description>
    </item>
    
    <item>
      <title>树和二叉树基本特性(2)</title>
      <link>https://helixs.github.io/posts/2020-03-16-%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A72/</link>
      <pubDate>Mon, 16 Mar 2020 09:19:37 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2020-03-16-%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A72/</guid>
      <description>查找二叉树（Binary Sort Tree 二叉排序树）的基本定义 1、若查找树的左子树非空，则其左子树上的各个节点值均小于根节点的值
2、若查找树的右子树非空，则其右子树上的各个节点值均大于根节点的值
3、查找树的左右子树各是一棵查找树。
查找 查找就是比较大小 没啥好说的
插入 1、如果相同键值的节点已在查找二叉树中，则不插入
2、如果查找二叉树为空树，则以新节点为查找二叉树
3、将要插入的节点与即将插入的父节点作比较，确定左右子节点插入
删除 1、如果要删除的节点是叶子节点就直接删除
2、如果删除的节点只有一个子节点，那么就直接连接子节点，然后删除
3、若要删除的节点P有两个子节点，则在其左子树上，用中序遍历需找最大的节点S，用节点S的值代替节点P的值，然后删除节点S，节点S必属于上述1,2情况之1(
 找出左子树中最大或者右子树中最小的值val 将当前节点的值替换为val 在左子树或者右子树中找到val删除  )</description>
    </item>
    
    <item>
      <title>树和二叉树基本特性(1)</title>
      <link>https://helixs.github.io/posts/2020-03-16-%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A71/</link>
      <pubDate>Mon, 16 Mar 2020 03:21:03 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2020-03-16-%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A71/</guid>
      <description>树的基本概念就不介绍了，直接上干活
概念：  1、树的总结点数为n，总度数为k，那么n=k+1
因为度数就相当于子节点的个数，根节点就是那个+1
节点的度：一个节点有几个子节点就是有几度。树的读：所有节点中，有几个节点有分叉，就相当于树的度。例题.在一棵度为3的树中，有2个度为3的节点，1个度为2的节点，则有_x_个度为0的节点。求x。_
解：树的度为3，就相当于3个有分叉的节点，其他都是叶子节点，因为n=k+1。
得到n=3*2+2*1+0*x =&amp;gt;n=9
9-2-1=6 x = 6
2、二叉树的重要特性
1、在二叉树的第i层上，最多有2^(i-1)个节点（i≥1）；
2、深度为k的二叉树最多有(2^k)-1个节点(i≥1)；
3、对任何一颗二叉树，如果其叶子结点数为N0，度为2的节点数为N2，则N0=N2+1；
4、具有n个结点的完全二叉树的深度为floor(log2n) + 1
5、如果对一棵有n个结点的完全二叉树（其深度为floor(log2n) + 1 ）的结点按层序编号，则对任一结点i（1≤i≤n）有：
（1） 如果i = 1，则结点i是二叉树的根，无双亲；如果i &amp;gt; 1，则其双亲PARENT(i)是结点 floor((i)/2)
（2）如果2i &amp;gt; n，则结点i无左孩子；否则其左孩子LCHILD(i)是结点2i
（3）如果2i + 1 &amp;gt; n，则结点i无右孩子；否则其右孩子RCHILD(i)是结点2i + 1
floor向下取整 二叉树通常作为数据结构应用，典型用法是对节点定义一个标记函数，将一些值与每个节点相关系。这样标记的二叉树就可以实现二叉搜索树和二叉堆，并应用于高效率的搜索和排序。
例题：一个具有767个节点的完全二叉树，其叶子结点个数为_X_个。 求X
根据上面第三点 对任何一颗二叉树，如果其叶子结点数为N0，度为2的节点数为N2，则N0=N2+1；
N = N0 + (N2 +1)=2N2+1
767 = 2N2+1
N2 = 383
X = N2+1 = 383+1 = 384
二叉树的遍历             前序1，2，4，5，7，8，3，6</description>
    </item>
    
    <item>
      <title>Navicat各版本(包括15)通用激活教程</title>
      <link>https://helixs.github.io/posts/2020-03-12-navicat%E5%90%84%E7%89%88%E6%9C%AC%E5%8C%85%E6%8B%AC15%E9%80%9A%E7%94%A8%E6%BF%80%E6%B4%BB%E6%95%99%E7%A8%8B/</link>
      <pubDate>Thu, 12 Mar 2020 08:39:49 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2020-03-12-navicat%E5%90%84%E7%89%88%E6%9C%AC%E5%8C%85%E6%8B%AC15%E9%80%9A%E7%94%A8%E6%BF%80%E6%B4%BB%E6%95%99%E7%A8%8B/</guid>
      <description>Navicat是比较好的数据库管理软件，可是真的好贵啊，公司企业那些一直在用付费很正常，普通用户也不是一直用，所以很划不来。不过还是要支持正版。
下载Navicat https://www.navicat.com.cn/products  最新版本已经是15了，下载完成后安装，记得安装目录就行
下载激活工具 Navicat Software – Patch/Keygen 原始链接(可能出现网站不稳定的情况)
根据浪儿提供的地址 https://www.lanzous.com/b0bkap39e 5p9d如果下载不了请关闭杀毒软件，或者信任。当然我也不知道有没有毒。哈哈
断网 1、 打开激活工具，默认选中了Backup和Host，然后选择Navicat的版本，之后点击patch。
弹窗选择框到Navicat安装目录选中navicat.exe完成
              2、选中你的协议和products(mysql啊orancle等等)
3、点击Generate生成激活码，复制激活码
4、打开navicat，输入激活码，弹窗则手动，复制requestCode
5、打开激活工具粘贴到requestCode，点击Generate生成ActivationCode，复制
6、打开navicat粘上去，激活成功
可以看看下面这个教程
https://juejin.im/post/5d8081b0e51d4561d54dea19  本博客不提供任何文件下载服务，链接资源均搜集子网上，如果出现侵权行为，请关闭此页面。  </description>
    </item>
    
    <item>
      <title>安装mariadb设置初始密码及配置</title>
      <link>https://helixs.github.io/posts/2020-03-11-%E5%AE%89%E8%A3%85mariadb%E8%AE%BE%E7%BD%AE%E5%88%9D%E5%A7%8B%E5%AF%86%E7%A0%81/</link>
      <pubDate>Wed, 11 Mar 2020 10:49:51 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2020-03-11-%E5%AE%89%E8%A3%85mariadb%E8%AE%BE%E7%BD%AE%E5%88%9D%E5%A7%8B%E5%AF%86%E7%A0%81/</guid>
      <description>初始密码的问题 安装MariaDb后按照网上说的什么mysql -u root -p 根本进不去啊，要输入密码，直接回车也不行。下面可以解决
root用户远程访问数据库 root用户默认值只允许localhost，所以需要修改root用户的访问权限，不然在会拒绝连接。
默认是3306端口号，记得开启端口，如果是云服务器记得配置3306的安全组
还有如果是本地的防火墙可以参考centos7 防火墙端口配置和SSH端口配置 做完之后登录mysql -u root -p.表示所有ip可以进来，password表示root用户远程登录的密码，不是原来的密码，记得设置。然后就可以啦
 navicat安装教程 Navicat各版本(包括15)通用激活教程 </description>
    </item>
    
    <item>
      <title>Android调用DownloadManager下载文件及安装apk，兼容6、7、8&#43;</title>
      <link>https://helixs.github.io/posts/2020-03-11-android%E8%B0%83%E7%94%A8downloadmanager%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%E5%8F%8A%E5%AE%89%E8%A3%85apk%E5%85%BC%E5%AE%B9678/</link>
      <pubDate>Wed, 11 Mar 2020 01:53:58 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2020-03-11-android%E8%B0%83%E7%94%A8downloadmanager%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%E5%8F%8A%E5%AE%89%E8%A3%85apk%E5%85%BC%E5%AE%B9678/</guid>
      <description>我们的app经常有需求下载文件等，还有就是下载安装。
1、下载文件的方式 1,很多三方框架都有文件上传下载功能，可以借助三方框架(比如Volley,OkHttp,或者还有个很不错的库OKdownload,不过这个库比较重量级，我们只做简单的下载就不太需要啦)
2,也可以开启一个线程去下载,（可以用IntentService）
3，最简单的一种方式：Android SDK 其实给我们提供了下载类DownloadManager,只需要简单的配置项设置，就能轻松实现下载功能。
DownloadManager 是SDK 自带的，大概流程如下：
（1）创建一个Request,进行简单的配置（下载地址，和文件保存地址等）
（2）下载完成后，系统会发送一个下载完成的广播，我们需要监听广播。
（3）监听到下载完成的广播后，根据id查找下载的apk文件
（4）在代码中执行apk安装。
Activity中使用
简单的使用就是这些，有问题可以评论哦</description>
    </item>
    
    <item>
      <title>Ubuntu开机错误 couldn’t find an input interrupt /dev/sda1 contains a file system with errors</title>
      <link>https://helixs.github.io/posts/2020-02-29-ubuntu%E5%BC%80%E6%9C%BA%E9%94%99%E8%AF%AF-couldnt-find-an-input-interrupt-dev-sda1-contains-a-file-system-with-errors/</link>
      <pubDate>Sat, 29 Feb 2020 11:21:58 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2020-02-29-ubuntu%E5%BC%80%E6%9C%BA%E9%94%99%E8%AF%AF-couldnt-find-an-input-interrupt-dev-sda1-contains-a-file-system-with-errors/</guid>
      <description>更新系统软件后，非正常关机，出现了
 couldn&#39;t find an input interrupt dev/sda1 contains a file system with errors, check forced. Inodes that were part of a corrupted orphan linked list found. /dev/sda1: UNEXPECTED INCONSISTENCY: RUN fsck MANUALLY. (i.e., without -a or -p options) fsck exited with status code 4 The root filesystem on /dev/sda1 requires a manual fsck BusyBox v1.22.1 (Ubuntu 1:1.22.0-19ubuntuu2) built-in shell (ash) Enter &#39;help&#39; for a list of built-in commands. (initramfs)_  键入fsck -f /dev/sda1以检查/修复您的文件系统。</description>
    </item>
    
    <item>
      <title>android对finishAffinity的简单认识</title>
      <link>https://helixs.github.io/posts/2019-12-16-android%E5%AF%B9finishaffinity%E7%9A%84%E7%AE%80%E5%8D%95%E8%AE%A4%E8%AF%86/</link>
      <pubDate>Mon, 16 Dec 2019 08:50:53 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2019-12-16-android%E5%AF%B9finishaffinity%E7%9A%84%E7%AE%80%E5%8D%95%E8%AE%A4%E8%AF%86/</guid>
      <description>大多数简单的Android应用我们都是直接startActivity启动和finish完成销毁。慢慢我们根据应用的各个场景及跳转复杂度开始使用了lanchMode诸如singleTask singleTop，NewTask等等。用是用了，但是用的是不清不楚不明不白，倘若面试疑问就是一脸懵逼。今天着重看看Task栈和finishAffinity的用法，不过在这之前还是找找启动模式的一些资料，先到网上翻阅，看看人们是怎么说的。
Activity 启动模式和任务栈 任务栈（tasks-and-back-stack） 创建任务栈 在两种情况下，有可能会创建一个新的任务栈：
（1）以 FLAG_ACTIVITY_NEW_TASK 方式启动一个 activity；
（2）在 AndroidManifest.xml 中配置了 android:taskAffinity。
如果我们使用 startActivity 启动一个 Activity，没有添加任何 flag 时，新启动的 Activity 会与调用 startActivity 的 Activity 位于同一个任务栈中；在默认情况下，应用内的所有 Activity 都会被存放在以包名命名的任务栈中。
当我们以 FLAG_ACTIVITY_NEW_TASK 方式启动一个 Activity 时，如果某个任务栈里已经有该 Activity 了，那么会将该任务栈从后台切换到前台，也即从停止状态切换到活跃状态，否则先创建一个新的任务栈，将创建一个 Activity 实例，将该实例作为 Root Activity（任务栈最底部的 Activity）。
如果在当前的任务栈中，按照FLAG_ACTIVITY_NEW_TASK启动当前根Activity是无法启动的。如果同样方式启动android:taskAffinity一致但是Activity不一样也不会启动新的任务栈，而是在当前任务栈启动一个新的Activity。 西门笔者试了一下，在默认的lanchMode下，如果要使用FLAG_ACTIVITY_NEW_TASK切换任务栈或者创建新的任务栈要同时满足两个需求，1、当且仅当当前任务栈的RootActivityandroid:taskAffinity和被启动的Activity的android:taskAffinity不一致2、如果要切换在后台的任务栈，需要满足被启动的Acitivity在其他某个任务栈的作为Root节点，不过相应的，你看看在没有魔改的android系统的多任务栏切换是不是多了那么多个taskAffinity窗口呢，哈哈~~~所以看看微信小程序是不是也是动态生成的小程序的任务栈。不过，如果同时也添加了 Intent.FLAG_ACTIVITY_MULTIPLE_TASK 属性，那么系统会无条件创建一个新的任务栈。
如果要启动的 Activity 配置了 android:taskAffinity，那么系统会将该 Activity 放到对应的任务栈中。
销毁任务栈  当我们从最近任务中移除对应的任务时，该任务栈也会被移除。从 Android 5.x 起，重启后任务栈可以被恢复。（see[持久化的任务栈][持久化的任务栈]） 当任务栈中已经没有 Activity 时，该任务栈会被自动销毁。 当系统内存较少时，任务栈也有可能被移除，只保留重建该任务栈需要的信息。  当任务栈被销毁时，之前在任务栈中的 Activity 关联的服务会触发 onTaskStopped() 回调，可以决定是否要结束服务；如果在 AndroidManifest.xml 设置 android:stopWithTask=&amp;quot;true&amp;quot;（默认 false），则不会接收到该回调，同时服务会自动被销毁。不过在 Android 4.</description>
    </item>
    
    <item>
      <title>Android MaterialButton的一些问题</title>
      <link>https://helixs.github.io/posts/2019-11-28-android-materialbutton%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</link>
      <pubDate>Thu, 28 Nov 2019 03:34:18 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2019-11-28-android-materialbutton%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</guid>
      <description>MaterialButton和MaterialCardView的都新增了边框属性，我们没必要为了一个边框写那么多shape，一旦多了谁着得住。
1、在使用MaterialButton注意一点是它必须设置android:textAppearance属性，不然会崩溃 This component requires that you specify a valid TextAppearance attribute. Update your app theme to inherit from Theme.MaterialComponents (or a descendant)它会检查textApearance属性，解决方式有两种如下:
1、添加它就好
2、application或activity或控件的theme继承自Theme.MaterialComponents.xxxx,使type能够找到这个属性，如
其实想了想，也许以后MaterialComponents的text相关组件都会进行这种操作吧。
2、在使用MaterialButton时候可能遇到背景颜色不能充满控件的问题。 如果按照以前默认的方式添加背景颜色，我们发现背景颜色不能充满上下编剧，我们对比使用appcompatButton
      1、从上面的图片可以看出它们的背景颜色不一样。MaterialButton是不受android:background控制的，官方建议我们设置app:backgroundHint来进行背景的更改。
2、AppCompatButton如果设置了android:background会覆盖上下左右的间距，MaterialButton则不会
3、MaterialButton设置了app:backgroundHint左右是没有间距的，而上下有。AppCompatButton设置了app:backgroundHint是上下左右都有间距
找到原因https://github.com/material-components/material-components-android/blob/master/docs/components/MaterialButton.md#attributes Note: MaterialButton is visually different from Button and AppCompatButton. One of the main differences is that AppCompatButton has a 4dp inset on the left and right sides, whereas MaterialButton does not. To add an inset to match AppCompatButton, set android:insetLeft and android:insetRight on the button to 4dp, or change the spacing on the button’s parent layout.</description>
    </item>
    
    <item>
      <title>Java线程池中SynchronousQueue、LinkedBlockingQueue和ArrayBlockingQueue</title>
      <link>https://helixs.github.io/posts/2019-09-27-java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%ADsynchronousqueuelinkedblockingqueue%E5%92%8Carrayblockingqueue/</link>
      <pubDate>Fri, 27 Sep 2019 06:30:21 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2019-09-27-java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%ADsynchronousqueuelinkedblockingqueue%E5%92%8Carrayblockingqueue/</guid>
      <description>作为一个普通的Android开发者来说，平常布布控件和各种框架的情况下，接触线程的地方少之又少，更别提线程池了。以前基础差，做项目的时候牵扯到异步操作的时候呢都是直接Thread+handler根本没考虑后果，做完事就行。面试的时候就是被按在地上一顿摩擦。
在alibaba开发手册上，这样写到：
【强制】新建线程时，必须通过线程池提供（AsyncTask 或者ThreadPoolExecutor或者其他形式自定义的线程池），不允许在应用中自行显式创建线程。
_ 说明：使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。另外创建匿名线程不便于后续的资源使用分析，对性能分析等会造成困扰。_
所以我们在进阶开发的时候特别涉及到大量数据操作的时候很有必要使用线程池来管理我们的线程任务。
线程池创建 Android中常用的线程池都是通过对ThreadPoolExecutor进行不同配置来实现的，下面是它的构造方法
 corePoolSize线程池中核心线程的数量 maximumPoolSize 线程池中最大线程数量（其中包括了核心线程） keepAliveTime当线程数大于核心时，这是多余的空闲线程在终止之前等待新任务的最长时间，也就是非核心线程的超时时长，当系统中非核心线程闲置时间超过keepAliveTime之后，则会被回收。如果ThreadPoolExecutor的allowCoreThreadTimeOut属性设置为true，则该参数也表示核心线程的超时时长 unitkeepAliveTime 的时间单位多数情况下按照秒和毫秒来做 workQueueBlockingQueue的实现类 在执行任务之前用于保留任务的队列。该队列将仅保存由ThreadPoolExecutor.execute方法提交的 Runnable任务。这也是我们这片文章的重点内容 threadFactory线程池在创建线程的工厂类，如果不传入默认会有一个Executors.defaultThreadFactory() handler拒绝策略，当线程无法执行新任务时（一般是由于线程池中的线程数量已经达到最大数或者线程池关闭导致的），默认情况下，当线程池无法处理新线程时，会抛出一个RejectedExecutionException。  了解到了它的构造方法后我们来捋一捋，看一下ThreadPoolExecutor.execute方法
ctl是AtomicInteger类型，(里面保存了当前线程池中有效线程数量count和当前线程池运行的状态runState，count的增减同步，保证每次get的时候数量是最新的，所谓的原子性。每次我们都只用get的值，里面是用位运算符关联两个值的。位运算我一脸懵逼反正它保存了两个值了)。如果当前运行的线程的数量小于核心线程数量(就是我们在构造方法传入的corePoolSize)，那么就正常添加并执行任务。如果没有添加成功，就继续检查当前线程池的运行状态，如果还是在运行中，那么尝试通过blockingQueue的offer方法(记住只有offer方法，后面讲的那么这个线程池没用上)把Runnable放到任务队列中（后续核心线程如果有任务完成，那么就从这个队列中使用take方法取出Runnable放入到核心线程去执行任务）。如果加入成功到队列中，检查线程池状态，如果线程池在运行，那么就删除添加的Runnable，如果一切成功就抛出RejectedExecutionException。后面都看得懂就不解释了。
过程如下
 execute一个线程之后，如果线程池中的线程数未达到核心线程数，则会立马启用一个核心线程去执行。 execute一个线程之后，如果线程池中的线程数已经达到核心线程数，且workQueue未满，则将新线程放入workQueue中等待执行。 execute一个线程之后，如果线程池中的线程数已经达到核心线程数但未超过非核心线程数，且workQueue已满，则开启一个非核心线程来执行任务。 execute一个线程之后，如果线程池中的线程数已经超过非核心线程数，则拒绝执行该任务。   BlockingQueue 下面引入网上对BlockingQueue的主要方法的解释
&amp;lt;td align=&amp;quot;center&amp;quot;&amp;gt; &amp;lt;em&amp;gt;&amp;lt;strong&amp;gt;抛出异常&amp;lt;/strong&amp;gt;&amp;lt;/em&amp;gt; &amp;lt;/td&amp;gt; &amp;lt;td align=&amp;quot;center&amp;quot;&amp;gt; &amp;lt;em&amp;gt;&amp;lt;strong&amp;gt;特殊值&amp;lt;/strong&amp;gt;&amp;lt;/em&amp;gt; &amp;lt;/td&amp;gt; &amp;lt;td align=&amp;quot;center&amp;quot;&amp;gt; &amp;lt;em&amp;gt;&amp;lt;strong&amp;gt;阻塞&amp;lt;/strong&amp;gt;&amp;lt;/em&amp;gt; &amp;lt;/td&amp;gt; &amp;lt;td align=&amp;quot;center&amp;quot;&amp;gt; &amp;lt;em&amp;gt;&amp;lt;strong&amp;gt;超时&amp;lt;/strong&amp;gt;&amp;lt;/em&amp;gt; &amp;lt;/td&amp;gt;  &amp;lt;td&amp;gt; &amp;lt;a href=&amp;quot;http://blog.csdn.net/itm_hadf/article/details/7538083&amp;quot; rel=&amp;quot;nofollow&amp;quot; data-token=&amp;quot;d84ab2ded6a50457642e83b0a8a699b4&amp;quot;&amp;gt;&amp;lt;code&amp;gt;&amp;lt;/code&amp;gt;&amp;lt;strong&amp;gt;add(e)&amp;lt;/strong&amp;gt;&amp;lt;/a&amp;gt; &amp;lt;/td&amp;gt; &amp;lt;td&amp;gt; &amp;lt;a href=&amp;quot;http://blog.csdn.net/itm_hadf/article/details/7538083&amp;quot; rel=&amp;quot;nofollow&amp;quot; data-token=&amp;quot;d84ab2ded6a50457642e83b0a8a699b4&amp;quot;&amp;gt;&amp;lt;code&amp;gt;&amp;lt;/code&amp;gt;&amp;lt;strong&amp;gt;offer(e)&amp;lt;/strong&amp;gt;&amp;lt;/a&amp;gt; &amp;lt;/td&amp;gt; &amp;lt;td&amp;gt; &amp;lt;a href=&amp;quot;http://blog.csdn.net/itm_hadf/article/details/7538083&amp;quot; rel=&amp;quot;nofollow&amp;quot; data-token=&amp;quot;d84ab2ded6a50457642e83b0a8a699b4&amp;quot;&amp;gt;&amp;lt;code&amp;gt;&amp;lt;/code&amp;gt;&amp;lt;strong&amp;gt;put(e)&amp;lt;/strong&amp;gt;&amp;lt;/a&amp;gt; &amp;lt;/td&amp;gt; &amp;lt;td&amp;gt; &amp;lt;a href=&amp;quot;http://blog.</description>
    </item>
    
    <item>
      <title>kotlin特性之inline内联函数</title>
      <link>https://helixs.github.io/posts/2019-09-11-kotlin%E7%89%B9%E6%80%A7%E4%B9%8Binline%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/</link>
      <pubDate>Wed, 11 Sep 2019 07:15:28 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2019-09-11-kotlin%E7%89%B9%E6%80%A7%E4%B9%8Binline%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/</guid>
      <description>inline内联函数可以说是kotlin的一个高级特性了，不过在C++其实早就实现了，而java不支持内联函数，不过在jvm运行的时候会有一定的内联优化。
为什么需要内联 处理器调用一个函数的步骤如下：
  保留当前执行栈的信息
  为被调用的函数分配栈区
  初始化被调用函数中的参数、内部变量
  执行被调用函数并返回
  销毁被调用函数的执行栈
  取出第一步保存的信息并恢复，然后继续执行
  从这个流程中可以看到，所谓函数调用的开销主要是当前执行栈的保存与恢复、被调用函数栈区的分配与销毁两部分的开销。
调用函数是一个入栈出栈的过程，意味着需要内存的开销和释放。增加了机器运行的负担，而使用内联函数就在编译器级别，将函数中的代码，直接放入调用函数的地方。这样就减少了一个入栈和出栈的过程，还是很不错的吧。不过相应的，编译后所生成的字节码的长度肯定是要变大的。我们可以根据一定的场景进行内联。
inline 先来看看kotlin自带的inline函数
然后我们试试
然后我们Decompile转为java代码
我们可以看到main方法中调用printTexts方法已经直接将函数代码放入到了main方法里。
不过在定义printTexts方法的时候编译器提示了
expected performance impact of inlining is insignificant. Inlining works best for functions with parameters of functional types
刻意将普通方法加入inline并不会给性能带来多少的优化，反而会带来更多的字节码。建议将参数为函数形式的方法使用inline可以提高性能。
转为java
我们不加入inline内联实际上调用了printTexts方法中的Function1的回调函数。
然后在printTexts方法前面加入inline后再看看
参数为函数类型的函数使用inline的确可以提高性能，避免进入callback回调地狱。其实普通的方法不使用inline的情况下jvm也会帮我们实现部分的，如果需要的话那么你也可以强制使用Inline也没关系。
noinline 通过上面的代码我们看到，默认情况下内联函数的的参数如果是函数的话，那么参数函数也是被内联的
如果函数参数在内联函数的方法体内被其他非内联函数调用,就会报错.
我们可以加入noinline
正常，转java
我们可以看到参数函数不会被内联，而是转为callback了，那么就能正常调用非inline的函数了。
crossinline 我们来看一看下面的代码
答案是不会执行，除非使用的是return@printTexts 。默认内联函数lambda参数中return是可以进行调用函数处return的，因为已经和调用处函数融为一体了。
我们可以在block参数前加入crossinline来防止printTexts局部return
reified 其实我个人认为这个reified才是内联函数中最牛逼的玩意儿。在java中我们的泛型在运行时都是一堆object，被擦除了没啥卵用。
我们来试试哈
这个操作在java中可能实现吗，答案是不可能的。但是在kotlin中通过inline和reified就可以实现
这样我们就可以获取到泛型信息了，运行时的哦，困扰我多年的问题终于有办法了。比如我现在直接传入泛型而不用传入class就可以知道T是什么类型了。在java时候还要使用一堆头疼的反射等。其实inline的时候相当于就是吧T类型的class作为一个参数传进来了，还是蛮强大的。看看java代码
我们可以用来干嘛？</description>
    </item>
    
    <item>
      <title>冒泡排序的概念和优化</title>
      <link>https://helixs.github.io/posts/2019-09-02-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E4%BC%98%E5%8C%96/</link>
      <pubDate>Mon, 02 Sep 2019 09:33:36 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2019-09-02-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E4%BC%98%E5%8C%96/</guid>
      <description>冒泡排序为什么叫冒泡排序 -_- 我们都是宅农，应该都用锅烧过开水，或用来做饭或用来烧汤，不过我在小时候还烧过猪食。等水温达到一定程度，水就开始出了一点泡泡。
气泡有两个来源：
1、在水沸腾之前出现的气泡，主要是水中溶解的气体（氮气、氧气等），随着温度升高，它们在水中的溶解度下降，于是析出了气泡
2、等水沸腾之后大部分气泡就是沸腾产生的水蒸汽了气泡越来越大。
上浮的过程中气泡会变大主要原因是：pV=nRT，于是气体的体积和压强成反比。水面以下越深，压强就越大，所以上浮的过程是压强减小的过程，也就是体积增大的过程。
冒泡排序就是差不多这样解释啦。不过这里面还差了一个循环的意思。
最简单的实现方式 在要排序的一组数中，对当前还未排好序的范围内的全部数，自上而下对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。即：每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。
这个就是最简单冒泡排序实现办法。时间复杂度=O（n^2）也就是n*n。
优化 如果对于一个本身有序的序列，或则序列后面一大部分都是有序的序列，上面的算法就会浪费很多的时间开销，这里设置一个标志flag，如果这一趟发生了交换，则为true，否则为false。明显如果有一趟没有发生交换，说明排序已经完成。最好时间复杂度O(n) 最坏O(n^2)
进一步优化 比如，现在有一个包含1000个数的数组，仅前面100个无序，后面900个都已排好序且都大于前面100个数字，那么在第一趟遍历后，最后发生交换的位置必定小于100，且这个位置之后的数据必定已经有序了，也就是这个位置以后的数据不需要再排序了，于是记录下这位置，第二次只要从数组头部遍历到这个位置就可以了。如果是对于上面的冒泡排序算法2来说，虽然也只排序100次，但是前面的100次排序每次都要对后面的900个数据进行比较，而对于现在的排序算法3，只需要有一次比较后面的900个数据，之后就会设置尾边界，保证后面的900个数据不再被排序。
那么第三种其实就是最优解啦。</description>
    </item>
    
    <item>
      <title>Flutter SliverAppBar</title>
      <link>https://helixs.github.io/posts/2019-08-20-flutter-sliverappbar/</link>
      <pubDate>Tue, 20 Aug 2019 08:35:31 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2019-08-20-flutter-sliverappbar/</guid>
      <description> </description>
    </item>
    
    <item>
      <title>Java GC简单认识</title>
      <link>https://helixs.github.io/posts/2019-07-30-java-gc%E7%AE%80%E5%8D%95%E8%AE%A4%E8%AF%86/</link>
      <pubDate>Tue, 30 Jul 2019 04:00:27 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2019-07-30-java-gc%E7%AE%80%E5%8D%95%E8%AE%A4%E8%AF%86/</guid>
      <description>前几日，我去外面试了试面试。找找新工作看看有没有合适的。前面基本上很顺利，没有什么特别的难度和问题，本以为可以满怀信心的入职，结果被泼了一盆冷水。被问到关于GC机制的问题，GC算法有哪些，规则如何等等，我懵逼了，我只知道GC是垃圾回收，在内存不够的时候会触发它，然后回收没有引用的内存。然后它是如何实现的可真没有仔细研究过。书到用时方恨少，事非经过不知难。
在很多年前我们在运行android程序的时候，时不时的会卡顿，我当时不以为然。排除线程和代码相关的情况下多半都与触发了GC有关西。了解才知道，在触发GC线程的时候，其它线程会进行等待，包括UI线程，UI线程卡顿了，那么我们肯定就会卡了。
可以看看jvm运行时内存分配哪些对象会被回收？ 对于寄存器、栈和本地方法区，他们都是跟随着当前线程走的，线程走完也就消亡了，所以不许要GC去触碰它。
而GC的主要对象是Java堆，这个地方跟线程的生命周期没有直接关联，就算你方法走完，new的对象也不会马上消失，直到GC的时候才有可能回收它。次要对象就是方法区的常量或者类等，毕竟这个一般也不会大到哪里去。
对象存活的依据 1、引用计数法  原理：给对象添加一个引用计数器，每当有地方引用时计数器加 1，引用失效时减 1。当该对象引用为 0 时，判定对象失效 优点：实现简单，判定效率高 缺点：很难解决对象之间循环引用的问题  如果 class A,classB都持有对方的引用那么就不可能回收了！。
 &amp;lt;ol&amp;gt; &amp;lt;li&amp;gt; 判断对象是否覆盖了 finalize() 方法 &amp;lt;/li&amp;gt; &amp;lt;/ol&amp;gt; &amp;lt;p&amp;gt; 如果覆盖了 finalize() 方法，那么将 finalize() 放到 F-Queue 队列中 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 如果未覆盖该方法，则直接回收 &amp;lt;/p&amp;gt; &amp;lt;ol start=&amp;quot;2&amp;quot;&amp;gt; &amp;lt;li&amp;gt; 执行 F-Queue 队列中的 finalize() 方法&amp;lt;br /&amp;gt; 由虚拟机自动建立一个优先级较低的线程去执行 F-Queue 中的 finalize() 方法，这里的执行只是触发这些方法并不保证会等待它执行完毕。如果 finalize() 方法作了耗时操作，虚拟机会停止执行并将该对象清除。 &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; 对象销毁或重生&amp;lt;br /&amp;gt; &amp;lt;strong&amp;gt;在 finalize() 方法中，将 this 赋值给某一个引用，那么该对象就重生了。如果没有引用，该对象会被回收&amp;lt;/strong&amp;gt;。 &amp;lt;/li&amp;gt; &amp;lt;/ol&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;h5&amp;gt; 方法区的内存回收 &amp;lt;/h5&amp;gt; &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt; 废弃的常量：&amp;lt;br /&amp;gt; 当前系统中没有任何对象引用常量池中的该常量，则是废弃常量 &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; 废弃的类判断规则：&amp;lt;br /&amp;gt; 该类所有实例都被回收；&amp;lt;br /&amp;gt; 加载该类的 ClassLoader 已经被回收；&amp;lt;br /&amp;gt; 该类对应的 Class 对象没有引用，也无法通过反射访问该类的方法。 &amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;h4&amp;gt; 算法 &amp;lt;/h4&amp;gt; &amp;lt;p&amp;gt; 最基础的收集算法是&amp;amp;#8221;标记 &amp;amp;#8211; 清除&amp;amp;#8221;算法，之所以说它是最基础的是因为它逻辑简单、使用简便，而且后续的收集算法大多基于这种算法的不足而优化的。 &amp;lt;/p&amp;gt; &amp;lt;h5&amp;gt; 1.</description>
    </item>
    
    <item>
      <title>jvm运行时内存分配</title>
      <link>https://helixs.github.io/posts/2019-07-29-java-gc%E7%9A%84%E7%AE%80%E5%8D%95%E8%AE%A4%E8%AF%86/</link>
      <pubDate>Mon, 29 Jul 2019 10:03:17 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2019-07-29-java-gc%E7%9A%84%E7%AE%80%E5%8D%95%E8%AE%A4%E8%AF%86/</guid>
      <description>前几日，我去外面试了试面试。找找新工作看看有没有合适的。前面基本上很顺利，没有什么特别的难度和问题，本以为可以满怀信心的入职，结果被泼了一盆冷水。被问到关于GC机制的问题，GC算法有哪些，规则如何等等，我懵逼了，我只知道GC是垃圾回收，在内存不够的时候会触发它，然后回收没有引用的内存。然后它是如何实现的可真没有仔细研究过。书到用时方恨少，事非经过不知难。
在很多年前我们在运行android程序的时候，时不时的会卡顿，我当时不以为然。排除线程和代码相关的情况下多半都与触发了GC有关西。了解才知道，在触发GC线程的时候，其它线程会进行等待，包括UI线程，UI线程卡顿了，那么我们肯定就会卡了。
jvm运行时内存分配 1、栈 英文stack，运行于RAM之上。stack最主要的特征即是先进后出。栈内存上面有一个指针，和C语言的指针差不多，指针的加减直接影响栈内存的创建和释放。当载入一个新方法的时候，指针+，方法执行完毕，指针-。这是一种特别快、特别有效的数据保存方式，仅次于寄存器。创建程序时，Java编译器必须准确地知道堆栈内保存的所有数据的“长度”以及“存在时间”。这是由于它必须生成相应的代码，以便移动指针。
 每个线程包含一个栈区，栈中只保存基本数据类型的数据和自定义对象的引用(不是对象)，对象都存放在堆区中。 每个栈中的数据(原始类型和对象引用)都是私有的，其他栈不能访问。 栈分为3个部分：基本数据类型的变量区、执行环境上下文、操作指令区(存放操作指令)。  栈是存放线程调用方法时存储局部变量表，操作，方法出口等与方法执行相关的信息，Java栈所占内存的大小由Xss来调节，方法调用层次太多会撑爆这个区域即_StackOverflowError。_
ps:这让我想起了递归，如果递归层级过多，不进行尾递归优化那么方法一直在载入没有执行完毕，那么一记StackOverflowError送给你
程序计数器（ProgramCounter）寄存器 是cpu的一部分，离cpu最近，速度也最快。每个线程启动的时候，都会创建一个寄存器，保存正在执行jvm指令的地址和下一步指令的地址。寄存器的内容总是指向下一条将被执行指令的地址，这里的地址可以是一个本地指针，也可以是在方法区中相对应于该方法起始指令的偏移量。
ps:想想为什么需要保存啊，不是直接执行就行了么。NONONO，现在程序都是多线程运行的，cpu要同时执行多条命令呀！这句话说的也不对，多线程是个假象，就算是32核64线程也是假象，cpu短时间内会在不同线程之间切换运行指令，造成一种同时运行多任务的假象，不过假象很有效，足以骗过我们愚蠢的人类。所以任务切来切去不找个地方保存下一步需要执行的地方，我回过神来就会迷失方向了。
本地方法栈(也叫本地方法区) Nativemethodstack(本地方法栈)：保存native方法进入区域的地址。
方法区 method（方法区）又叫静态区，存放所有的①类（class），②静态变量（static变量），③静态方法，④常量和⑤成员方法。
1.又叫静态区，跟堆一样，被所有的线程共享。
2.方法区中存放的都是在整个程序中永远唯一的元素。这也是方法区被所有的线程共享的原因。
（顺便展开静态变量和常量的区别： 静态变量本质是变量，是整个类所有对象共享的一个变量，其值一旦改变对这个类的所有对象都有影响；常量一旦赋值后不能修改其引用，其中基本数据类型的常量不能修改其值。）
Java里面是没有静态变量这个概念的，不信你自己在某个成员方法里面定义一个static int i = 0；Java里只有静态成员变量。它属于类的属性。至于他放哪里？楼上说的是静态区。我不知道到底有没有这个翻译。但是深入JVM里是翻译为方法区的。虚拟机的体系结构：①Java栈，② 堆，③PC寄存器，④方法区，⑤本地方法栈，⑥运行常量池。而方法区保存的就是一个类的模板，堆是放类的实例（即对象）的。栈是一般来用来函数计算的。随便找本计算机底层的书都知道了。栈里的数据，函数执行完就不会存储了。这就是为什么局部变量每一次都是一样的。就算给他加一后，下次执行函数的时候还是原来的样子。
方法区的大小由-XX:PermSize和-XX:MaxPermSize来调节，类太多有可能撑爆永久代。静态变量或常量也有可能撑爆方法区。
 方法区的位置有三种情况：
java7之前，方法区位于永久代(PermGen)，永久代和堆相互隔离，永久代的大小在启动JVM时可以设置一个固定值，不可变； java7中，存储在永久代的部分数据就已经转移到Java Heap或者Native memory。但永久代仍存在于JDK 1.7中，并没有完全移除，譬如符号引用(Symbols)转移到了native memory；字符串常量池(interned strings)转移到了Java heap；类的静态变量(class statics)转移到了Java heap。 java8中，取消永久代，方法存放于元空间(Metaspace)，元空间仍然与堆不相连，但与堆共享物理内存，逻辑上可认为在堆中  Native memory：本地内存，也称为C-Heap，是供JVM自身进程使用的。当Java Heap空间不足时会触发GC，但Native memory空间不够却不会触发GC。
为什么移除永久代？
1、字符串存在永久代中，容易出现性能问题和内存溢出。
2、永久代大小不容易确定，PermSize指定太小容易造成永久代OOM
3、永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。
4、Oracle 可能会将HotSpot 与 JRockit 合二为一。
堆 类的对象放在heap（堆）中，所有的类对象都是通过new方法创建，创建后，在stack（栈）会创建类对象的引用（内存地址）。
一种常规用途的内存池（也在RAM（随机存取存储器 ）区域），其中保存了Java对象。和栈不同：“内存堆”或“堆”最吸引人的地方在于编译器不必知道要从堆里分配多少存储空间，也不必知道存储的数据要在堆里停留多长的时间。因此，用堆保存数据时会得到更大的灵活性。要求创建一个对象时，只需用new命令编辑相应的代码即可。执行这些代码时，会在堆里自动进行数据的保存。当然，为达到这种灵活性，必然会付出一定的代价：在堆里分配存储空间时会花掉更长的时间。
JVM将所有对象的实例（即用new创建的对象）（对应于对象的引用（引用就是内存地址））的内存都分配在堆上，堆所占内存的大小由-Xmx指令和-Xms指令来调节。
运行常量池 这儿的“静态”是指“位于固定位置”。程序运行期间，静态存储的数据将随时等候调用。可用static关键字指出一个对象的特定元素是静态的。但Java对象本身永远都不会置入静态存储空间。
这个区域属于方法区。该区域存放类和接口的常量，除此之外，它还存放成员变量和成员方法的所有引用。当一个成员变量或者成员方法被引用的时候，JVM就通过运行常量池中的这些引用来查找成员变量和成员方法在内存中的的实际地址。
举个例子 命令 java AppMain</description>
    </item>
    
    <item>
      <title>通过openssl获取证书摘要信息</title>
      <link>https://helixs.github.io/posts/2019-07-23-%E9%80%9A%E8%BF%87openssl%E8%8E%B7%E5%8F%96%E8%AF%81%E4%B9%A6%E6%91%98%E8%A6%81%E4%BF%A1%E6%81%AF/</link>
      <pubDate>Tue, 23 Jul 2019 07:42:30 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2019-07-23-%E9%80%9A%E8%BF%87openssl%E8%8E%B7%E5%8F%96%E8%AF%81%E4%B9%A6%E6%91%98%E8%A6%81%E4%BF%A1%E6%81%AF/</guid>
      <description> 转载请注明出处https://xmcf.me/?p=314 我们做app开发的时候，往往需要对应用信息安全做考虑。通过charles fiddler抓取http包是很随意的事情，https中间人也是很容易。所以做一个信任所有证书的商业应用来说是很low。
拿android开发为例，如果考虑安全，必须进行证书锁定。如，通过network_security_config文件进行锁定。通过digest摘要来验证证书，而不用将证书放入到apk中，具体的不多说。
下面是X509公钥证书的格式标准，另外还有中间机构和根证书就不说明了
公钥证书的信息大概就是这些，在window的chrome我们可以随时到处证书就像这样
两个格式的主要区别：
虽然他们保存文件的的后缀都是cer区别就是der是保存的二进制文件，看不到里面的内容。
而base64编码实际上是pem格式的证书。开头—–BEGIN CERTIFICATE—– 结尾 —–END CERTIFICATE—–
他们最终包含的信息都是一样的，注意的是base64可以用文本编辑内容，不过不要随意修改多一个少一个空格也是不好的。
保存完后我们就要通过openssl进行获取证书公钥的摘要了
openssl登场
因为我用的win10系统装了个linux内核还是蛮舒服的
其大概过程是，1、让openssl安装x509公钥的标准读取证书信息 ，-pubkey 读取公钥 2、通过pkey -pukey 读取密钥信息通过-outform 按照der格式保存密钥信息 3、dgst按照sha256 进行hash计算得到了2进制数据 4、将二进制信息通过base64编码。最终就是我们所需要的信息了，我们得到的信息是通过hash计算不可逆的，所以保证了一定的安全性。
android项目通过
 </description>
    </item>
    
    <item>
      <title>Flutter.dio进行application/x-www-form-urlencoded请求注意事项</title>
      <link>https://helixs.github.io/posts/2019-07-22-flutter-dio%E8%BF%9B%E8%A1%8Capplication-x-www-form-urlencoded%E8%AF%B7%E6%B1%82%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</link>
      <pubDate>Mon, 22 Jul 2019 06:52:51 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2019-07-22-flutter-dio%E8%BF%9B%E8%A1%8Capplication-x-www-form-urlencoded%E8%AF%B7%E6%B1%82%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</guid>
      <description>转载请注明出处https://xmcf.me/?p=312  前些天使用Flutter的dio库进行post请求。说来也怪。服务器只允许使用application/x-www-form-urlencoded方式接收数据，data数据格式大概如下。
dataArr=[{“type”:”file”,”path”:”xxxx/wsdsd.txt”}]想了想用json不就行了么。form好麻烦。奈何你只是服务者。直接用dio库进行请求，contentType设置为application/x-www-form-urlencoded。就像这样
请求失败了，服务器接收数据格式错误。怎么查文档也不行，只能看dio源代码入手。找到RequestOptions看看他是如何做data编码的，找到DefaultTransformer.transformRequest(RequestOptions options)
再找到 Transformer.urlEncodeMap(data)
得到的结果是
晕，我也没时间看它错在哪里了，看来做好的办法就是自己进行encode编码了，也就是除了key=value之间的=号其他都要进行url编码，毕竟=才是唯一标准，看来dio库也是有bug的。顺便提一下，flutter的log居然从来不打双引号或者单引号，String看起来真麻烦。
按照刚才的例子直接改成
这样就可以了。
 —-坑一直很多，需要一步一步的填。</description>
    </item>
    
    <item>
      <title>OkHttp单一请求RequestBody执行两次writeTo的问题</title>
      <link>https://helixs.github.io/posts/2019-07-19-okhttp%E5%8D%95%E4%B8%80%E8%AF%B7%E6%B1%82requestbody%E6%89%A7%E8%A1%8C%E4%B8%A4%E6%AC%A1writeto%E7%9A%84%E9%97%AE%E9%A2%98/</link>
      <pubDate>Fri, 19 Jul 2019 03:01:55 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2019-07-19-okhttp%E5%8D%95%E4%B8%80%E8%AF%B7%E6%B1%82requestbody%E6%89%A7%E8%A1%8C%E4%B8%A4%E6%AC%A1writeto%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
      <description>转载请注明出处https://xmcf.me/?p=309 今天测试提示了bug，在文件上传的时候会有进度显示，可是每次都会显示200%。找了半天也没有找到具体的问题所在。所以，我就从上传触发点入手了。
原代码如下按道理来说这样执行都没啥问题的，不过它居然执行了两次。没办法了，去看Okhttp的源码，还是被我找到了
上面是第一次，下面是第二次
看看Okio.buffer中是什么
 执行顺序大概是
第一次&amp;gt;
HttpLoggingInterceptor.intercept-&amp;gt;MultipartBody.writeTo(BufferedSink)=&amp;gt;writeOrCountBytes(BufferedSink)=&amp;gt;PartBody.writeTo(BufferedSink)=&amp;gt;我们实现的writeTo(BufferedSink)
第二次&amp;gt;
CallServerInterceptor.intercept-
 MultipartBody.writeTo(BufferedSink)=&amp;gt;writeOrCountBytes(BufferedSink)=&amp;gt;PartBody.writeTo(BufferedSink)=&amp;gt;我们实现的writeTo(BufferedSink)
 除了调用的地方，其他后续操作都一样，不一样的主要就是一个是writeTo(Buffer)一个是writeTo(RealBufferedSink)
看看BufferedSink｛
子类为Buffer和RealBufferedSink
｝
再看看RealBufferedSink{
}
由此可知，Buffer和RealBufferedSink都是BufferedSink的实现类，RealBufferedSink中拥有Buffer成员,write的时候真正也是调用的Buffer.write。
所以我们可以通过判断BufferedSink的两个子类型来判断进行过滤。修改后的代码为
测试一下好了。数据的Request和Response都会进入Okhttp的拦截器过滤和观察我们的数据，执行读取操作。除了我们自己添加的log拦截，默认还有自带的拦截器，他们会形成一个任务链模式。有人说直接把Httplog的等级改成Head那是很蠢的做法，那你还观察什么数据呢。或者自定义Log拦截器，把MultipartBody类型的日志过滤掉，这才是正确的做法，毕竟logcat里面弹出一堆乱码也是很烦的一件事。
 转载请注明出处https://xmcf.me/?p=309 </description>
    </item>
    
    <item>
      <title>bash shell 数据流重导向与管道的简单认识</title>
      <link>https://helixs.github.io/posts/2019-06-12-bash-shell-%E6%95%B0%E6%8D%AE%E6%B5%81%E9%87%8D%E5%AF%BC%E5%90%91%E4%B8%8E%E7%AE%A1%E9%81%93%E7%9A%84%E7%AE%80%E5%8D%95%E8%AE%A4%E8%AF%86/</link>
      <pubDate>Wed, 12 Jun 2019 03:08:39 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2019-06-12-bash-shell-%E6%95%B0%E6%8D%AE%E6%B5%81%E9%87%8D%E5%AF%BC%E5%90%91%E4%B8%8E%E7%AE%A1%E9%81%93%E7%9A%84%E7%AE%80%E5%8D%95%E8%AE%A4%E8%AF%86/</guid>
      <description>数据流重导向3个方式发送的文件或者设备上
 标准输入　（stdin） ：代码为 0 ，使用 &amp;lt;(指定标准输入文件或者设备) 或 &amp;laquo;(后面跟上内容如字符串可以结束输入) ； 标准输出　（stdout）：代码为 1 ，使用 &amp;gt;(覆盖输出设备或文件的数据) 或 &amp;raquo;(累加输出设备或文件的数据)； 标准错误输出（stderr）：代码为 2 ，使用 2&amp;gt; 或 2&amp;raquo; ；(和标准输出一样，只不过是错误信息)  错误输出数据和正确输出一样，只需在后面跟上2&amp;gt;或者2&amp;raquo;
&amp;amp;&amp;amp;和||跟编程代码中的与和或很像
管道命令 cut主要的用途是将同一行里面的数据按照规定的字符进行拆分，有点像java中的String.split。
cut是取出一行一行中我们想要的,那么grep就是过滤一行一行的的数据，过滤包含或者不包含的数据
 sort  sort 是很有趣的指令，他可以帮我们进行排序，而且可以依据不同的数据型态来排序喔！ 例如数字与文字的排序就不一样。此外，排序的字符与语系的编码有关，因此， 如果您需要排序时，建议使用 LANG=C 来让语系统一，数据排序比较好一些。
 wc  如果我想要知道 /etc/man_db.conf 这个文件里面有多少字？多少行？多少字符的话， 可以怎么做呢？其实可以利用 wc 这个指令来达成喔！他可以帮我们计算输出的讯息的整体数据！
 uniq   tee  会将数据流整个传送给文件或设备，因此我们除非去读取该文件或设备， 否则就无法继续利用这个数据流。万一我想要将这个数据流的处理过程中将某段讯息存下来，应该怎么做？ 利用 tee 就可以啰～
tee 会同时将数据流分送到文件去与屏幕 （screen）；而输出到屏幕的，其实就是 stdout ，那就可以让下个指令继续处理喔！
tee 可以让 standard output 转存一份到文件内并将同样的数据继续送到屏幕去处理！ 这样除了可以让我们同时分析一份数据并记录下来之外，还可以作为处理一份数据的中间暂存盘记录之用！</description>
    </item>
    
    <item>
      <title>Bash Shell常用快捷键</title>
      <link>https://helixs.github.io/posts/2019-06-11-bash-shell%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</link>
      <pubDate>Tue, 11 Jun 2019 09:06:49 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2019-06-11-bash-shell%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</guid>
      <description>编辑命令  Ctrl + a ：移到命令行首 Ctrl + e ：移到命令行尾 Ctrl + f ：按字符前移（右向） Ctrl + b ：按字符后移（左向） Alt + f ：按单词前移（右向） Alt + b ：按单词后移（左向） Ctrl + xx：在命令行首和光标之间移动 Ctrl + u ：从光标处删除至命令行首 Ctrl + k ：从光标处删除至命令行尾 Ctrl + w ：从光标处删除至字首 Alt + d ：从光标处删除至字尾 Ctrl + d ：删除光标处的字符 Ctrl + h ：删除光标前的字符 Ctrl + y ：粘贴至光标后 Alt + c ：从光标处更改为首字母大写的单词 Alt + u ：从光标处更改为全部大写的单词 Alt + l ：从光标处更改为全部小写的单词 Ctrl + t ：交换光标处和之前的字符 Alt + t ：交换光标处和之前的单词 Alt + Backspace：与 Ctrl + w 相同类似，分隔符有些差别  重新执行命令  Ctrl + r：逆向搜索命令历史 Ctrl + g：从历史搜索模式退出 Ctrl + p：历史中的上一条命令 Ctrl + n：历史中的下一条命令 Alt + .</description>
    </item>
    
    <item>
      <title>为什么国内的服务器带宽都那么贵？</title>
      <link>https://helixs.github.io/posts/2019-06-06-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9B%BD%E5%86%85%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B8%A6%E5%AE%BD%E9%83%BD%E9%82%A3%E4%B9%88%E8%B4%B5/</link>
      <pubDate>Thu, 06 Jun 2019 01:52:44 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2019-06-06-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9B%BD%E5%86%85%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B8%A6%E5%AE%BD%E9%83%BD%E9%82%A3%E4%B9%88%E8%B4%B5/</guid>
      <description> &amp;lt;p style=&amp;quot;margin: 0px 0px 30px; padding: 0px; font-size: 17px; color: #2a2a2a; line-height: 29px; word-break: break-word; font-family: &#39;SF Pro SC&#39;, &#39;HanHei SC&#39;, &#39;SF Pro Text&#39;, &#39;Myriad Set Pro&#39;, &#39;SF Pro Icons&#39;, &#39;PingFang SC&#39;, &#39;Segoe UI&#39;, SegoeUI, &#39;Microsoft YaHei&#39;, 微软雅黑, &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; text-align: justify;&amp;quot;&amp;gt; 欧洲和美国的网络是完全的互联互通——美国FCC（联邦通信委员会）有强制的要求。运营商们有的有内容，有的有眼球，对等地位的免费互联，叫peering，不对等的要网间结算，叫买IP transit。但价格也是绝对合理。 &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;quot;margin: 0px 0px 30px; padding: 0px; font-size: 17px; color: #2a2a2a; line-height: 29px; word-break: break-word; font-family: &#39;SF Pro SC&#39;, &#39;HanHei SC&#39;, &#39;SF Pro Text&#39;, &#39;Myriad Set Pro&#39;, &#39;SF Pro Icons&#39;, &#39;PingFang SC&#39;, &#39;Segoe UI&#39;, SegoeUI, &#39;Microsoft YaHei&#39;, 微软雅黑, &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; text-align: justify;&amp;quot;&amp;gt; 今年的行情，1Gbps左右的带宽，自己没有骨干网，到处和人家peering凑起来的接入商，大概1美元/Mbps。Tier 1的ISP，拥有全国骨干网的几家，价格在3-5美元/Mbps。而拥有大量内容的客户，比如Facebook, Google, Netflix，以及云存储和CDN服务商们，可以得到大量免费的带宽，只有小部分需要购买。曾经听过一个数据是美国一家著名的CDN，70%的带宽是免费获得的。 &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;quot;margin: 0px 0px 30px; padding: 0px; font-size: 17px; color: #2a2a2a; line-height: 29px; word-break: break-word; font-family: &#39;SF Pro SC&#39;, &#39;HanHei SC&#39;, &#39;SF Pro Text&#39;, &#39;Myriad Set Pro&#39;, &#39;SF Pro Icons&#39;, &#39;PingFang SC&#39;, &#39;Segoe UI&#39;, SegoeUI, &#39;Microsoft YaHei&#39;, 微软雅黑, &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; text-align: justify;&amp;quot;&amp;gt; 在这个基础上，首先技术上BGP（边界网关协议）是普遍标准，仅仅就DNS服务这种云服务和CDN都会用到的基础服务来说，Anycast是普遍采用的技术。全网的CDN节点，只会给一个IP。无论是云服务还是CDN，除了个别非常老的服务提供商，几乎其它各家用的都是Anycast。其次，网络使用非常方便，我可以开1G的端口，可以开10G的端口，可以买几百Mbps，也可以按照流量使用付费——因为网络是自由互联的，接少数几家就可以得到全国的各个网络的覆盖，任何一个机房都有自己的meet me room。上百家的ISP，甚至世界各国的ISP都可以接进来，在这个房间里，做好互联。 &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;quot;margin: 0px 0px 30px; padding: 0px; font-size: 17px; color: #2a2a2a; line-height: 29px; word-break: break-word; font-family: &#39;SF Pro SC&#39;, &#39;HanHei SC&#39;, &#39;SF Pro Text&#39;, &#39;Myriad Set Pro&#39;, &#39;SF Pro Icons&#39;, &#39;PingFang SC&#39;, &#39;Segoe UI&#39;, SegoeUI, &#39;Microsoft YaHei&#39;, 微软雅黑, &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; text-align: justify;&amp;quot;&amp;gt; 而且机房之间和机房之内的通信也是自由的，拉光纤实现就好。所以AWS的EC2可以推出Multi AZ的概念——同一个地区，推出两个以上独立机房，应用架构可以平行部署在两个机房里，但两个机房又是光纤直连的，媲美同一个机房的内网速度。所以用户完全可以零成本的做到多个机房的部署，不怕单一机房的故障。 &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;quot;margin: 0px 0px 30px; padding: 0px; font-size: 17px; color: #2a2a2a; line-height: 29px; word-break: break-word; font-family: &#39;SF Pro SC&#39;, &#39;HanHei SC&#39;, &#39;SF Pro Text&#39;, &#39;Myriad Set Pro&#39;, &#39;SF Pro Icons&#39;, &#39;PingFang SC&#39;, &#39;Segoe UI&#39;, SegoeUI, &#39;Microsoft YaHei&#39;, 微软雅黑, &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; text-align: justify;&amp;quot;&amp;gt; 而中国的网络环境，至少我看到的是相当差的。即使亚洲的网络普遍存在垄断的情况，中国的情况也是非常恶劣的。两个主要运营商之间的互联互通非常少，我都懒得去CNNIC上查最新的两家之间的互联互通的带宽，因为事实就是秃头上面的虱子，这点带宽纯属摆设。主管部委的网站上公布的互联互通的指导价格是1000元人民币/Mbps，这可相当于是160美元/Mbps啊，这是一个让全世界的人看来都无比震惊的数字！ &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;quot;margin: 0px 0px 30px; padding: 0px; font-size: 17px; color: #2a2a2a; line-height: 29px; word-break: break-word; font-family: &#39;SF Pro SC&#39;, &#39;HanHei SC&#39;, &#39;SF Pro Text&#39;, &#39;Myriad Set Pro&#39;, &#39;SF Pro Icons&#39;, &#39;PingFang SC&#39;, &#39;Segoe UI&#39;, SegoeUI, &#39;Microsoft YaHei&#39;, 微软雅黑, &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; text-align: justify;&amp;quot;&amp;gt; 即使真正通过协商，互联互通的价格低也实际上仍然很高，因为北京市场上的BGP价格在100美元/Mbps。在台湾，中华电信一家独大，政府给的网间互连指导价是5美与啊/Mbps。在香港，HKIX里只要有ISP执照，就可以免费的和HKIX交换流量，和香港的所有运营商免费互联。 &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;quot;margin: 0px 0px 30px; padding: 0px; font-size: 17px; color: #2a2a2a; line-height: 29px; word-break: break-word; font-family: &#39;SF Pro SC&#39;, &#39;HanHei SC&#39;, &#39;SF Pro Text&#39;, &#39;Myriad Set Pro&#39;, &#39;SF Pro Icons&#39;, &#39;PingFang SC&#39;, &#39;Segoe UI&#39;, SegoeUI, &#39;Microsoft YaHei&#39;, 微软雅黑, &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; text-align: justify;&amp;quot;&amp;gt; 这个导致的直接结果是中国有两张隔离的网,。显然运营商们建设的 机房只有自己的网络可以接入，中国的机房没有meet me room。因为大多数的机房只有一个运营商的网络。少数的大客户强势的需要互联互通的，运营商会硬着头皮到另一家里高价把线接进来，当然是客户买单。 &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;quot;margin: 0px 0px 30px; padding: 0px; font-size: 17px; color: #2a2a2a; line-height: 29px; word-break: break-word; font-family: &#39;SF Pro SC&#39;, &#39;HanHei SC&#39;, &#39;SF Pro Text&#39;, &#39;Myriad Set Pro&#39;, &#39;SF Pro Icons&#39;, &#39;PingFang SC&#39;, &#39;Segoe UI&#39;, SegoeUI, &#39;Microsoft YaHei&#39;, 微软雅黑, &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; text-align: justify;&amp;quot;&amp;gt; 这种现状给全国的线上业务带来无尽的麻烦。几乎全部上规模的互联网业务都需要在两家运营商里复制两个以一样的系统，然后用load balancing的技术把电信的流量给电信的机房，联通的给联通。这种重复的建设不知道给运营商贡献了多少收入，以及制造了多少传说中的GDP，但也很大程度上提高了互联网领域的门槛，限制了创新。中国的互联网运维队伍可能是全世界最庞大的。运维甚至成为很多互联网业务的核心竞争力。因为基础设施和网络上太复杂了。 &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;quot;margin: 0px 0px 30px; padding: 0px; font-size: 17px; color: #2a2a2a; line-height: 29px; word-break: break-word; font-family: &#39;SF Pro SC&#39;, &#39;HanHei SC&#39;, &#39;SF Pro Text&#39;, &#39;Myriad Set Pro&#39;, &#39;SF Pro Icons&#39;, &#39;PingFang SC&#39;, &#39;Segoe UI&#39;, SegoeUI, &#39;Microsoft YaHei&#39;, 微软雅黑, &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; text-align: justify;&amp;quot;&amp;gt; 想用BGP实现自动的互联互通？BGP受到运营商的严格限制，不仅仅是价格。运营商们在二三线城市基本都不开BGP。北京的BGP价格高达100美元/Mbps，上海更贵。你想多买还不一定能买到。中国市场上创造性的出现了假BGP，双线，多线等各种网络接入方式。这种情况下，大多数的业务都只能走静态带宽。像Anycast这样的技术在中国根本就无从谈起。 &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;quot;margin: 0px 0px 30px; padding: 0px; font-size: 17px; color: #2a2a2a; line-height: 29px; word-break: break-word; font-family: &#39;SF Pro SC&#39;, &#39;HanHei SC&#39;, &#39;SF Pro Text&#39;, &#39;Myriad Set Pro&#39;, &#39;SF Pro Icons&#39;, &#39;PingFang SC&#39;, &#39;Segoe UI&#39;, SegoeUI, &#39;Microsoft YaHei&#39;, 微软雅黑, &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; text-align: justify;&amp;quot;&amp;gt; 海外的云服务提供商即使在中国有机会做起一些服务的点，也只能在网络调度上隔离于全球网络之外。比如CDN，曾经接触过多个海外CDN的公司想把CDN点布到中国，对不起，不要说管制的问题，技术上就做不到。 &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;quot;margin: 0px 0px 30px; padding: 0px; font-size: 17px; color: #2a2a2a; line-height: 29px; word-break: break-word; font-family: &#39;SF Pro SC&#39;, &#39;HanHei SC&#39;, &#39;SF Pro Text&#39;, &#39;Myriad Set Pro&#39;, &#39;SF Pro Icons&#39;, &#39;PingFang SC&#39;, &#39;Segoe UI&#39;, SegoeUI, &#39;Microsoft YaHei&#39;, 微软雅黑, &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; text-align: justify;&amp;quot;&amp;gt; 光纤的互联同样受到严格的限制，以北京为例，大多数运营商经营的机房不允许光纤的接入，因为他们担心你会把另一家的带宽也拉进来。所以你想拉光纤在两个机房之间非常困难，这直接导致在中国设立像AWS那样两个机房互为备份的概念基本不可能。目前在国内有推出“公有云”的各家也都没有能够成功的提供的这个功能。 &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;quot;margin: 0px 0px 30px; padding: 0px; font-size: 17px; color: #2a2a2a; line-height: 29px; word-break: break-word; font-family: &#39;SF Pro SC&#39;, &#39;HanHei SC&#39;, &#39;SF Pro Text&#39;, &#39;Myriad Set Pro&#39;, &#39;SF Pro Icons&#39;, &#39;PingFang SC&#39;, &#39;Segoe UI&#39;, SegoeUI, &#39;Microsoft YaHei&#39;, 微软雅黑, &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; text-align: justify;&amp;quot;&amp;gt; &amp;lt;p style=&amp;quot;margin: 0px 0px 30px; padding: 0px; font-size: 17px; color: #2a2a2a; line-height: 29px; word-break: break-word; font-family: &#39;SF Pro SC&#39;, &#39;HanHei SC&#39;, &#39;SF Pro Text&#39;, &#39;Myriad Set Pro&#39;, &#39;SF Pro Icons&#39;, &#39;PingFang SC&#39;, &#39;Segoe UI&#39;, SegoeUI, &#39;Microsoft YaHei&#39;, 微软雅黑, &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; text-align: justify;&amp;quot;&amp;gt; &amp;lt;strong style=&amp;quot;margin: 0px; padding: 0px;&amp;quot;&amp;gt;政策管制&amp;lt;/strong&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;quot;margin: 0px 0px 30px; padding: 0px; font-size: 17px; color: #2a2a2a; line-height: 29px; word-break: break-word; font-family: &#39;SF Pro SC&#39;, &#39;HanHei SC&#39;, &#39;SF Pro Text&#39;, &#39;Myriad Set Pro&#39;, &#39;SF Pro Icons&#39;, &#39;PingFang SC&#39;, &#39;Segoe UI&#39;, SegoeUI, &#39;Microsoft YaHei&#39;, 微软雅黑, &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; text-align: justify;&amp;quot;&amp;gt; 最后，政策方面的限制，其实我倒觉得还好。一个外国公司，可以名义上授权自己的品牌给国内的一家有业务牌照的公司来提供服务给中国的用户，在云的领域，可以是数据中心的执照，但ICP的执照也未尝不可，因为hosting类的服务在中国一直以来也都是成千上万的服务提供商拿着一个ICP执照来提供的。 &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;quot;margin: 0px 0px 30px; padding: 0px; font-size: 17px; color: #2a2a2a; line-height: 29px; word-break: break-word; font-family: &#39;SF Pro SC&#39;, &#39;HanHei SC&#39;, &#39;SF Pro Text&#39;, &#39;Myriad Set Pro&#39;, &#39;SF Pro Icons&#39;, &#39;PingFang SC&#39;, &#39;Segoe UI&#39;, SegoeUI, &#39;Microsoft YaHei&#39;, 微软雅黑, &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; text-align: justify;&amp;quot;&amp;gt; 而难受的是：对于在线内容的管制与“云”的精神相悖。云的价值是让你有了好的想法可以随时上线，鼓励创新和试错。但我们关于ICP备案的规定完全是本着宁可错杀一千，不放过一个的精神。比如为了备案，网站所有者要到提供服务器托管服务的服务提供商那里去照相。 &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;quot;margin: 0px 0px 30px; padding: 0px; font-size: 17px; color: #2a2a2a; line-height: 29px; word-break: break-word; font-family: &#39;SF Pro SC&#39;, &#39;HanHei SC&#39;, &#39;SF Pro Text&#39;, &#39;Myriad Set Pro&#39;, &#39;SF Pro Icons&#39;, &#39;PingFang SC&#39;, &#39;Segoe UI&#39;, SegoeUI, &#39;Microsoft YaHei&#39;, 微软雅黑, &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; text-align: justify;&amp;quot;&amp;gt; 互联网是无疆界的，即便是在国内这个网内，一个上海的公司把内容host在北京也是完全可能的，那么你就只能想办法到北京去照相，或者服务提供商把照相的那块背景布寄到上海。不要说完全不理解这一套的外国服务提供商，国内的云服务提供商在一开始也在备案这块上也是非常头疼。 &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;quot;margin: 0px 0px 30px; padding: 0px; font-size: 17px; color: #2a2a2a; line-height: 29px; word-break: break-word; font-family: &#39;SF Pro SC&#39;, &#39;HanHei SC&#39;, &#39;SF Pro Text&#39;, &#39;Myriad Set Pro&#39;, &#39;SF Pro Icons&#39;, &#39;PingFang SC&#39;, &#39;Segoe UI&#39;, SegoeUI, &#39;Microsoft YaHei&#39;, 微软雅黑, &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; text-align: justify;&amp;quot;&amp;gt; 但毫无疑问，中国是一个庞大的市场，有最优秀的工程师，有最渴望成功的互联网领域的创业者。微软能够开始在中国提供业务是个非常值得关注的，以后还是会有越来越多的公司，包括国内的和国际的，尝试在中国市场提供云服务。中国土生土长的云服务公司早已习惯了这样的一个基础设施环境，并不畏惧由此产生的困难，但反而容易陷入资源的陷阱，误以为有好的机房，拿到便宜的BGP资源就不怕竞争了。 &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;quot;margin: 0px 0px 30px; padding: 0px; font-size: 17px; color: #2a2a2a; line-height: 29px; word-break: break-word; font-family: &#39;SF Pro SC&#39;, &#39;HanHei SC&#39;, &#39;SF Pro Text&#39;, &#39;Myriad Set Pro&#39;, &#39;SF Pro Icons&#39;, &#39;PingFang SC&#39;, &#39;Segoe UI&#39;, SegoeUI, &#39;Microsoft YaHei&#39;, 微软雅黑, &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; text-align: justify;&amp;quot;&amp;gt; 云服务在海外从来没有资源的限制，大家在不断提高的都是产品和资源的运营能力，从Iaas作为基础，整合开源的东西，加上Windows，Oracle，SAP等等，拥有覆盖线上应用方方面面的产品组合。但面对中国市场，国外的云服务公司必须要正视在资源上的诸多限制，必须找到那些有资源的合作伙伴，在经营模式上做妥协，否则即使侥幸开始了服务，也面临无法扩展的危险。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; &amp;amp;nbsp; &amp;lt;/p&amp;gt; </description>
    </item>
    
    <item>
      <title>vi/vim常用快捷键</title>
      <link>https://helixs.github.io/posts/2019-06-04-vi-vim%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</link>
      <pubDate>Tue, 04 Jun 2019 07:39:38 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2019-06-04-vi-vim%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</guid>
      <description>第一部份：一般指令模式可用的按钮说明，光标移动、复制贴上、搜寻取代等  &amp;lt;td&amp;gt; 光标向左移动一个字符 &amp;lt;/td&amp;gt;  &amp;lt;td&amp;gt; 光标向下移动一个字符 &amp;lt;/td&amp;gt;  &amp;lt;td&amp;gt; 光标向上移动一个字符 &amp;lt;/td&amp;gt;  &amp;lt;td&amp;gt; 光标向右移动一个字符 &amp;lt;/td&amp;gt;  &amp;lt;td&amp;gt; 屏幕“向下”移动一页，相当于 [Page Down]按键 （常用） &amp;lt;/td&amp;gt;  &amp;lt;td&amp;gt; 屏幕“向上”移动一页，相当于 [Page Up] 按键 （常用） &amp;lt;/td&amp;gt;  &amp;lt;td&amp;gt; 屏幕“向下”移动半页 &amp;lt;/td&amp;gt;  &amp;lt;td&amp;gt; 屏幕“向上”移动半页 &amp;lt;/td&amp;gt;  &amp;lt;td&amp;gt; 光标移动到非空白字符的下一列 &amp;lt;/td&amp;gt;  &amp;lt;td&amp;gt; 光标移动到非空白字符的上一列 &amp;lt;/td&amp;gt;  &amp;lt;td&amp;gt; 那个 n 表示“数字”，例如 20 。按下数字后再按空白键，光标会向右移动这一列的 n 个字符。例如 20&amp;lt;space&amp;gt; 则光标会向后面移动 20 个字符距离。 &amp;lt;/td&amp;gt;  &amp;lt;td&amp;gt; 这是数字“ 0 ”：移动到这一列的最前面字符处 （常用） &amp;lt;/td&amp;gt;  &amp;lt;td&amp;gt; 移动到这一列的最后面字符处（常用） &amp;lt;/td&amp;gt;  &amp;lt;td&amp;gt; 光标移动到这个屏幕的最上方那一列的第一个字符 &amp;lt;/td&amp;gt;  &amp;lt;td&amp;gt; 光标移动到这个屏幕的中央那一列的第一个字符 &amp;lt;/td&amp;gt;  &amp;lt;td&amp;gt; 光标移动到这个屏幕的最下方那一列的第一个字符 &amp;lt;/td&amp;gt;  &amp;lt;td&amp;gt; 移动到这个文件的最后一列（常用） &amp;lt;/td&amp;gt;  &amp;lt;td&amp;gt; n 为数字。移动到这个文件的第 n 列。例如 20G 则会移动到这个文件的第 20 列（可配合 :set nu） &amp;lt;/td&amp;gt;  &amp;lt;td&amp;gt; 移动到这个文件的第一列，相当于 1G 啊！ （常用） &amp;lt;/td&amp;gt;  &amp;lt;td&amp;gt; n 为数字。光标向下移动 n 列（常用） &amp;lt;/td&amp;gt;  &amp;lt;td&amp;gt; 向光标之下寻找一个名称为 word 的字串。例如要在文件内搜寻 vbird 这个字串，就输入 /vbird 即可！ （常用） &amp;lt;/td&amp;gt;  &amp;lt;td&amp;gt; 向光标之上寻找一个字串名称为 word 的字串。 &amp;lt;/td&amp;gt;  &amp;lt;td&amp;gt; 这个 n 是英文按键。代表“&amp;lt;u&amp;gt;重复前一个搜寻的动作&amp;lt;/u&amp;gt;”。举例来说， 如果刚刚我们执行 /vbird 去向下搜寻 vbird 这个字串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字串。如果是执行 ?</description>
    </item>
    
    <item>
      <title>C语言stdio中fgets和gets、puts的区别</title>
      <link>https://helixs.github.io/posts/2019-05-30-c%E8%AF%AD%E8%A8%80stdio%E4%B8%ADfgets%E5%92%8Cgetsputs%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Thu, 30 May 2019 09:01:00 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2019-05-30-c%E8%AF%AD%E8%A8%80stdio%E4%B8%ADfgets%E5%92%8Cgetsputs%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description> 结果：
红色是输入部分，**printf默认不会加回车，puts会在后面加入回车。**定义的inputs数组的最大只有10，我所输入的所有字符都打印出来了，所以gets函数并没有检查也无法检查inputs所占用的空间和范围，毕竟读取字符串也只能按照\0结尾。
然后再来看看fgets()多了最大值和字符从那个地方获取。地方我们用默认就行了，毕竟不太懂。仔细数一数打印出来了多少个，其实是29个,看来第30个添加结束标志\0。末尾的样子就是I\0了
所以我们以后输入字符串最好用fgets不要用gets。
 ==看看输入字符后完整内存看看
结果
就算少输几位后面也就是0 10 0 0 0，fgets无论你怎么输入都会在\0后面加入\n ascii为10，所以我们以后最好在判断\0的\n情况咯。
 </description>
    </item>
    
    <item>
      <title>舒舒服服看和bt未删减的美剧</title>
      <link>https://helixs.github.io/posts/2019-05-28-%E8%88%92%E8%88%92%E6%9C%8D%E6%9C%8D%E7%9C%8B%E5%92%8Cbt%E6%9C%AA%E5%88%A0%E5%87%8F%E7%9A%84%E7%BE%8E%E5%89%A7/</link>
      <pubDate>Tue, 28 May 2019 09:47:33 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2019-05-28-%E8%88%92%E8%88%92%E6%9C%8D%E6%9C%8D%E7%9C%8B%E5%92%8Cbt%E6%9C%AA%E5%88%A0%E5%87%8F%E7%9A%84%E7%BE%8E%E5%89%A7/</guid>
      <description>如果你想无拘无束，天天看自己喜欢的美剧，请耐心看完这篇文章。因为如果你不学会这个技能，总有一天你只能看删减版。
先介绍一下你看的美剧从哪里来。
从美国电视，流媒体（Hulu，Netflix，亚马逊）来，国外有专门的兴趣小组从电视及流媒体录制片源然后在国外各大资源站传播，传播方式以BT为主。
顶级渠道是0 day次级是PT，再次是BT。但是因为网络的发展，这三个渠道的传播速度已经基本相同，普通人也能第一时间获取美剧片源。
那么重点来了在海盗湾淡出历史舞台后，哪个是最大的BT资源站？
请百度rarbg（浏览这个网站务必安装广告拦截插件）,哈哈顺便一句google是不会让你搜到它的，度娘可以搜到，纯国外网友建立，你想要的游戏，电影，美剧，XXX，基本都能找到。不过都是无字幕纯英文版，即生肉。
rarbg是一个大型综合BT交流网站，没想到互联网发展这么多年还是原始的最好用吧？
你想用迅雷是可以的，但是如果迅雷因为XXX原因不能下载，请换其他软件，比如qbittorrent，utorrent(下面classic版本才是客户端,web版本是在线观看)，比特彗星等等。
因为rarbg里基本都是老外，所以你连接的BT链也是跨国传播，速度比较随缘。其实一般来说开始会慢，等等会快。如果等了很久也很慢，那只能是无缘了。
这时候可以试试把磁力链接放进度盘离线，相信我以后没有好心人再给你传度盘了。
好了生肉你会下了，字幕怎么办。
第一，各大字幕组微博，欢迎关注。
第二，字幕网站，比如字幕库，subhd等等。
如果你连外挂字幕都不会….百度一下很简单的。
生肉加外挂字幕，感觉又回到十几年前了不是？
切记，盗版始终有盗版的风险，追求正版是对视频的支持。我们只是需要未删减版对不？
源自–ttmeiju微信公众号-酸梅电影</description>
    </item>
    
    <item>
      <title>WorkManager详解</title>
      <link>https://helixs.github.io/posts/2019-05-27-workmanager%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Mon, 27 May 2019 10:02:52 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2019-05-27-workmanager%E8%AF%A6%E8%A7%A3/</guid>
      <description>一、回顾一下以前的做法 以前我们在处理后台任务时，一般都是使用Service(含IntentService）或者线程/线程池，而Service不受页面生命周期影响，可以常驻后台，所以很适合做一些定时、延时任务，或者其他一些肉眼不可见的神秘勾当。 在处理一些复杂需求时，比如监听网络环境自动暂停重启后台上传下载这类变态任务，我们需要用Service结合Broadcast一起来做,非常的麻烦，再加上传输进度的回调，让人想疯！
当然大量的后台任务过度消耗了设备的电量，比如多种第三方推送的service都在后台常驻，不良App后台自动上传用户隐私也带来了隐私安全问题。
二、谷歌开始专项整顿  6.0 (API 级 23) 引入了Doze机制和应用程序待机 。当屏幕关闭且设备静止时, 打盹模式会限制应用程序的行为。应用程序待机将未使用的应用程序置于限制其网络访问、作业和同步的特殊状态。 Android 7.0 (API 级 24) 有限的隐性广播和Doze-on-the-go . Android 8.0 (API 级 26) 进一步限制了后台行为 , 例如在后台获取位置并释放缓存的 wakelocks。  尤其在Android O（8.0）中，谷歌对于后台的限制几乎可以称之为变态：
 Android 8.0 有一项复杂功能；系统不允许后台应用创建后台服务。 因此，Android 8.0 引入了一种全新的方法，即 Context.startForegroundService()，以在前台启动新服务。 在系统创建服务后，应用有五秒的时间来调用该服务的 startForeground() 方法以显示新服务的用户可见通知。 如果应用在此时间限制内未调用 startForeground()，则系统将停止服务并声明此应用为 ANR。
 而且加入了对静态广播的限制：
 Android 8.0 让这些限制更为严格。 针对 Android 8.0 的应用无法继续在其清单中为隐式广播注册广播接收器。 隐式广播是一种不专门针对该应用的广播。 例如，ACTION_PACKAGE_REPLACED 就是一种隐式广播，因为它将发送到注册的所有侦听器，让后者知道设备上的某些软件包已被替换。 不过，ACTION_MY_PACKAGE_REPLACED 不是隐式广播，因为不管已为该广播注册侦听器的其他应用有多少，它都会只发送到软件包已被替换的应用。 应用可以继续在它们的清单中注册显式广播。 应用可以在运行时使用 Context.registerReceiver() 为任意广播（不管是隐式还是显式）注册接收器。 需要签名权限的广播不受此限制所限，因为这些广播只会发送到使用相同证书签名的应用，而不是发送到设备上的所有应用。 在许多情况下，之前注册隐式广播的应用使用 JobScheduler 作业可以获得类似的功能。
 于此同时，官方推荐用5.</description>
    </item>
    
    <item>
      <title>腾讯云秒杀活动信息查询脚本</title>
      <link>https://helixs.github.io/posts/2019-05-24-%E8%85%BE%E8%AE%AF%E4%BA%91%E7%A7%92%E6%9D%80%E6%B4%BB%E5%8A%A8%E4%BF%A1%E6%81%AF%E6%9F%A5%E8%AF%A2%E8%84%9A%E6%9C%AC/</link>
      <pubDate>Fri, 24 May 2019 09:03:37 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2019-05-24-%E8%85%BE%E8%AE%AF%E4%BA%91%E7%A7%92%E6%9D%80%E6%B4%BB%E5%8A%A8%E4%BF%A1%E6%81%AF%E6%9F%A5%E8%AF%A2%E8%84%9A%E6%9C%AC/</guid>
      <description>刚刚学习python又找不到练手的地方，所以闲来无事写了一个腾讯云活动查询的小爬虫，比较简单，也算是练手的
当前时段正在进行的活动
   </description>
    </item>
    
    <item>
      <title>正则表达式符号表</title>
      <link>https://helixs.github.io/posts/2019-05-23-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AC%A6%E5%8F%B7%E8%A1%A8/</link>
      <pubDate>Thu, 23 May 2019 08:00:24 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2019-05-23-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AC%A6%E5%8F%B7%E8%A1%A8/</guid>
      <description>表达式全集 &amp;lt;th width=&amp;quot;90%&amp;quot;&amp;gt; 描述 &amp;lt;/th&amp;gt;  &amp;lt;td&amp;gt; 将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，“&amp;lt;code&amp;gt;n&amp;lt;/code&amp;gt;”匹配字符“&amp;lt;code&amp;gt;n&amp;lt;/code&amp;gt;”。“&amp;lt;code&amp;gt;\n&amp;lt;/code&amp;gt;”匹配一个换行符。串行“&amp;lt;code&amp;gt;\\&amp;lt;/code&amp;gt;”匹配“&amp;lt;code&amp;gt;\&amp;lt;/code&amp;gt;”而“&amp;lt;code&amp;gt;\(&amp;lt;/code&amp;gt;”则匹配“&amp;lt;code&amp;gt;(&amp;lt;/code&amp;gt;”。 &amp;lt;/td&amp;gt;  &amp;lt;td&amp;gt; 匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配“&amp;lt;code&amp;gt;\n&amp;lt;/code&amp;gt;”或“&amp;lt;code&amp;gt;\r&amp;lt;/code&amp;gt;”之后的位置。 &amp;lt;/td&amp;gt;  &amp;lt;td&amp;gt; 匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，$也匹配“&amp;lt;code&amp;gt;\n&amp;lt;/code&amp;gt;”或“&amp;lt;code&amp;gt;\r&amp;lt;/code&amp;gt;”之前的位置。 &amp;lt;/td&amp;gt;  &amp;lt;td&amp;gt; 匹配前面的子表达式零次或多次。例如，zo*能匹配“&amp;lt;code&amp;gt;z&amp;lt;/code&amp;gt;”以及“&amp;lt;code&amp;gt;zoo&amp;lt;/code&amp;gt;”。*等价于{0,}。 &amp;lt;/td&amp;gt;  &amp;lt;td&amp;gt; 匹配前面的子表达式一次或多次。例如，“&amp;lt;code&amp;gt;zo+&amp;lt;/code&amp;gt;”能匹配“&amp;lt;code&amp;gt;zo&amp;lt;/code&amp;gt;”以及“&amp;lt;code&amp;gt;zoo&amp;lt;/code&amp;gt;”，但不能匹配“&amp;lt;code&amp;gt;z&amp;lt;/code&amp;gt;”。+等价于{1,}。 &amp;lt;/td&amp;gt;  &amp;lt;td&amp;gt; 匹配前面的子表达式零次或一次。例如，“&amp;lt;code&amp;gt;do(es)?&amp;lt;/code&amp;gt;”可以匹配“&amp;lt;code&amp;gt;does&amp;lt;/code&amp;gt;”或“&amp;lt;code&amp;gt;does&amp;lt;/code&amp;gt;”中的“&amp;lt;code&amp;gt;do&amp;lt;/code&amp;gt;”。?等价于{0,1}。 &amp;lt;/td&amp;gt;  &amp;lt;td&amp;gt; n是一个非负整数。匹配确定的n次。例如，“&amp;lt;code&amp;gt;o{2}&amp;lt;/code&amp;gt;”不能匹配“&amp;lt;code&amp;gt;Bob&amp;lt;/code&amp;gt;”中的“&amp;lt;code&amp;gt;o&amp;lt;/code&amp;gt;”，但是能匹配“&amp;lt;code&amp;gt;food&amp;lt;/code&amp;gt;”中的两个o。 &amp;lt;/td&amp;gt;  &amp;lt;td&amp;gt; n是一个非负整数。至少匹配n次。例如，“&amp;lt;code&amp;gt;o{2,}&amp;lt;/code&amp;gt;”不能匹配“&amp;lt;code&amp;gt;Bob&amp;lt;/code&amp;gt;”中的“&amp;lt;code&amp;gt;o&amp;lt;/code&amp;gt;”，但能匹配“&amp;lt;code&amp;gt;foooood&amp;lt;/code&amp;gt;”中的所有o。“&amp;lt;code&amp;gt;o{1,}&amp;lt;/code&amp;gt;”等价于“&amp;lt;code&amp;gt;o+&amp;lt;/code&amp;gt;”。“&amp;lt;code&amp;gt;o{0,}&amp;lt;/code&amp;gt;”则等价于“&amp;lt;code&amp;gt;o*&amp;lt;/code&amp;gt;”。 &amp;lt;/td&amp;gt;  &amp;lt;td&amp;gt; m和n均为非负整数，其中n&amp;lt;=m。最少匹配n次且最多匹配m次。例如，“&amp;lt;code&amp;gt;o{1,3}&amp;lt;/code&amp;gt;”将匹配“&amp;lt;code&amp;gt;fooooood&amp;lt;/code&amp;gt;”中的前三个o。“&amp;lt;code&amp;gt;o{0,1}&amp;lt;/code&amp;gt;”等价于“&amp;lt;code&amp;gt;o?&amp;lt;/code&amp;gt;”。请注意在逗号和两个数之间不能有空格。 &amp;lt;/td&amp;gt;  &amp;lt;td&amp;gt; 当该字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“&amp;lt;code&amp;gt;oooo&amp;lt;/code&amp;gt;”，“&amp;lt;code&amp;gt;o+?&amp;lt;/code&amp;gt;”将匹配单个“&amp;lt;code&amp;gt;o&amp;lt;/code&amp;gt;”，而“&amp;lt;code&amp;gt;o+&amp;lt;/code&amp;gt;”将匹配所有“&amp;lt;code&amp;gt;o&amp;lt;/code&amp;gt;”。 &amp;lt;/td&amp;gt;  &amp;lt;td&amp;gt; 匹配除“&amp;lt;code&amp;gt;\&amp;lt;/code&amp;gt;&amp;lt;code&amp;gt;n&amp;lt;/code&amp;gt;”之外的任何单个字符。要匹配包括“&amp;lt;code&amp;gt;\&amp;lt;/code&amp;gt;&amp;lt;code&amp;gt;n&amp;lt;/code&amp;gt;”在内的任何字符，请使用像“&amp;lt;code&amp;gt;(.|\n)&amp;lt;/code&amp;gt;”的模式。 &amp;lt;/td&amp;gt;  &amp;lt;td&amp;gt; 匹配pattern并获取这一匹配。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0…$9属性。要匹配圆括号字符，请使用“&amp;lt;code&amp;gt;\(&amp;lt;/code&amp;gt;”或“&amp;lt;code&amp;gt;\)&amp;lt;/code&amp;gt;”。 &amp;lt;/td&amp;gt;  &amp;lt;td&amp;gt; 匹配pattern但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用或字符“&amp;lt;code&amp;gt;(|)&amp;lt;/code&amp;gt;”来组合一个模式的各个部分是很有用。例如“&amp;lt;code&amp;gt;industr(?:y|ies)&amp;lt;/code&amp;gt;”就是一个比“&amp;lt;code&amp;gt;industry|industries&amp;lt;/code&amp;gt;”更简略的表达式。 &amp;lt;/td&amp;gt;  &amp;lt;td&amp;gt; 正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，“&amp;lt;code&amp;gt;Windows(?=95|98|NT|2000)&amp;lt;/code&amp;gt;”能匹配“&amp;lt;code&amp;gt;Windows2000&amp;lt;/code&amp;gt;”中的“&amp;lt;code&amp;gt;Windows&amp;lt;/code&amp;gt;”，但不能匹配“&amp;lt;code&amp;gt;Windows3.1&amp;lt;/code&amp;gt;”中的“&amp;lt;code&amp;gt;Windows&amp;lt;/code&amp;gt;”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 &amp;lt;/td&amp;gt;  &amp;lt;td&amp;gt; 正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如“&amp;lt;code&amp;gt;Windows(?!95|98|NT|2000)&amp;lt;/code&amp;gt;”能匹配“&amp;lt;code&amp;gt;Windows3.1&amp;lt;/code&amp;gt;”中的“&amp;lt;code&amp;gt;Windows&amp;lt;/code&amp;gt;”，但不能匹配“&amp;lt;code&amp;gt;Windows2000&amp;lt;/code&amp;gt;”中的“&amp;lt;code&amp;gt;Windows&amp;lt;/code&amp;gt;”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始 &amp;lt;/td&amp;gt;  &amp;lt;td&amp;gt; 反向肯定预查，与正向肯定预查类拟，只是方向相反。例如，“&amp;lt;code&amp;gt;(?&amp;amp;lt;=95|98|NT|2000)Windows&amp;lt;/code&amp;gt;”能匹配“&amp;lt;code&amp;gt;2000Windows&amp;lt;/code&amp;gt;”中的“&amp;lt;code&amp;gt;Windows&amp;lt;/code&amp;gt;”，但不能匹配“&amp;lt;code&amp;gt;3.1Windows&amp;lt;/code&amp;gt;”中的“&amp;lt;code&amp;gt;Windows&amp;lt;/code&amp;gt;”。 &amp;lt;/td&amp;gt;  &amp;lt;td&amp;gt; 反向否定预查，与正向否定预查类拟，只是方向相反。例如“&amp;lt;code&amp;gt;(?</description>
    </item>
    
    <item>
      <title>android WebView视频全屏播放</title>
      <link>https://helixs.github.io/posts/2019-05-22-android-webview%E8%A7%86%E9%A2%91%E5%85%A8%E5%B1%8F%E6%92%AD%E6%94%BE%E6%A0%87%E7%AD%BE/</link>
      <pubDate>Wed, 22 May 2019 10:41:09 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2019-05-22-android-webview%E8%A7%86%E9%A2%91%E5%85%A8%E5%B1%8F%E6%92%AD%E6%94%BE%E6%A0%87%E7%AD%BE/</guid>
      <description>今天有个需求，web页面有个视频是用标签进行播放的，点击放大按钮进行全屏播放。默认情况下，的确可以实现播放功能，但是放大按钮是无法点击的状态。所以我们要进行一下适配了。
注意事项
 启动硬件加速 重写WebChromeClient-onShowCustomView方法 横竖屏切换的适配情况 Activity destory情况  1、硬件加速
&amp;lt;activity &amp;hellip; android:hardwareAccelerated=&amp;ldquo;true&amp;rdquo; /&amp;gt;2、我们重写onShowCustomView
此方法是通知我们当前的页面将进入全屏模式，也就是我们点击那个小全屏图标的时候，参数当中是一个view，需要将这个view添加到activity中的布局中，我们就直接添加到Webview上，毕竟Webview是个FrameLayout。
实现了上面的方法后，video标签上的全屏按钮就有效果了，点击的时候，会撑满当前的WebView的大小（当然，如果实现全屏的话，那你的webview也要撑满全屏才是哦）。这个简易的全屏方式就实现了。
我们也可以将这个全屏模式的view添加到别的layout上面，这个可以在webview不是全屏的页面上使用，具体就不介绍了，大家应该都会
如果有特殊的退出全屏时的操作可以实现这个方法。
3、横竖屏的适配操作
如果页面全屏的时候需要有横屏的要求，需要加入兼容性的配置，最后不要让应用进行自动横竖屏，view的哪些东西保存状态是个麻烦，我们手动请求横竖屏，那么就可以躲避横竖屏自动切换所带来的生命周期干扰了。
当屏幕方向变化的时候会回调Activity的onConfigurationChanged方法，而不会进行生命周期的变化。
基本上我们的全屏功能就完成啦，切换时候的addview和removeView等等需要根据自己的情况实现
4、退出的WebActivity的时候记得调用webview.destory()，异步进程可能导致视频还有声音在播放。
谢谢大家
参考–
android webview中视频播放及全屏Android 横竖屏切换WebView 支持 Html5 video 进行全屏播放</description>
    </item>
    
    <item>
      <title>centos7安装sha*dow***s-libev</title>
      <link>https://helixs.github.io/posts/2019-05-17-centos7%E5%AE%89%E8%A3%85shadows-libev/</link>
      <pubDate>Fri, 17 May 2019 02:05:50 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2019-05-17-centos7%E5%AE%89%E8%A3%85shadows-libev/</guid>
      <description>基于总所周知的原因，获取开发者资料也很是麻烦，顺便做个记录，怕以后忘记。下面所有的xxxxx 替换为 shdowockslibev的版本呢比较的轻量级，用docker的方式安装最是省心。也怪自己不太会docker的使用，就直接用原生吧，以下都是基于centos7的
打开它的github，找到centos 添加libev的源。顺便复制一下这个，创建文件librehat-xxxxx-epel-7.repo
放入/etc/yum.repos.d/
或者直接
 如果出现
Error: Package: xxxxxxx-libev-3.2.0-2.el7.x86_64 (librehat-xxxxx)
Requires: libsodium &amp;gt;= 1.0.4
Error: Package: xxxxxx-libev-3.2.0-2.el7.x86_64 (librehat-xxxxx)
Requires: mbedtls
好像是udns源没有启用上，部分的vps可能会出现这个情况
解决办法github或者
成功后再执行安装操作。
试试呢
加上bbr那么效果更好了</description>
    </item>
    
    <item>
      <title>android沉浸状态栏</title>
      <link>https://helixs.github.io/posts/2019-03-27-android%E6%B2%89%E6%B5%B8%E7%8A%B6%E6%80%81%E6%A0%8F/</link>
      <pubDate>Wed, 27 Mar 2019 07:37:48 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2019-03-27-android%E6%B2%89%E6%B5%B8%E7%8A%B6%E6%80%81%E6%A0%8F/</guid>
      <description>&amp;lt;p&amp;gt; Android 4.4 为什么能够实现沉浸式的效果呢？因为在Android 4.4 新增了一个重要的属性：&amp;lt;code&amp;gt;FLAG_TRANSLUCENT_STATUS&amp;lt;/code&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;pre&amp;gt;&amp;lt;code class=&amp;quot;hljs java copyable&amp;quot;&amp;gt; &amp;amp;lt;span class=&amp;quot;hljs-comment&amp;quot;&amp;gt;/** * Window flag: request a translucent status bar with minimal system-provided * background protection. * * &amp;amp;lt;p&amp;amp;gt;This flag can be controlled in your theme through the * {&amp;amp;lt;span class=&amp;quot;hljs-doctag&amp;quot;&amp;gt;@link&amp;amp;lt;/span&amp;gt; android.R.attr#windowTranslucentStatus} attribute; this attribute * is automatically set for you in the standard translucent decor themes * such as * {&amp;amp;lt;span class=&amp;quot;hljs-doctag&amp;quot;&amp;gt;@link&amp;amp;lt;/span&amp;gt; android.R.style#Theme_Holo_NoActionBar_TranslucentDecor}, * {&amp;amp;lt;span class=&amp;quot;hljs-doctag&amp;quot;&amp;gt;@link&amp;amp;lt;/span&amp;gt; android.R.style#Theme_Holo_Light_NoActionBar_TranslucentDecor}, * {&amp;amp;lt;span class=&amp;quot;hljs-doctag&amp;quot;&amp;gt;@link&amp;amp;lt;/span&amp;gt; android.</description>
    </item>
    
    <item>
      <title>adb_fastboot常用命令</title>
      <link>https://helixs.github.io/posts/2019-03-19-adb_fastboot%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Tue, 19 Mar 2019 03:53:48 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2019-03-19-adb_fastboot%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</guid>
      <description>&amp;lt;div class=&amp;quot;blockcode&amp;quot;&amp;gt; &amp;lt;div id=&amp;quot;code_zsS&amp;quot;&amp;gt; &amp;lt;ol&amp;gt; &amp;lt;li&amp;gt; D: &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; cd adb &amp;lt;/li&amp;gt; &amp;lt;/ol&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;p&amp;gt; 以此切换到D:/adb工作目录，此时可通过输入 &amp;lt;/p&amp;gt; &amp;lt;div class=&amp;quot;blockcode&amp;quot;&amp;gt; &amp;lt;div id=&amp;quot;code_FvG&amp;quot;&amp;gt; &amp;lt;ol&amp;gt; &amp;lt;li&amp;gt; adb version &amp;lt;/li&amp;gt; &amp;lt;/ol&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;p&amp;gt; 根据提示信息确定是否可正常使用，如图即为正常的情况。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; &amp;lt;span style=&amp;quot;font-size: medium;&amp;quot;&amp;gt;&amp;lt;span style=&amp;quot;color: #0000ff;&amp;quot;&amp;gt;&amp;lt;strong&amp;gt;三、我可以用ADB和Fastboot干什么，怎么做？&amp;lt;/strong&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 在做任何事情之前，我们都需要连接手机到电脑端，并开启USB调试模式，通过命令查看是否连接正常。&amp;lt;br /&amp;gt; 如果处在开机状态或recovery下，命令为： &amp;lt;/p&amp;gt; &amp;lt;div class=&amp;quot;blockcode&amp;quot;&amp;gt; &amp;lt;div id=&amp;quot;code_dsO&amp;quot;&amp;gt; &amp;lt;ol&amp;gt; &amp;lt;li&amp;gt; adb devices &amp;lt;/li&amp;gt; &amp;lt;/ol&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;p&amp;gt; Fastboot下，命令为 &amp;lt;/p&amp;gt; &amp;lt;div class=&amp;quot;blockcode&amp;quot;&amp;gt; &amp;lt;div id=&amp;quot;code_V9r&amp;quot;&amp;gt; &amp;lt;ol&amp;gt; &amp;lt;li&amp;gt; fastboot devices &amp;lt;/li&amp;gt; &amp;lt;/ol&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;p&amp;gt; 根据返回信息确认是否连接正常，若返回信息左侧显示为一序列号，右侧显示device或recovery或sideload或fastboot均为正常情况，分别代表此时设备所处的状态，如： &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; &amp;lt;strong&amp;gt;&amp;lt;span style=&amp;quot;font-size: medium;&amp;quot;&amp;gt;&amp;lt;span style=&amp;quot;color: #f4a460;&amp;quot;&amp;gt;&amp;lt;1&amp;gt;ADB工具&amp;lt;/span&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;/strong&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 最常用的，我们可以通过ADB，我们可以进行通过USB端进行ROM刷机包刷机操作。&amp;lt;br /&amp;gt; 将手机进入Recovery模式，可看到，由于一加三由于出厂Android版本为6.</description>
    </item>
    
    <item>
      <title>androidButton设置minHeight和minWidth无效的问题</title>
      <link>https://helixs.github.io/posts/2019-03-11-androidbutton%E8%AE%BE%E7%BD%AEminheight%E5%92%8Cminwidth%E6%97%A0%E6%95%88%E7%9A%84%E9%97%AE%E9%A2%98/</link>
      <pubDate>Mon, 11 Mar 2019 03:46:00 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2019-03-11-androidbutton%E8%AE%BE%E7%BD%AEminheight%E5%92%8Cminwidth%E6%97%A0%E6%95%88%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
      <description>今天在代码中设置button的minheight，发现没有效果。结果发现代码中设置minHeight实际上对应的是text的绘制最小区域，要使用minimumHeight
 </description>
    </item>
    
    <item>
      <title>实现在gridLayoutManager中宽高一致的item</title>
      <link>https://helixs.github.io/posts/2019-03-06-%E5%AE%9E%E7%8E%B0%E5%9C%A8gridlayoutmanager%E4%B8%AD%E5%AE%BD%E9%AB%98%E4%B8%80%E8%87%B4%E7%9A%84item/</link>
      <pubDate>Wed, 06 Mar 2019 09:34:07 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2019-03-06-%E5%AE%9E%E7%8E%B0%E5%9C%A8gridlayoutmanager%E4%B8%AD%E5%AE%BD%E9%AB%98%E4%B8%80%E8%87%B4%E7%9A%84item/</guid>
      <description> </description>
    </item>
    
    <item>
      <title>卸载阿里云监控服务</title>
      <link>https://helixs.github.io/posts/2019-03-06-%E5%8D%B8%E8%BD%BD%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%91%E6%8E%A7%E6%9C%8D%E5%8A%A1/</link>
      <pubDate>Wed, 06 Mar 2019 05:28:28 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2019-03-06-%E5%8D%B8%E8%BD%BD%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%91%E6%8E%A7%E6%9C%8D%E5%8A%A1/</guid>
      <description>卸载阿里云盾监控： 删除残留： 屏蔽云盾 IP，用包过滤屏蔽如下IP： 卸载云监控Java版本插件： sudo /usr/local/cloudmonitor/wrapper/bin/cloudmonitor.sh remove
sudo rm -rf /usr/local/cloudmonitor</description>
    </item>
    
    <item>
      <title>android从view中获取bitmap</title>
      <link>https://helixs.github.io/posts/2019-02-28-android%E4%BB%8Eview%E4%B8%AD%E8%8E%B7%E5%8F%96bitmap/</link>
      <pubDate>Thu, 28 Feb 2019 05:49:50 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2019-02-28-android%E4%BB%8Eview%E4%B8%AD%E8%8E%B7%E5%8F%96bitmap/</guid>
      <description>我们从屏幕截图或者从imageView中获得bitmap大多都是从以下代码获取
但是这些方法在api28的时候都过期了，虽然可以用不过在api26之后google放了个PixelCopy这个类，他是直接从指定的window上获取surface对象 在通过native方法获取的。
&amp;lt;div&amp;gt; 还有它不是直接在view上获取，而是在window上，所以要确定要位置，不然获取的地方不单单是你绘制的那个区域了，所以我们要把控好位置和距离，这个是缺点如果图像层叠的话那就没办法了，盖住的部分肯定无法获取，这是缺点。不过也带来了优点，如果像获取某个区域块的图像，更是一种好方法。 如果不行那就还是用老的方法吧。 &amp;lt;/div&amp;gt; </description>
    </item>
    
    <item>
      <title>自定义View绘制等相关介绍地址</title>
      <link>https://helixs.github.io/posts/2019-02-26-%E8%87%AA%E5%AE%9A%E4%B9%89view%E7%BB%98%E5%88%B6%E7%AD%89%E7%9B%B8%E5%85%B3%E4%BB%8B%E7%BB%8D%E5%9C%B0%E5%9D%80/</link>
      <pubDate>Tue, 26 Feb 2019 03:07:37 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2019-02-26-%E8%87%AA%E5%AE%9A%E4%B9%89view%E7%BB%98%E5%88%B6%E7%AD%89%E7%9B%B8%E5%85%B3%E4%BB%8B%E7%BB%8D%E5%9C%B0%E5%9D%80/</guid>
      <description>Android图像处理——Paint之Xfermode https://blog.csdn.net/allen315410/article/details/45077165 </description>
    </item>
    
    <item>
      <title>Bitmap加载之基本的使用</title>
      <link>https://helixs.github.io/posts/2019-02-26-bitmap%E5%8A%A0%E8%BD%BD%E4%B9%8B%E5%9F%BA%E6%9C%AC%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Tue, 26 Feb 2019 02:48:29 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2019-02-26-bitmap%E5%8A%A0%E8%BD%BD%E4%B9%8B%E5%9F%BA%E6%9C%AC%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>上一篇文章已经转载了大神的，总结一下基本的加载使用方式
 </description>
    </item>
    
    <item>
      <title>Android Bitmap最全面详解</title>
      <link>https://helixs.github.io/posts/2019-02-26-android-bitmap%E6%9C%80%E5%85%A8%E9%9D%A2%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Tue, 26 Feb 2019 02:33:58 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2019-02-26-android-bitmap%E6%9C%80%E5%85%A8%E9%9D%A2%E8%AF%A6%E8%A7%A3/</guid>
      <description>https://juejin.im/entry/59b6419d5188257e82675716  Bitmap图像处理的最重要类之一。用它可以获取图像文件信息，进行图像颜色变换、剪切、旋转、缩放等操作，并可以指定格式保存图像文件
 ____
Bitmap中有两个内部枚举类：Config和CompressFormat，
Config是用来设置颜色配置信息的，
CompressFormat是用来设置压缩方式的。
__
Config解析：
 Bitmap.Config.ALPHA_8：颜色信息只由透明度组成，占8位。 Bitmap.Config.ARGB_4444：颜色信息由透明度与R（Red），G（Green），B（Blue）四部分组成，每个部分都占4位，总共占16位。 Bitmap.Config.ARGB_8888：颜色信息由透明度与R（Red），G（Green），B（Blue）四部分组成，每个部分都占8位，总共占32位。是Bitmap默认的颜色配置信息，也是最占空间的一种配置。 Bitmap.Config.RGB_565：颜色信息由R（Red），G（Green），B（Blue）三部分组成，R占5位，G占6位，B占5位，总共占16位。   通常我们优化Bitmap时，当需要做性能优化或者防止OOM（Out Of Memory），我们通常会使用Bitmap.Config.RGB_565这个配置，因为Bitmap.Config.ALPHA_8只有透明度，显示一般图片没有意义，Bitmap.Config.ARGB_4444显示图片不清楚，Bitmap.Config.ARGB_8888占用内存最多。
 CompressFormat解析：
 Bitmap.CompressFormat.JPEG：表示以JPEG压缩算法进行图像压缩，压缩后的格式可以是”.jpg”或者”.jpeg”，是一种有损压缩。 Bitmap.CompressFormat.PNG：表示以PNG压缩算法进行图像压缩，压缩后的格式可以是”.png”，是一种无损压缩。 Bitmap.CompressFormat.WEBP：表示以WebP压缩算法进行图像压缩，压缩后的格式可以是”.webp”，是一种有损压缩，质量相同的情况下，WebP格式图像的体积要比JPEG格式图像小40%。美中不足的是，WebP格式图像的编码时间“比JPEG格式图像长8倍”。  itmap.createBitmap(Bitmap source, int x, int y, int width, int height)
根据源Bitmap对象source，创建出source对象裁剪后的图像的Bitmap。x,y分别代表裁剪时，x轴和y轴的第一个像素，width，height分别表示裁剪后的图像的宽度和高度。 注意：x+width要小于等于source的宽度，y+height要小于等于source的高度。
Bitmap.createBitmap(Bitmap source, int x, int y, int width, int height,Matrix m, boolean filter)
这个方法只比上面的方法多了m和filter这两个参数，m是一个Matrix（矩阵）对象，可以进行缩放，旋转，移动等动作，filter为true时表示source会被过滤，仅仅当m操作不仅包含移动操作，还包含别的操作时才适用。其实上面的方法本质上就是调用这个方法而已。
 public static Bitmap createBitmap(Bitmap source, int x, int y, int width, int height) { return createBitmap(source, x, y, width, height, null, false); }  Bitmap缩放，旋转，移动，倾斜图像其实就是通过Bitmap.</description>
    </item>
    
    <item>
      <title>viewpager&#43;fragment的懒加载</title>
      <link>https://helixs.github.io/posts/2019-02-15-viewpagerfragment%E7%9A%84%E6%87%92%E5%8A%A0%E8%BD%BD/</link>
      <pubDate>Fri, 15 Feb 2019 06:02:00 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2019-02-15-viewpagerfragment%E7%9A%84%E6%87%92%E5%8A%A0%E8%BD%BD/</guid>
      <description>使用 FragmentPagerAdapter 时，ViewPager 中的所有 Fragment 实例常驻内存，当 Fragment 变得不可见时仅仅是视图结构的销毁，即调用了 onDestroyView 方法。由于 FragmentPagerAdapter 内存消耗较大，所以适合少量静态页面的场景。
使用 FragmentStatePagerAdapter 时，当 Fragment 变得不可见，不仅视图层次销毁，实例也被销毁，即调用了 onDestroyView 和 onDestroy 方法，仅仅保存 Fragment 状态。相比而言， FragmentStatePagerAdapter 内存占用较小，所以适合大量动态页面，比如我们常见的新闻列表类应用。
不管是哪种情况，他们的view都是有可能被销毁的。关键点是在于view的保存和fragment的显示隐藏状态
 二 、当使用FragmentPagerAdapter动态删除和添加的问题 看下面的源码
instantiateItem在执行时会FragmentManager里面查找是否已存在对应的fragment，如果不存在，才会执行getItem 。所以会无效
两个解决方法
1使用FragmentPagerStateAdapter
2覆写getItemId()
  未完待续
感谢http://yifeng.studio/2016/12/23/android-fragment-and-viewpager-attentions/ </description>
    </item>
    
    <item>
      <title>java和kotlin中泛型通配符（草稿）</title>
      <link>https://helixs.github.io/posts/2019-01-28-java%E5%92%8Ckotlin%E4%B8%AD%E6%B3%9B%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6%E8%8D%89%E7%A8%BF/</link>
      <pubDate>Mon, 28 Jan 2019 13:57:41 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2019-01-28-java%E5%92%8Ckotlin%E4%B8%AD%E6%B3%9B%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6%E8%8D%89%E7%A8%BF/</guid>
      <description>今天开始仔细研究kotlin的泛型，顺便把java的泛型也温习一下。
 =============================================
在kotlin中亦是如此
in：很像&amp;lt;? super T&amp;gt; out很像&amp;lt;? extends T&amp;gt; 不过他们限制的更加严格，变量类型中无法加入&amp;lt;? extends T&amp;gt;和&amp;lt;？super T&amp;gt; 在类型定义的时候已经限制好了
参考资料
https://www.kotlincn.net/docs/reference/generics.html https://zhuanlan.zhihu.com/p/27672091 https://www.jianshu.com/p/a41cb479b278      </description>
    </item>
    
    <item>
      <title>android布局之ConstraintLayout的一些特性</title>
      <link>https://helixs.github.io/posts/2019-01-22-android%E5%B8%83%E5%B1%80%E4%B9%8Bconstraintlayout%E7%9A%84%E4%B8%80%E4%BA%9B%E7%89%B9%E6%80%A7/</link>
      <pubDate>Tue, 22 Jan 2019 08:43:57 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2019-01-22-android%E5%B8%83%E5%B1%80%E4%B9%8Bconstraintlayout%E7%9A%84%E4%B8%80%E4%BA%9B%E7%89%B9%E6%80%A7/</guid>
      <description>前前后后google不知道每年推出N中新东西，每次看了看就忘记了，还是回忆一下ConstraintLayout这个约束布局了。
&amp;lt;ol&amp;gt; &amp;lt;li&amp;gt; 解决复杂布局嵌套过多，影响性能的问题。 &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; 相对定位，和RelativeLayout大致相同，也同样支持Baseline基线定位。 &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; 角度定位，更加玄学了。角度和距离定位了（想象一下在直角坐标系中中心点O距离点A的角度和距离了）。 &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; 支持按照比例偏移。 &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; 尺寸方面，match_parent尽量少用，直接0dp往上干。并且更好的支持比例约束。 &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; 链式布局，可以想象在Flex布局中justify-content，不过没有flex那么强大啦，也只有3个属性选择。 &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; Optimizer，当控件设置尺寸为0dp的时候布局会进行二次测量，不可避免的会进行耗时操作，所以要进行处理。 &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; Barrier，屏障，相当于一个阈值吧，不过我这样形容不恰当。 &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; Group，可以将控件进行分组，而直接在这个组上面设置属性，那么组当中所带入的属性会直接传到属于这个组的控件上面。感觉这个设计特别棒，如统一的颜色和统一的显示隐藏等。 &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; Placeholder，占位符，也很吊，可以动态控制显示的控件。不需要我们每次动态setVisibility了。 &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; Guideline，辅助线，执行复杂布局中这个是很有效的东西哦 &amp;lt;/li&amp;gt; &amp;lt;/ol&amp;gt; &amp;lt;p&amp;gt; 上面就是这个ConstraintLayout的一些特性了。下面就慢慢的介绍一下它的具体使用方式 &amp;lt;/p&amp;gt;  &amp;lt;p&amp;gt; &amp;lt;code class=&amp;quot;api-signature&amp;quot;&amp;gt;public class ConstraintLayout &amp;lt;/code&amp;gt;&amp;lt;code class=&amp;quot;api-signature&amp;quot;&amp;gt;&amp;amp;lt;code class=&amp;quot;api-signature&amp;quot;&amp;gt;extends &amp;lt;/code&amp;gt;&amp;lt;/code&amp;gt;&amp;lt;a href=&amp;quot;http://developer.android.com/reference/android/view/ViewGroup.html&amp;quot;&amp;gt;ViewGroup&amp;lt;/a&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;div class=&amp;quot;devsite-table-wrapper&amp;quot;&amp;gt; &amp;lt;table class=&amp;quot;jd-inheritance-table&amp;quot;&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td class=&amp;quot;jd-inheritance-class-cell&amp;quot; colspan=&amp;quot;4&amp;quot;&amp;gt; &amp;lt;a href=&amp;quot;http://developer.android.com/reference/java/lang/Object.html&amp;quot;&amp;gt;java.lang.Object&amp;lt;/a&amp;gt; &amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td class=&amp;quot;jd-inheritance-space&amp;quot;&amp;gt; ↳ &amp;lt;/td&amp;gt; &amp;lt;td class=&amp;quot;jd-inheritance-class-cell&amp;quot; colspan=&amp;quot;3&amp;quot;&amp;gt; &amp;lt;a href=&amp;quot;http://developer.</description>
    </item>
    
    <item>
      <title>centos开启bbr</title>
      <link>https://helixs.github.io/posts/2019-01-16-centos%E5%BC%80%E5%90%AFbbr/</link>
      <pubDate>Wed, 16 Jan 2019 06:29:02 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2019-01-16-centos%E5%BC%80%E5%90%AFbbr/</guid>
      <description>TCP BBR是谷歌出品的TCP拥塞控制算法。BBR目的是要尽量跑满带宽，并且尽量不要有排队的情况。BBR可以起到单边加速TCP连接的效果。
Google提交到Linux主线并发表在ACM queue期刊上的TCP-BBR拥塞控制算法。继承了Google“先在生产环境上部署，再开源和发论文”的研究传统。TCP-BBR已经再YouTube服务器和Google跨数据中心的内部广域网(B4)上部署。由此可见出该算法的前途。
TCP-BBR的目标就是最大化利用网络上瓶颈链路的带宽。一条网络链路就像一条水管，要想最大化利用这条水管，最好的办法就是给这跟水管灌满水。
 BBR解决了两个问题：
 在有一定丢包率的网络链路上充分利用带宽。非常适合高延迟，高带宽的网络链路。 降低网络链路上的buffer占用率，从而降低延迟。非常适合慢速接入网络的用户。  以上来自http://blog.51cto.com/zero01/2064660 通过上面我们大概知道bbr就是想办法给你加大带宽流量的和速锐那种暴力发包是两回事。google的这个bbr算法已经集成到linux4.9内核以上，即便你的系统是最新版但是大多数情况下云服务厂商默认都还是使用的3.x，所以我们要升级内核并且切换到该内核上面，最后再开启bbr。
然后我们进入http://elrepo.org/tiki/tiki-index.php 查看最新的rpm源，按照上面的方法进行源设置
最新的教程已经不需要上面的这样了直接install
然后，进入http://elrepo.org/tiki/kernel-ml 查看安装方法
然后，使用这个看不懂的命令进入查看已经安装的内核
我这里已经安装了4.20的内核版本了，还得切换到这个内核
基本上就成功啦。</description>
    </item>
    
    <item>
      <title>idea显示kotlin的推断类型</title>
      <link>https://helixs.github.io/posts/2019-01-15-idea%E6%98%BE%E7%A4%BAkotlin%E7%9A%84%E6%8E%A8%E6%96%AD%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Tue, 15 Jan 2019 07:58:09 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2019-01-15-idea%E6%98%BE%E7%A4%BAkotlin%E7%9A%84%E6%8E%A8%E6%96%AD%E7%B1%BB%E5%9E%8B/</guid>
      <description>我们使用idea写kotlin代码的时候有很多类型都是自己判断了，不用像java一样强制定义类型，可是当我们写了一个变量或者赋值变量的时候能看到val或者是var的类型
比如我们现在想要这样一个代码
默认情况下我并不知道rect是个什么类型，然后我们就打开idea的设置了Setting-&amp;gt;Editor-&amp;gt;Appearance-&amp;gt;show parameter name hints-&amp;gt;Configure-&amp;gt;Language=Kotlin然后下面的选项那么多，那就全部选中了。GG图片就不用粘上去了，毕竟带宽有限。
 </description>
    </item>
    
    <item>
      <title>java关于判断emoji位数和截取的一些处理</title>
      <link>https://helixs.github.io/posts/2019-01-14-java%E5%85%B3%E4%BA%8E%E5%88%A4%E6%96%ADemoji%E4%BD%8D%E6%95%B0%E5%92%8C%E6%88%AA%E5%8F%96%E7%9A%84%E4%B8%80%E4%BA%9B%E5%A4%84%E7%90%86/</link>
      <pubDate>Mon, 14 Jan 2019 08:18:11 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2019-01-14-java%E5%85%B3%E4%BA%8E%E5%88%A4%E6%96%ADemoji%E4%BD%8D%E6%95%B0%E5%92%8C%E6%88%AA%E5%8F%96%E7%9A%84%E4%B8%80%E4%BA%9B%E5%A4%84%E7%90%86/</guid>
      <description>今天android项目里有个需求，一个textview中要显示最多8个字符，英文算一个，中文算两个。满满以为直接用一下这种方法判断了
结果测试加入了emoji表情，直接截取0-7会在部分手机上出现？等无法识别的情况，然后是查了查emoji是基于Unicode编码来的，也就是说随便一个emoji组成的字符长度最少是两位,所以我直接截取了表情的一半那肯定就是不行了，然后具体查了查编码的历史从ascii到utf-8等等，这里。
然后找到了java的api主要关于unicode有以下几个方法
&amp;lt;td&amp;gt; &amp;lt;code&amp;gt;&amp;amp;lt;b&amp;gt;&amp;amp;lt;a href=&amp;quot;http://tool.oschina.net/uploads/apidocs/jdk-zh/java/lang/String.html#codePointAt(int)&amp;quot;&amp;gt;codePointAt&amp;amp;lt;/a&amp;gt;&amp;amp;lt;/b&amp;gt;(int index)&amp;lt;/code&amp;gt;&amp;lt;br /&amp;gt; 返回指定索引处的字符（Unicode 代码点）。 &amp;lt;/td&amp;gt;  &amp;lt;td&amp;gt; &amp;lt;code&amp;gt;&amp;amp;lt;b&amp;gt;&amp;amp;lt;a href=&amp;quot;http://tool.oschina.net/uploads/apidocs/jdk-zh/java/lang/String.html#codePointBefore(int)&amp;quot;&amp;gt;codePointBefore&amp;amp;lt;/a&amp;gt;&amp;amp;lt;/b&amp;gt;(int index)&amp;lt;/code&amp;gt;&amp;lt;br /&amp;gt; 返回指定索引之前的字符（Unicode 代码点）。 &amp;lt;/td&amp;gt;  &amp;lt;td&amp;gt; &amp;lt;code&amp;gt;&amp;amp;lt;b&amp;gt;&amp;amp;lt;a href=&amp;quot;http://tool.oschina.net/uploads/apidocs/jdk-zh/java/lang/String.html#codePointCount(int,%20int)&amp;quot;&amp;gt;codePointCount&amp;amp;lt;/a&amp;gt;&amp;amp;lt;/b&amp;gt;(int beginIndex, int endIndex)&amp;lt;/code&amp;gt;&amp;lt;br /&amp;gt; 返回此 &amp;lt;code&amp;gt;String&amp;lt;/code&amp;gt; 的指定文本范围中的 Unicode 代码点数。 &amp;lt;/td&amp;gt;  &amp;lt;td&amp;gt; &amp;lt;code&amp;gt;&amp;amp;lt;b&amp;gt;&amp;amp;lt;a href=&amp;quot;http://tool.oschina.net/uploads/apidocs/jdk-zh/java/lang/String.html#offsetByCodePoints(int,%20int)&amp;quot;&amp;gt;offsetByCodePoints&amp;amp;lt;/a&amp;gt;&amp;amp;lt;/b&amp;gt;(int index, int codePointOffset)&amp;lt;/code&amp;gt;&amp;lt;br /&amp;gt; 返回此 &amp;lt;code&amp;gt;String&amp;lt;/code&amp;gt; 中从给定的 &amp;lt;code&amp;gt;index&amp;lt;/code&amp;gt; 处偏移 &amp;lt;code&amp;gt;codePointOffset&amp;lt;/code&amp;gt; 个代码点的索引。 &amp;lt;/td&amp;gt;  我们现在截取的字符数量是8位，然后我们就找到在0到7位中的unicode编码，这样汉字和emoji就一起解决了。
是不是比上一个代码实现的简单的多。</description>
    </item>
    
    <item>
      <title>android项目引入kotlin包冲突问题</title>
      <link>https://helixs.github.io/posts/2018-12-26-android%E9%A1%B9%E7%9B%AE%E5%BC%95%E5%85%A5kotlin%E5%8C%85%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98/</link>
      <pubDate>Wed, 26 Dec 2018 08:46:59 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2018-12-26-android%E9%A1%B9%E7%9B%AE%E5%BC%95%E5%85%A5kotlin%E5%8C%85%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98/</guid>
      <description>今天在android项目中导入了kotlin的支持，可是怎么运行也运行不起来
Program type already present: javax.annotation.CheckReturnValue
等等 包冲突了，检查不同的library的版本，然后清空缓存重试</description>
    </item>
    
    <item>
      <title>Glide在共享元素动画时会gif会停止播放</title>
      <link>https://helixs.github.io/posts/2018-12-19-glide%E5%9C%A8%E5%85%B1%E4%BA%AB%E5%85%83%E7%B4%A0%E5%8A%A8%E7%94%BB%E6%97%B6%E4%BC%9Agif%E4%BC%9A%E5%81%9C%E6%AD%A2%E6%92%AD%E6%94%BE/</link>
      <pubDate>Wed, 19 Dec 2018 07:29:46 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2018-12-19-glide%E5%9C%A8%E5%85%B1%E4%BA%AB%E5%85%83%E7%B4%A0%E5%8A%A8%E7%94%BB%E6%97%B6%E4%BC%9Agif%E4%BC%9A%E5%81%9C%E6%AD%A2%E6%92%AD%E6%94%BE/</guid>
      <description>在上一篇文章中我们实现了recyclerView到viewpager的转换，用glide加载gif，viewpager中并不能正常播放，把动画关了就可以，初步猜想是因为，我们在viewpager的istantiateItem中用glide直接去into了，此时共享元素动画是处于暂停状态，所以我们的gif也被迫暂停，当然我这只是猜想。可以等viewpager加载完成之后再into，或者延迟加载。</description>
    </item>
    
    <item>
      <title>android recyclerview点击跳转到viewpager共享元素动画</title>
      <link>https://helixs.github.io/posts/2018-12-11-android-recyclerview%E7%82%B9%E5%87%BB%E8%B7%B3%E8%BD%AC%E5%88%B0viewpager%E5%85%B1%E4%BA%AB%E5%85%83%E7%B4%A0%E5%8A%A8%E7%94%BB/</link>
      <pubDate>Tue, 11 Dec 2018 06:35:19 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2018-12-11-android-recyclerview%E7%82%B9%E5%87%BB%E8%B7%B3%E8%BD%AC%E5%88%B0viewpager%E5%85%B1%E4%BA%AB%E5%85%83%E7%B4%A0%E5%8A%A8%E7%94%BB/</guid>
      <description>今天做项目的时候用到了Transition动画。也就是android5.0中出现的。基本的使用方式我们都知道是用TransitionName在两个activity中进行绑定。现在的场景是activityA中有个recyclerview，点击item的时候跳转到activityB。B中是一个类似全屏的viewpager。item中的图片元素共享的viewpager指定的Item上。并且viewpager可以动态删除item，返回的A的时候item也要同步数量。想想实现功能应该不难。难的地方在于两个页面的item数量不一样，共享元素view的位置可能也不一样。如果B当中已经改变了item的数量和选中的viewpager的position的位置，A那边的共享元素该如何改变呢。现在开始展现真正的轮子了。
设置两个activity的style中 &amp;lt;span style=&amp;ldquo;color: #ff0000;&amp;quot;&amp;gt;android:windowContentTransitions&amp;lt;/span&amp;gt;为true
共享元素关键点是绑定的view和view的TransitionName，那么我们就要给itemView设置transitionName了。这里我们使用url给item设置TransitionName，如果item的url一样那么可以自己想想，保持唯一就行了。
ViewCompat是support兼容类。不然就要写一堆判断了很是烦。
启动activity绑定transitionView,将list和选中的item传入
之后我们到了B的Activity，这里我们不要为viewpager的每个itemview设置transitionName，我们直接给viewpager设置transitionName，以为viewpager选中页的两边都会加载view，处理起来稍微有点麻烦，直接设置viewpager的transitionName反而方便连贯。
  2、进阶使用 基本的点击返回效果我们就搞好了，可是还是会出现动画不连贯的效果。一头雾水的搜了一下
因为viewpager.setCurrentItem之后UI毕竟是在默认300ms完成绘制。所以我们要等待viewpager完全展示完成才能进行过渡动画的渲染。
这样我们的连贯效果就实现了。
3、完成实现 因为我们知道B页面是带有删除和翻页功能的，所以我们就要进行页面之间切换时候的ui数据整理。我试着在onActivityResult中用supportPostponeEnterTransition和supportStartPostponedEnterTransition实现数据的变换，发现效果并没有实现，onActivityResult在过渡动画后才调用。所以还是搜索一下
满怀希望的试一试。结果懵逼，切换了还是没效果。。。==。B页面的共享viewpager的TransitionName还是原来的。我们要在返回的时候设置viewpager的TransitionName为当前选中的item的url。
B中
这里具体可以参考 https://blog.csdn.net/mr_wrong1/article/details/49669275 哈哈 。可以了。不过最后一步中，感觉只需要设置viewpager的TransitionName就行了，没试过。有时间再试试吧。
4、遇到的问题 项目加载网络图片会出现一些问题。如果使用glide的话要禁用动画加载dontAnimate。
还有部分时候会出现viewpager翻页会出现返回动画失效的问题,我们在返回的时候需要进行view的替换
over</description>
    </item>
    
    <item>
      <title>git 配置代理 解决访问github等访问过慢的问题</title>
      <link>https://helixs.github.io/posts/2018-11-30-git-%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86-%E8%A7%A3%E5%86%B3%E8%AE%BF%E9%97%AEgithub%E7%AD%89%E8%AE%BF%E9%97%AE%E8%BF%87%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98/</link>
      <pubDate>Fri, 30 Nov 2018 06:52:25 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2018-11-30-git-%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86-%E8%A7%A3%E5%86%B3%E8%AE%BF%E9%97%AEgithub%E7%AD%89%E8%AE%BF%E9%97%AE%E8%BF%87%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
      <description>最近不知道怎么的从git上下来代码好慢，访问github没啥问题，找了一下原来是http://github.global.ssl.fastly.Net这个被我们伟大的墙把限制邪恶的资本主义限制了。
前提是你要开代理，正常情况下ss for windows的http和socks5都是共用的1080端口，mac 版本的ng要设置http端口，这里以1080为例。网上基本上都是全局的设置
果然是立竿见影，可是如果是访问内网或者国内的git仓局要么找不到要么就很慢，这个可是不行的，所以我们只能针对github进行代理
上面是走http代理，下面是走sock5代理
 取消代理如下
我们也可以进行再git配置文件下，默认在用户目录.gitconfig
感谢 https://www.zhihu.com/question/27159393</description>
    </item>
    
    <item>
      <title>centos7 aria2 安装配置</title>
      <link>https://helixs.github.io/posts/2018-11-21-aria2%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</link>
      <pubDate>Wed, 21 Nov 2018 07:45:05 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2018-11-21-aria2%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</guid>
      <description>下载并编译aria2 最新版本新建aria2.conf配置文件
vi /etc/aria2/aria2.conf
测试
 配置www权限：&amp;lt;span class=&amp;ldquo;hljs-attribute&amp;rdquo;&amp;gt;vi&amp;lt;/span&amp;gt; /etc/sudoers按“i”进入编辑： root ALL=(ALL:ALL) ALL 这行下面添加上
强制保存退出。
以www身份运行aria2
或者
配置开机自启动：&amp;lt;span class=&amp;ldquo;hljs-attribute&amp;rdquo;&amp;gt;vi&amp;lt;/span&amp;gt; /etc/rc.local 在 exit 0 前面加上sudo -u www aria2c &amp;ndash;conf-path=&amp;lt;span class=&amp;ldquo;hljs-regexp&amp;rdquo;&amp;gt;/etc/&amp;lt;/span&amp;gt;aria2/aria2.conf -D来自 这里配置成系统服务
赋予aria2c文件可执行权限
from如果遇到多用户权限问题可以这样操作 https://www.jianshu.com/p/955e933eb191 </description>
    </item>
    
    <item>
      <title>Centos安装NextCloud</title>
      <link>https://helixs.github.io/posts/2018-11-19-/</link>
      <pubDate>Mon, 19 Nov 2018 03:09:58 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2018-11-19-/</guid>
      <description></description>
    </item>
    
    <item>
      <title>WordPress&#43;Nginx搭建全过程</title>
      <link>https://helixs.github.io/posts/2018-11-12-wordpressnginx%E6%90%AD%E5%BB%BA/</link>
      <pubDate>Mon, 12 Nov 2018 10:24:15 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2018-11-12-wordpressnginx%E6%90%AD%E5%BB%BA/</guid>
      <description>最近在学习linux基础，打算搭个blog做个笔记。因为练手的需要，在瓦工上租借了一年的VPS，毕竟是双十一特价(PS：国内环境太差了，1Mbps还贵的不行，还要传身份证备案，当初在百度云和华为云注册了一下，隔三差五给我来个电话，发营销短信，我也是受不了了。虽然我不是做WF的事情，国内的隐私已经不是隐私了)。
我装的系统是centos7，vps内存就那么点，就打算使用nginx替代apache了。又得知nginx主要是用来处理静态网页比较给力，对用php开发的wordpress是天生的不支持。所以就要通过nginx将php的动态请求转发到php-fpm解析器，处理完成后再通过nginx回馈给client，大概就是这个过程。
本文章写于2018年11月份，看看wordpress官网的最新版本，我下载的是4.9.8版本。然后开看看这个版本的最低环境要求：
 PHP 7.2或更高版本。 MySQL 5.6或更高版本_或_ MariaDB 版本10.0或更高版本(内存怪兽)。 HTTPS 支持(这个看自己需求了)  1、安装php 7.x2、安装MariaDB(与MySql源自同根生，只是oracle一贯的德行，没看到google被oracle搞的气的不行)设置数据库
$ mysql_secure_installation
下面就是根据自己的需求了
# Enter current password for root (enter for none): 输入当前的root密码(默认空)，直接回车
# Set root password?[Y/n] 设置新密码，y
# Remove anonymous users?[Y/n] 移除匿名用户，y
# Disallow root login remotely?[Y/n] 禁止root用户远程登录，y
# Remove test database and access to it?[Y/n] 移除测试数据库，y
# Reload privilege tables now?[Y/n] y
$ mysql -u ‘数据库用户’ -p因为是我用的是root所以就填的root了，然后输入数据库用户的密码就是你刚才设置的
$ CREATE DATABASE wordpress(名字随意，初始化进入wordpress的时候是要选择这个的)
exit
这样我们的数据库配置基本上就完成了</description>
    </item>
    
    <item>
      <title>centos7 防火墙端口配置和SSH端口配置</title>
      <link>https://helixs.github.io/posts/2018-10-31-centos7-%E9%98%B2%E7%81%AB%E5%A2%99%E7%AB%AF%E5%8F%A3%E9%85%8D%E7%BD%AE%E5%92%8Cssh%E7%AB%AF%E5%8F%A3%E9%85%8D%E7%BD%AE-/</link>
      <pubDate>Tue, 30 Oct 2018 21:36:03 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2018-10-31-centos7-%E9%98%B2%E7%81%AB%E5%A2%99%E7%AB%AF%E5%8F%A3%E9%85%8D%E7%BD%AE%E5%92%8Cssh%E7%AB%AF%E5%8F%A3%E9%85%8D%E7%BD%AE-/</guid>
      <description>防火墙 启动防火墙
systemctl start firewalld 关闭防火墙
systemctl stop firewalld 查看防火墙状态
systemctl status firewalld CRLF will be replaced by LF in blog/content/posts/2018-11-21-aria2配置文件.md. The file will have its original line endings in your working directory
开机禁用防火墙
systemctl disable firewalld 开机启用防火墙
systemctl enable firewalld 开放指定端口 firewall-cmd --zone=public --add-port=80/tcp --permanent 关闭指定端口
firewall-cmd --zone=public --remove-port=80/tcp --permanent 重启防火墙 firewall-cmd --reload –zone 作用域
–add-port=80/tcp 添加端口，格式为：端口/通讯协议
–permanent 永久生效，没有此参数重启后失效
查看防火墙规则 firewall-cmd --list-all 查看开放端口
firewall-cmd --list-ports  SSH vim /etc/ssh/sshd_config 找到下面 Port 大部分默认端口为22 改成你想要的端口如 1234</description>
    </item>
    
    <item>
      <title>android TextView总汇</title>
      <link>https://helixs.github.io/posts/2019-03-13-/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2019-03-13-/</guid>
      <description>textview inputtype</description>
    </item>
    
    <item>
      <title>android 启动速度优化</title>
      <link>https://helixs.github.io/posts/2019-05-17-/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2019-05-17-/</guid>
      <description>我们打开一些androidApp的时候老是会出现一些黑屏，白屏，延迟打开等部分情况。少则1-2秒多则3-5秒
1、我们通过adb shell命令来查看启动耗时的部分情况
 ThisTime-&amp;gt;从launch到SplashActivity启动所消耗的时间
TotalTime-&amp;gt;如果有多个activity的话就是总共的时长
WaitTime-&amp;gt;创建进程到启动所消耗的时间
2、</description>
    </item>
    
    <item>
      <title>android 查看签名md5及sha</title>
      <link>https://helixs.github.io/posts/2019-03-26-/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2019-03-26-/</guid>
      <description>安装jdk，配置path变量</description>
    </item>
    
    <item>
      <title>Android_JetPack之ViewModel</title>
      <link>https://helixs.github.io/posts/2020-09-30-/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2020-09-30-/</guid>
      <description>我们来引用官方对ViewModel的定义，我们为什么使用它？
ViewModel类旨在以注重生命周期的方式存储和管理界面相关的数据。ViewModel类让数据可在发生屏幕旋转等配置更改后继续留存。Android 框架可以管理界面控制器（如 Activity 和 Fragment）的生命周期。Android 框架可能会决定销毁或重新创建界面控制器，以响应完全不受您控制的某些用户操作或设备事件。如果系统销毁或重新创建界面控制器，则存储在其中的任何临时性界面相关数据都会丢失。例如，应用的某个 Activity 中可能包含用户列表。因配置更改而重新创建 Activity 后，新 Activity 必须重新提取用户列表。对于简单的数据，Activity 可以使用 onSaveInstanceState()方法从 onCreate()中的捆绑包恢复其数据，但此方法仅适合可以序列化再反序列化的少量数据，而不适合数量可能较大的数据，如用户列表或位图。另一个问题是，界面控制器经常需要进行异步调用，这些调用可能需要一些时间才能返回结果。界面控制器需要管理这些调用，并确保系统在其销毁后清理这些调用以避免潜在的内存泄露。此项管理需要大量的维护工作，并且在因配置更改而重新创建对象的情况下，会造成资源的浪费，因为对象可能需要重新发出已经发出过的调用。诸如 Activity 和 Fragment 之类的界面控制器主要用于显示界面数据、对用户操作做出响应或处理操作系统通信（如权限请求）。如果要求界面控制器也负责从数据库或网络加载数据，那么会使类越发膨胀。为界面控制器分配过多的责任可能会导致单个类尝试自己处理应用的所有工作，而不是将工作委托给其他类。以这种方式为界面控制器分配过多的责任也会大大增加测试的难度。从界面控制器逻辑中分离出视图数据所有权的做法更易行且更高效。—这个其实就是presenter还有一点可以通过ViewModel，Fragment和Activity、Fragment和Fragment之间共享数据和监听，省去了一大半烦恼。、大概的介绍和使用可以看看官方的文档我们从源代码的角度来分析分析：
就拿一个ViewModelProviders.of(this).get(UserModel.class)
ViewModel
 它是一个很简单的抽象类，所以我们需要使用它，在onCleared中我们可以做一些清理操作，如网络请求，耗时任务什么的。当界面不需要它的时候会调用它。
ViewModelProviders
  </description>
    </item>
    
    <item>
      <title>Android在子线程中更新UI</title>
      <link>https://helixs.github.io/posts/2020-04-20-/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2020-04-20-/</guid>
      <description></description>
    </item>
    
    <item>
      <title>android截图之应用内</title>
      <link>https://helixs.github.io/posts/2019-02-25-/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2019-02-25-/</guid>
      <description> </description>
    </item>
    
    <item>
      <title>Android源码一步一步分析系列之OkIO</title>
      <link>https://helixs.github.io/posts/2020-04-16-/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2020-04-16-/</guid>
      <description></description>
    </item>
    
    <item>
      <title>匹配算法之KMP及Next数组</title>
      <link>https://helixs.github.io/posts/2019-10-18-/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2019-10-18-/</guid>
      <description>KMP算法 Knuth-Morris-Pratt(克努斯-莫里斯-普拉特)字符串查找算法。
可在一个主文本字符串S内查找一个词W的出现位置。此算法通过运用对这个词在不匹配时本身就包含足够的信息来确定下一个匹配将在哪里开始的发现，从而避免重新检查先前匹配的字符。这个算法是由高德纳和沃恩·普拉特在1974年构思，同年詹姆斯·H·莫里斯也独立地设计出该算法，最终由三人于1977年联合发表。
朴素模式匹配算法 了解KMP之前我们先来想想用最简单的方式匹配字符串
有很长一段字符串S，我们想要从S中匹配字符串P，得到匹配到P后分别在S(p)出的position的位置，也可以是指针位置。
我们用最简单的朴素模式匹配算法来匹配(该算法也称布鲁特-福斯算法，其基本思想是从主串S的第一个字符起与模式串P的第一个字符比较，若相等，则继续逐一对字符进行后续的比较，否则从主串S第二个字符起与模式串P的第一个字符重新比较，知道模式串中每个字符依次和主串中第一个连续的字符序列相等时位置，此时成为匹配成功)
1、
     首先，字符串”BBC ABCDAB ABCDABCDABDE”的第一个字符与搜索词”ABCDABD”的第一个字符，进行比较。因为B与A不匹配，所以搜索词后移一位。
2、
    因为B与A不匹配，搜索词再往后移。
3、
    就这样，直到字符串有一个字符，与搜索词的第一个字符相同为止。
4、
     接着比较字符串和搜索词的下一个字符，还是相同。
5、
    直到字符串有一个字符，与搜索词对应的字符不相同为止。
6、
     这时，最自然的反应是，将搜索词整个后移一位，再从头逐个比较。这样做虽然可行，但是效率很差，因为你要把”搜索位置”移到已经比较过的位置，重比一遍。
 这种方法最然最易看懂，不过时间复杂度那是相当的高呀。
使用KMP算法 先看代码
 </description>
    </item>
    
    <item>
      <title>最优二叉树-哈</title>
      <link>https://helixs.github.io/posts/2020-03-19-/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2020-03-19-/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>
