<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>数据结构和算法 on 西门吹风</title>
    <link>https://helixs.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/</link>
    <description>Recent content in 数据结构和算法 on 西门吹风</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 30 Mar 2021 12:32:42 +0000</lastBuildDate><atom:link href="https://helixs.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>LinkedHashMap图解</title>
      <link>https://helixs.github.io/posts/2021-03-30-linkedhashmap%E5%9B%BE%E8%A7%A3/</link>
      <pubDate>Tue, 30 Mar 2021 12:32:42 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2021-03-30-linkedhashmap%E5%9B%BE%E8%A7%A3/</guid>
      <description>跟hashMap的区别就是所有node节点增加了after和before属性 形成了双向链表，通过牺牲空间来保证有序性。</description>
    </item>
    
    <item>
      <title>LeetCode之在数组中计算某个两个数和等于目标值</title>
      <link>https://helixs.github.io/posts/2021-03-26-leetcode%E4%B9%8B%E5%9C%A8%E6%95%B0%E7%BB%84%E4%B8%AD%E8%AE%A1%E7%AE%97%E6%9F%90%E4%B8%AA%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%92%8C%E7%AD%89%E4%BA%8E%E7%9B%AE%E6%A0%87%E5%80%BC/</link>
      <pubDate>Fri, 26 Mar 2021 06:33:01 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2021-03-26-leetcode%E4%B9%8B%E5%9C%A8%E6%95%B0%E7%BB%84%E4%B8%AD%E8%AE%A1%E7%AE%97%E6%9F%90%E4%B8%AA%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%92%8C%E7%AD%89%E4%BA%8E%E7%9B%AE%E6%A0%87%E5%80%BC/</guid>
      <description>链接：https://leetcode-cn.com/problems/two-sum
我的第一想法 双循环
再看看大神
 看到没，循环只有一次，通过每次预推断补数，就直接下个循环判断有没有就行了。</description>
    </item>
    
    <item>
      <title>树和二叉树基本特性(2)</title>
      <link>https://helixs.github.io/posts/2020-03-16-%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A72/</link>
      <pubDate>Mon, 16 Mar 2020 09:19:37 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2020-03-16-%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A72/</guid>
      <description>查找二叉树（Binary Sort Tree 二叉排序树）的基本定义 1、若查找树的左子树非空，则其左子树上的各个节点值均小于根节点的值
2、若查找树的右子树非空，则其右子树上的各个节点值均大于根节点的值
3、查找树的左右子树各是一棵查找树。
查找 查找就是比较大小 没啥好说的
插入 1、如果相同键值的节点已在查找二叉树中，则不插入
2、如果查找二叉树为空树，则以新节点为查找二叉树
3、将要插入的节点与即将插入的父节点作比较，确定左右子节点插入
删除 1、如果要删除的节点是叶子节点就直接删除
2、如果删除的节点只有一个子节点，那么就直接连接子节点，然后删除
3、若要删除的节点P有两个子节点，则在其左子树上，用中序遍历需找最大的节点S，用节点S的值代替节点P的值，然后删除节点S，节点S必属于上述1,2情况之1(
 找出左子树中最大或者右子树中最小的值val 将当前节点的值替换为val 在左子树或者右子树中找到val删除  )</description>
    </item>
    
    <item>
      <title>树和二叉树基本特性(1)</title>
      <link>https://helixs.github.io/posts/2020-03-16-%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A71/</link>
      <pubDate>Mon, 16 Mar 2020 03:21:03 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2020-03-16-%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A71/</guid>
      <description>树的基本概念就不介绍了，直接上干活
概念：  1、树的总结点数为n，总度数为k，那么n=k+1
因为度数就相当于子节点的个数，根节点就是那个+1
节点的度：一个节点有几个子节点就是有几度。树的读：所有节点中，有几个节点有分叉，就相当于树的度。例题.在一棵度为3的树中，有2个度为3的节点，1个度为2的节点，则有_x_个度为0的节点。求x。_
解：树的度为3，就相当于3个有分叉的节点，其他都是叶子节点，因为n=k+1。
得到n=3*2+2*1+0*x =&amp;gt;n=9
9-2-1=6 x = 6
2、二叉树的重要特性
1、在二叉树的第i层上，最多有2^(i-1)个节点（i≥1）；
2、深度为k的二叉树最多有(2^k)-1个节点(i≥1)；
3、对任何一颗二叉树，如果其叶子结点数为N0，度为2的节点数为N2，则N0=N2+1；
4、具有n个结点的完全二叉树的深度为floor(log2n) + 1
5、如果对一棵有n个结点的完全二叉树（其深度为floor(log2n) + 1 ）的结点按层序编号，则对任一结点i（1≤i≤n）有：
（1） 如果i = 1，则结点i是二叉树的根，无双亲；如果i &amp;gt; 1，则其双亲PARENT(i)是结点 floor((i)/2)
（2）如果2i &amp;gt; n，则结点i无左孩子；否则其左孩子LCHILD(i)是结点2i
（3）如果2i + 1 &amp;gt; n，则结点i无右孩子；否则其右孩子RCHILD(i)是结点2i + 1
floor向下取整 二叉树通常作为数据结构应用，典型用法是对节点定义一个标记函数，将一些值与每个节点相关系。这样标记的二叉树就可以实现二叉搜索树和二叉堆，并应用于高效率的搜索和排序。
例题：一个具有767个节点的完全二叉树，其叶子结点个数为_X_个。 求X
根据上面第三点 对任何一颗二叉树，如果其叶子结点数为N0，度为2的节点数为N2，则N0=N2+1；
N = N0 + (N2 +1)=2N2+1
767 = 2N2+1
N2 = 383
X = N2+1 = 383+1 = 384
二叉树的遍历             前序1，2，4，5，7，8，3，6</description>
    </item>
    
    <item>
      <title>冒泡排序的概念和优化</title>
      <link>https://helixs.github.io/posts/2019-09-02-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E4%BC%98%E5%8C%96/</link>
      <pubDate>Mon, 02 Sep 2019 09:33:36 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2019-09-02-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E4%BC%98%E5%8C%96/</guid>
      <description>冒泡排序为什么叫冒泡排序 -_- 我们都是宅农，应该都用锅烧过开水，或用来做饭或用来烧汤，不过我在小时候还烧过猪食。等水温达到一定程度，水就开始出了一点泡泡。
气泡有两个来源：
1、在水沸腾之前出现的气泡，主要是水中溶解的气体（氮气、氧气等），随着温度升高，它们在水中的溶解度下降，于是析出了气泡
2、等水沸腾之后大部分气泡就是沸腾产生的水蒸汽了气泡越来越大。
上浮的过程中气泡会变大主要原因是：pV=nRT，于是气体的体积和压强成反比。水面以下越深，压强就越大，所以上浮的过程是压强减小的过程，也就是体积增大的过程。
冒泡排序就是差不多这样解释啦。不过这里面还差了一个循环的意思。
最简单的实现方式 在要排序的一组数中，对当前还未排好序的范围内的全部数，自上而下对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。即：每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。
这个就是最简单冒泡排序实现办法。时间复杂度=O（n^2）也就是n*n。
优化 如果对于一个本身有序的序列，或则序列后面一大部分都是有序的序列，上面的算法就会浪费很多的时间开销，这里设置一个标志flag，如果这一趟发生了交换，则为true，否则为false。明显如果有一趟没有发生交换，说明排序已经完成。最好时间复杂度O(n) 最坏O(n^2)
进一步优化 比如，现在有一个包含1000个数的数组，仅前面100个无序，后面900个都已排好序且都大于前面100个数字，那么在第一趟遍历后，最后发生交换的位置必定小于100，且这个位置之后的数据必定已经有序了，也就是这个位置以后的数据不需要再排序了，于是记录下这位置，第二次只要从数组头部遍历到这个位置就可以了。如果是对于上面的冒泡排序算法2来说，虽然也只排序100次，但是前面的100次排序每次都要对后面的900个数据进行比较，而对于现在的排序算法3，只需要有一次比较后面的900个数据，之后就会设置尾边界，保证后面的900个数据不再被排序。
那么第三种其实就是最优解啦。</description>
    </item>
    
  </channel>
</rss>
