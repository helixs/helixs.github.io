<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>源码分析 on 西门吹风</title>
    <link>https://helixs.github.io/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</link>
    <description>Recent content in 源码分析 on 西门吹风</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sun, 26 Apr 2020 05:36:46 +0000</lastBuildDate><atom:link href="https://helixs.github.io/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Android源码一步一步分析系列之Retrofit</title>
      <link>https://helixs.github.io/posts/2020-04-26-android%E6%BA%90%E7%A0%81%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8Bretrofit/</link>
      <pubDate>Sun, 26 Apr 2020 05:36:46 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2020-04-26-android%E6%BA%90%E7%A0%81%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8Bretrofit/</guid>
      <description>Retrofit是原Square大神JakeWharton面向Android和Java平台的http客户端。
那么我们常用的Retrofit+Okhttp的关系是什么呢？其实Retrofit需要依赖Okhttp，就如同Okhttp依赖OkIO一样，Retrofit当使用Http请求时候方面了我们的结构化配置。
Okhttp：
Android为我们提供了两种HTTP交互的方式：HttpURLConnection和Apache HTTP Client（ Android 6.0——API 23已经不支持该方式了 ），虽然两者都支持HTTPS，流的上传和下载，配置超时IPv6和连接池，已足够满足我们各种HTTP请求的需求。但更高效的使用HTTP可以让我们的应用运行更快、更节省流量。这就诞生了Okhttp及Retrofit等HTTP库。OKHttp是一款高效的HTTP库，支持连接同一地址的链接共享同一个socket，通过连接池来减小响应延迟，还有透明的GZIP压缩，请求缓存等优势。OkHttp存在以下的特点：
 支持HTTP2/SPDY socket自动选择最好路线，并支持自动重连 拥有自动维护的socket连接池，减少握手次数 拥有队列线程池，轻松写并发 拥有Interceptors轻松处理请求与响应（比如透明GZIP压缩,LOGGING） 基于Headers的缓存策略  Retrofit:retrofit就是对okhttp做了一层封装。把网络请求都交给给了Okhttp，我们只需要通过简单的配置就能使用retrofit来进行网络请求了。Retrofit框架存在的优势：
 Retrofit使用注解方式，大大简化了我们的URL拼写形式，而且注解含义一目了然，简单易懂； Retrofit使用简单，结构层次分明，每一步都能清晰的表达出之所以要使用的寓意； Retrofit支持同步和异步执行，使得请求变得异常简单，只要调用enqueue/execute即可完成； Retrofit更大自由度的支持我们自定义的业务逻辑，如自定义Converters。 Retrofit支持多种文件解析(Gson,Json,XML,Protobuf) Retrofit支持RxJava  我们来看如何使用
基于com.squareup.retrofit2:retrofit:2.8.1.
看到没，是不是很方便呢，我们只需配置一个baseUrl，放置一个接口配置清单，我们就可以进行简单的网络请求了。
分析源码
下面这张图是Retrofit常用依赖包
    adapter和converter根据自己实际情况进行调整
看看retrofit的东西，哟，不是很多，说明我们看它更加容易
                http下面都是一堆注解，什么http方法 HEAD QUERY 等等非常丰富，retrofit运行过程中会反射获取这些类型再进行合理的封装。
看看Retrofit中的成员变量
Retrofit的Builder模式初始化
在1和2中我们看到了使用平台
Platform里面的东西其实不多，就是Callback的执行器和一些跟JAVA8特性相关，跟Retrofit核心关系不是很大。
createSerivce
这里面用到了动态代理模式，可以学习一下。
下面我们就来看看ServiceMethod是怎么获取的
1、RequestFactory
2、HttpServiceMethod
我们生成了RequestFactory后就马上调用了 HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory);</description>
    </item>
    
    <item>
      <title>Android源码一步一步分析系列之OkHttp(6)——CallServerInterceptor</title>
      <link>https://helixs.github.io/posts/2020-04-10-android%E6%BA%90%E7%A0%81%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8Bokhttp6-callserverinterceptor/</link>
      <pubDate>Fri, 10 Apr 2020 10:02:31 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2020-04-10-android%E6%BA%90%E7%A0%81%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8Bokhttp6-callserverinterceptor/</guid>
      <description>终于来到了最后一个拦截器，主要是通过上一个拦截器建立起来的连接通道通过交换机进行数据 包装发送 和 接受解包。
 写入请求 Header 如果请求头的 Expect: 100-continue 时，只发送请求头 根据返回的结果判断是否继续请求流程 写入请求体，完成请求 得到响应头，构建初步响应 构建响应体，完成最终响应 返回响应  下一篇就开始看看Sink和RequestBody及ResponseBody</description>
    </item>
    
    <item>
      <title>Android源码一步一步分析系列之OkHttp(5)——ConnectInterceptor</title>
      <link>https://helixs.github.io/posts/2020-04-10-android%E6%BA%90%E7%A0%81%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8Bokhttp5-connectinterceptor/</link>
      <pubDate>Fri, 10 Apr 2020 06:17:06 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2020-04-10-android%E6%BA%90%E7%A0%81%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8Bokhttp5-connectinterceptor/</guid>
      <description>ConnectInterceptor拦截器里面的东西不多，主要是调用了连接池里面的东西。
为什么需要这个拦截器，当我们每次发送一次Http请求的时候，如果每次都进行TCP3次握手，耗费的时间和精力是很多的。
在Http1.1中通过增加了head字段Connection和Keep-Alive来告诉服务器保持一个常在连接通道，那么后面很多的request请求在这个时间范围内都可以用这个连接进行发送。
这个拦截器就是来干这个事的。
我们下面来看看
进入newExchange
进入find
进入findHealthyConnection
进入findConnection
进入RealConnectionPool.transmitterAcquirePooledConnection
进入RealConnectionPool.isEligible
isEligible返回后进入 Transmitter.acquireConnectionNoEvents(connection);
告一段落
 在findConnection方法后面，会有一个put方法把创建新的连接加入到连接池connectionPool中，进入put方法
 连接池的代码较多，主要就是复用连接，创建连接，保存连接，移除连接的操作。
 </description>
    </item>
    
    <item>
      <title>Android源码一步一步分析系列之OkHttp(4)——CacheInterceptor</title>
      <link>https://helixs.github.io/posts/2020-04-09-android%E6%BA%90%E7%A0%81%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8Bokhttp3-cacheinterceptor/</link>
      <pubDate>Thu, 09 Apr 2020 05:16:19 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2020-04-09-android%E6%BA%90%E7%A0%81%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8Bokhttp3-cacheinterceptor/</guid>
      <description>CacheInterceptor主要是处理缓存的拦截器，其实他不是自己的一些什么缓存机制。基本上还是根据http的缓存协议基础上，进行缓存本地化的改造操作。
我们要了解缓存就必须理解Http缓存协议—彻底弄懂HTTP缓存机制及原理如果大家对缓存协议不清楚，最好看一下上面的内容，Okhttp缓存就是根据它的协议进行开发的，没有太大的改造。
CacheInterceptor流程
&amp;lt;pre class=&amp;quot;EnlighterJSRAW&amp;quot; data-enlighter-language=&amp;quot;java&amp;quot; data-enlighter-theme=&amp;quot;atomic&amp;quot;&amp;gt;/*  Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the &amp;ldquo;License&amp;rdquo;); you may not use this file except in compliance with the License. You may obtain a copy of the License at *  http://www.</description>
    </item>
    
    <item>
      <title>Android源码一步一步分析系列之OkHttp(3)——BridgeInterceptor</title>
      <link>https://helixs.github.io/posts/2020-04-07-android%E6%BA%90%E7%A0%81%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8Bokhttp3-bridgeinterceptor/</link>
      <pubDate>Tue, 07 Apr 2020 10:09:27 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2020-04-07-android%E6%BA%90%E7%A0%81%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8Bokhttp3-bridgeinterceptor/</guid>
      <description>了解更多请看
Android源码一步一步分析系列之OkHttp(1)——揭开面纱Android源码一步一步分析系列之OkHttp(2)——RetryAndFollowUpInterceptor BridgeInterceptor这个拦截器类容比较简单 主要是包装head和处理压缩数据的
 </description>
    </item>
    
    <item>
      <title>Android源码一步一步分析系列之OkHttp(2)——RetryAndFollowUpInterceptor</title>
      <link>https://helixs.github.io/posts/2020-04-07-android%E6%BA%90%E7%A0%81%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8Bokhttp2-retryandfollowupinterceptor/</link>
      <pubDate>Tue, 07 Apr 2020 05:38:46 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2020-04-07-android%E6%BA%90%E7%A0%81%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8Bokhttp2-retryandfollowupinterceptor/</guid>
      <description>可以看一下上一篇文章
Android源码一步一步分析系列之OkHttp(1)——揭开面纱   RetryAndFollowUpInterceptor拦截器是满足一定条件下用来处理失败重试和重定向的一些操作。
 </description>
    </item>
    
    <item>
      <title>Android源码一步一步分析系列之OkHttp(1)——揭开面纱</title>
      <link>https://helixs.github.io/posts/2020-04-02-android%E6%BA%90%E7%A0%81%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8Bokhttp1-%E6%8F%AD%E5%BC%80%E9%9D%A2%E7%BA%B1/</link>
      <pubDate>Thu, 02 Apr 2020 10:53:46 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2020-04-02-android%E6%BA%90%E7%A0%81%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8Bokhttp1-%E6%8F%AD%E5%BC%80%E9%9D%A2%E7%BA%B1/</guid>
      <description>说来很惭愧，做了这么多年Android没有仔仔细细的看过Okhttp源代码，空余时间都在学习些周边的技术。现在按照新手方式看一步写一步。
OkHttp就是一种HTTP客户端连接，它有如下特性：
 HTTP/2多路复用Socket到同一个主机，共享链接。 采用连接池技术，可以有效的减少Http链接数量。 无缝集成GZIP压缩技术。 支持Response Cache，避免重复请求。 域名多IP支持。  OkHttp会自动管理HTTP连接的生命周期：
 操作Response.body().string()等类型的API，OkHttp会自动将该HTTP连接加入到ConnectionPool中或者直接释放连接 如果采用stream方式操作流，则需要自己手动关闭，否则会发生HTTP连接泄漏（OkHttp通过WeakReference机制，尽最大努力管理这些泄漏的HTTP连接） OkHttp不读取Resonse#Head#Keep-Alive属性来决定该HTTP连接是否能复用，而是直接加入到ConnectionPool进行复用 当从ConnectionPool中获取HTTP连接的时候，OkHttp发现该HTTP连接已经失效，则关闭该连接，并且重新选择一个HTTP连接进行复用  GET 请求 基于3.14版本，最新的4.x版本全部都使用了kotlin编写。实在话，kotlin是门好语言，不过看代码还是java比较舒服
OkHttpClient
开启一个同步请求 开启一个异步请求  </description>
    </item>
    
  </channel>
</rss>
