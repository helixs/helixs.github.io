<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>编程生活 on 西门吹风</title>
    <link>https://helixs.github.io/categories/%E7%BC%96%E7%A8%8B%E7%94%9F%E6%B4%BB/</link>
    <description>Recent content in 编程生活 on 西门吹风</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 27 Apr 2021 02:12:57 +0000</lastBuildDate><atom:link href="https://helixs.github.io/categories/%E7%BC%96%E7%A8%8B%E7%94%9F%E6%B4%BB/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Flutter Web使用的一些心得和一些问题</title>
      <link>https://helixs.github.io/posts/2021-04-27-flutter-web%E4%BD%BF%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BF%83%E5%BE%97%E5%92%8C%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</link>
      <pubDate>Tue, 27 Apr 2021 02:12:57 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2021-04-27-flutter-web%E4%BD%BF%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BF%83%E5%BE%97%E5%92%8C%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</guid>
      <description>公司这段时间新建了一个网站项目，因为是新项目，选择技术栈来说是比较值得探讨的问题，因为前端缺人，本身我们组又是移动应用开发为主，虽然前端也会，毕竟不是一直从事前端开发，不能那么快速将项目上线。刚好前不久Flutter2.0发布了，FlutterWeb也开启了正式之路，然后我就跟同事们说要不就用这玩意儿吧，来吃肉(填坑？)。然后大家就欣然同意。
FlutterWeb实现原理基本上和移动应用一个道理，默认情况下都是使用的调用Canvaskit+skia引擎调用WebGL实现绘制。也可以使用html+css+canvas进行渲染，这样少了Skia引擎，会让包大小少2mb左右，不过展示的样式可能就是根据浏览器默认渲染的方式进行了，差别还是蛮大的。
1、使用默认Canvaskit渲染方式，会在打开应用之初加载字体1秒钟内，出现中文字体乱码问题！！！关于这个问题，我们暂时智能使用html的方式进行官方目前还没有什么有效的解决方式，问题在这里https://github.com/flutter/flutter/issues/73628 出现问题的主要原因是，自绘引擎需要字体库支持，FlutterWeb 默认会使用Noto字体，因为一般电脑上都不会带有这个字体，所以会在线寻找这个字体，比如google或者一些第三方字体库网站，导致加载缓慢和乱码。当然还有办法可以解决这个问题，就是将字体放到本地资源库，比如将Noto字体作为默认字体一起打包到web网站上，下载速度就快了很多,你也可以换一些自己的中文字体(注意版权问题)，不会出现乱码情况。坏处就是还是会增加一些服务器的负担。
 2、应用体积过大，我们大概做了十几个页面吧，打包下来最后会生成main.dart.js文件，搞下来已经7mb了，而且没办法拆分，意思就是你打开这个网站就等于加载了几乎整个应用渲染逻辑！更意味着打开网站下载js，执行js，渲染js 是你不得不面对的三道速度墙！记得如果你真的要用它，放到生产环境时候要给nginx或者其他方式实现brotli或者gzip压缩来减少传输时间！当然官方现在也没有很好的解决办法来如何拆分它！https://github.com/flutter/flutter/issues/46589 3、因为FlutterWeb是自绘引擎，默认是不支持文字选中和复制了，如果你需要文字选中和复制需要使用SelectableText ，从体验上来讲，还是有那么不太舒服哦，跟原生Web标准还是差很多。如果你的网页需要允许用户进行大量的复制操作，请谨慎尝试。
4、如果你的网页需要提高标签值被爬的难度，那么它可能是比较好的一个办法，一堆js等着你去解析吧。
问题待续….
根据上面的信息，我大概确定的是它目前定位基本上和nativeApp一个级别的WebApp，也可以直接生成webApp应用给浏览器保留，所以他不合适用来做很多传统的WebPage应用了。</description>
    </item>
    
    <item>
      <title>Mariadb安装设置root密码</title>
      <link>https://helixs.github.io/posts/2021-04-02-mariadb%E5%AE%89%E8%A3%85%E8%AE%BE%E7%BD%AEroot%E5%AF%86%E7%A0%81/</link>
      <pubDate>Fri, 02 Apr 2021 07:02:08 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2021-04-02-mariadb%E5%AE%89%E8%A3%85%E8%AE%BE%E7%BD%AEroot%E5%AF%86%E7%A0%81/</guid>
      <description>启动远程连接
红色部分是用户名和远程登录的密码，和本地密码不同。
 </description>
    </item>
    
    <item>
      <title>LeetCode之在数组中计算某个两个数和等于目标值</title>
      <link>https://helixs.github.io/posts/2021-03-26-leetcode%E4%B9%8B%E5%9C%A8%E6%95%B0%E7%BB%84%E4%B8%AD%E8%AE%A1%E7%AE%97%E6%9F%90%E4%B8%AA%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%92%8C%E7%AD%89%E4%BA%8E%E7%9B%AE%E6%A0%87%E5%80%BC/</link>
      <pubDate>Fri, 26 Mar 2021 06:33:01 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2021-03-26-leetcode%E4%B9%8B%E5%9C%A8%E6%95%B0%E7%BB%84%E4%B8%AD%E8%AE%A1%E7%AE%97%E6%9F%90%E4%B8%AA%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%92%8C%E7%AD%89%E4%BA%8E%E7%9B%AE%E6%A0%87%E5%80%BC/</guid>
      <description>链接：https://leetcode-cn.com/problems/two-sum
我的第一想法 双循环
再看看大神
 看到没，循环只有一次，通过每次预推断补数，就直接下个循环判断有没有就行了。</description>
    </item>
    
    <item>
      <title>AndroidStudio通过Gradle查看第三方依赖关系</title>
      <link>https://helixs.github.io/posts/2021-02-19-androidstudio%E9%80%9A%E8%BF%87gradle%E6%9F%A5%E7%9C%8B%E7%AC%AC%E4%B8%89%E6%96%B9%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB/</link>
      <pubDate>Fri, 19 Feb 2021 07:27:02 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2021-02-19-androidstudio%E9%80%9A%E8%BF%87gradle%E6%9F%A5%E7%9C%8B%E7%AC%AC%E4%B8%89%E6%96%B9%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB/</guid>
      <description>进行Android开发我们经常遇到一些依赖冲突，以及库版本号不一致导致出现各种问题。往往就下面这张图只是看到了你所有的依赖项，并不知道这些依赖都是从哪里来的，除非你进去一个个查看pow.xml那么蠢了。
                       看了半天也不知道是从哪里依赖的。
有个简单的方法，打开gradle工具，找到项目下如app模块-&amp;gt;Tasks-&amp;gt;help-&amp;gt;dependencies-&amp;gt;双击                         那么他会执行 :app:dependencies命令,会打印出依赖项及子依赖项
                      往上说的那些什么插件的都是老方法了，新版的studio没办法直观反映</description>
    </item>
    
    <item>
      <title>Android源码一步一步分析系列之Retrofit</title>
      <link>https://helixs.github.io/posts/2020-04-26-android%E6%BA%90%E7%A0%81%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8Bretrofit/</link>
      <pubDate>Sun, 26 Apr 2020 05:36:46 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2020-04-26-android%E6%BA%90%E7%A0%81%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8Bretrofit/</guid>
      <description>Retrofit是原Square大神JakeWharton面向Android和Java平台的http客户端。
那么我们常用的Retrofit+Okhttp的关系是什么呢？其实Retrofit需要依赖Okhttp，就如同Okhttp依赖OkIO一样，Retrofit当使用Http请求时候方面了我们的结构化配置。
Okhttp：
Android为我们提供了两种HTTP交互的方式：HttpURLConnection和Apache HTTP Client（ Android 6.0——API 23已经不支持该方式了 ），虽然两者都支持HTTPS，流的上传和下载，配置超时IPv6和连接池，已足够满足我们各种HTTP请求的需求。但更高效的使用HTTP可以让我们的应用运行更快、更节省流量。这就诞生了Okhttp及Retrofit等HTTP库。OKHttp是一款高效的HTTP库，支持连接同一地址的链接共享同一个socket，通过连接池来减小响应延迟，还有透明的GZIP压缩，请求缓存等优势。OkHttp存在以下的特点：
 支持HTTP2/SPDY socket自动选择最好路线，并支持自动重连 拥有自动维护的socket连接池，减少握手次数 拥有队列线程池，轻松写并发 拥有Interceptors轻松处理请求与响应（比如透明GZIP压缩,LOGGING） 基于Headers的缓存策略  Retrofit:retrofit就是对okhttp做了一层封装。把网络请求都交给给了Okhttp，我们只需要通过简单的配置就能使用retrofit来进行网络请求了。Retrofit框架存在的优势：
 Retrofit使用注解方式，大大简化了我们的URL拼写形式，而且注解含义一目了然，简单易懂； Retrofit使用简单，结构层次分明，每一步都能清晰的表达出之所以要使用的寓意； Retrofit支持同步和异步执行，使得请求变得异常简单，只要调用enqueue/execute即可完成； Retrofit更大自由度的支持我们自定义的业务逻辑，如自定义Converters。 Retrofit支持多种文件解析(Gson,Json,XML,Protobuf) Retrofit支持RxJava  我们来看如何使用
基于com.squareup.retrofit2:retrofit:2.8.1.
看到没，是不是很方便呢，我们只需配置一个baseUrl，放置一个接口配置清单，我们就可以进行简单的网络请求了。
分析源码
下面这张图是Retrofit常用依赖包
    adapter和converter根据自己实际情况进行调整
看看retrofit的东西，哟，不是很多，说明我们看它更加容易
                http下面都是一堆注解，什么http方法 HEAD QUERY 等等非常丰富，retrofit运行过程中会反射获取这些类型再进行合理的封装。
看看Retrofit中的成员变量
Retrofit的Builder模式初始化
在1和2中我们看到了使用平台
Platform里面的东西其实不多，就是Callback的执行器和一些跟JAVA8特性相关，跟Retrofit核心关系不是很大。
createSerivce
这里面用到了动态代理模式，可以学习一下。
下面我们就来看看ServiceMethod是怎么获取的
1、RequestFactory
2、HttpServiceMethod
我们生成了RequestFactory后就马上调用了 HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory);</description>
    </item>
    
    <item>
      <title>Android MaterialButton的一些问题</title>
      <link>https://helixs.github.io/posts/2019-11-28-android-materialbutton%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</link>
      <pubDate>Thu, 28 Nov 2019 03:34:18 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2019-11-28-android-materialbutton%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</guid>
      <description>MaterialButton和MaterialCardView的都新增了边框属性，我们没必要为了一个边框写那么多shape，一旦多了谁着得住。
1、在使用MaterialButton注意一点是它必须设置android:textAppearance属性，不然会崩溃 This component requires that you specify a valid TextAppearance attribute. Update your app theme to inherit from Theme.MaterialComponents (or a descendant)它会检查textApearance属性，解决方式有两种如下:
1、添加它就好
2、application或activity或控件的theme继承自Theme.MaterialComponents.xxxx,使type能够找到这个属性，如
其实想了想，也许以后MaterialComponents的text相关组件都会进行这种操作吧。
2、在使用MaterialButton时候可能遇到背景颜色不能充满控件的问题。 如果按照以前默认的方式添加背景颜色，我们发现背景颜色不能充满上下编剧，我们对比使用appcompatButton
      1、从上面的图片可以看出它们的背景颜色不一样。MaterialButton是不受android:background控制的，官方建议我们设置app:backgroundHint来进行背景的更改。
2、AppCompatButton如果设置了android:background会覆盖上下左右的间距，MaterialButton则不会
3、MaterialButton设置了app:backgroundHint左右是没有间距的，而上下有。AppCompatButton设置了app:backgroundHint是上下左右都有间距
找到原因https://github.com/material-components/material-components-android/blob/master/docs/components/MaterialButton.md#attributes Note: MaterialButton is visually different from Button and AppCompatButton. One of the main differences is that AppCompatButton has a 4dp inset on the left and right sides, whereas MaterialButton does not. To add an inset to match AppCompatButton, set android:insetLeft and android:insetRight on the button to 4dp, or change the spacing on the button’s parent layout.</description>
    </item>
    
    <item>
      <title>Java GC简单认识</title>
      <link>https://helixs.github.io/posts/2019-07-30-java-gc%E7%AE%80%E5%8D%95%E8%AE%A4%E8%AF%86/</link>
      <pubDate>Tue, 30 Jul 2019 04:00:27 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2019-07-30-java-gc%E7%AE%80%E5%8D%95%E8%AE%A4%E8%AF%86/</guid>
      <description>前几日，我去外面试了试面试。找找新工作看看有没有合适的。前面基本上很顺利，没有什么特别的难度和问题，本以为可以满怀信心的入职，结果被泼了一盆冷水。被问到关于GC机制的问题，GC算法有哪些，规则如何等等，我懵逼了，我只知道GC是垃圾回收，在内存不够的时候会触发它，然后回收没有引用的内存。然后它是如何实现的可真没有仔细研究过。书到用时方恨少，事非经过不知难。
在很多年前我们在运行android程序的时候，时不时的会卡顿，我当时不以为然。排除线程和代码相关的情况下多半都与触发了GC有关西。了解才知道，在触发GC线程的时候，其它线程会进行等待，包括UI线程，UI线程卡顿了，那么我们肯定就会卡了。
可以看看jvm运行时内存分配哪些对象会被回收？ 对于寄存器、栈和本地方法区，他们都是跟随着当前线程走的，线程走完也就消亡了，所以不许要GC去触碰它。
而GC的主要对象是Java堆，这个地方跟线程的生命周期没有直接关联，就算你方法走完，new的对象也不会马上消失，直到GC的时候才有可能回收它。次要对象就是方法区的常量或者类等，毕竟这个一般也不会大到哪里去。
对象存活的依据 1、引用计数法  原理：给对象添加一个引用计数器，每当有地方引用时计数器加 1，引用失效时减 1。当该对象引用为 0 时，判定对象失效 优点：实现简单，判定效率高 缺点：很难解决对象之间循环引用的问题  如果 class A,classB都持有对方的引用那么就不可能回收了！。
 &amp;lt;ol&amp;gt; &amp;lt;li&amp;gt; 判断对象是否覆盖了 finalize() 方法 &amp;lt;/li&amp;gt; &amp;lt;/ol&amp;gt; &amp;lt;p&amp;gt; 如果覆盖了 finalize() 方法，那么将 finalize() 放到 F-Queue 队列中 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 如果未覆盖该方法，则直接回收 &amp;lt;/p&amp;gt; &amp;lt;ol start=&amp;quot;2&amp;quot;&amp;gt; &amp;lt;li&amp;gt; 执行 F-Queue 队列中的 finalize() 方法&amp;lt;br /&amp;gt; 由虚拟机自动建立一个优先级较低的线程去执行 F-Queue 中的 finalize() 方法，这里的执行只是触发这些方法并不保证会等待它执行完毕。如果 finalize() 方法作了耗时操作，虚拟机会停止执行并将该对象清除。 &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; 对象销毁或重生&amp;lt;br /&amp;gt; &amp;lt;strong&amp;gt;在 finalize() 方法中，将 this 赋值给某一个引用，那么该对象就重生了。如果没有引用，该对象会被回收&amp;lt;/strong&amp;gt;。 &amp;lt;/li&amp;gt; &amp;lt;/ol&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;h5&amp;gt; 方法区的内存回收 &amp;lt;/h5&amp;gt; &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt; 废弃的常量：&amp;lt;br /&amp;gt; 当前系统中没有任何对象引用常量池中的该常量，则是废弃常量 &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; 废弃的类判断规则：&amp;lt;br /&amp;gt; 该类所有实例都被回收；&amp;lt;br /&amp;gt; 加载该类的 ClassLoader 已经被回收；&amp;lt;br /&amp;gt; 该类对应的 Class 对象没有引用，也无法通过反射访问该类的方法。 &amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;h4&amp;gt; 算法 &amp;lt;/h4&amp;gt; &amp;lt;p&amp;gt; 最基础的收集算法是&amp;amp;#8221;标记 &amp;amp;#8211; 清除&amp;amp;#8221;算法，之所以说它是最基础的是因为它逻辑简单、使用简便，而且后续的收集算法大多基于这种算法的不足而优化的。 &amp;lt;/p&amp;gt; &amp;lt;h5&amp;gt; 1.</description>
    </item>
    
    <item>
      <title>jvm运行时内存分配</title>
      <link>https://helixs.github.io/posts/2019-07-29-java-gc%E7%9A%84%E7%AE%80%E5%8D%95%E8%AE%A4%E8%AF%86/</link>
      <pubDate>Mon, 29 Jul 2019 10:03:17 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2019-07-29-java-gc%E7%9A%84%E7%AE%80%E5%8D%95%E8%AE%A4%E8%AF%86/</guid>
      <description>前几日，我去外面试了试面试。找找新工作看看有没有合适的。前面基本上很顺利，没有什么特别的难度和问题，本以为可以满怀信心的入职，结果被泼了一盆冷水。被问到关于GC机制的问题，GC算法有哪些，规则如何等等，我懵逼了，我只知道GC是垃圾回收，在内存不够的时候会触发它，然后回收没有引用的内存。然后它是如何实现的可真没有仔细研究过。书到用时方恨少，事非经过不知难。
在很多年前我们在运行android程序的时候，时不时的会卡顿，我当时不以为然。排除线程和代码相关的情况下多半都与触发了GC有关西。了解才知道，在触发GC线程的时候，其它线程会进行等待，包括UI线程，UI线程卡顿了，那么我们肯定就会卡了。
jvm运行时内存分配 1、栈 英文stack，运行于RAM之上。stack最主要的特征即是先进后出。栈内存上面有一个指针，和C语言的指针差不多，指针的加减直接影响栈内存的创建和释放。当载入一个新方法的时候，指针+，方法执行完毕，指针-。这是一种特别快、特别有效的数据保存方式，仅次于寄存器。创建程序时，Java编译器必须准确地知道堆栈内保存的所有数据的“长度”以及“存在时间”。这是由于它必须生成相应的代码，以便移动指针。
 每个线程包含一个栈区，栈中只保存基本数据类型的数据和自定义对象的引用(不是对象)，对象都存放在堆区中。 每个栈中的数据(原始类型和对象引用)都是私有的，其他栈不能访问。 栈分为3个部分：基本数据类型的变量区、执行环境上下文、操作指令区(存放操作指令)。  栈是存放线程调用方法时存储局部变量表，操作，方法出口等与方法执行相关的信息，Java栈所占内存的大小由Xss来调节，方法调用层次太多会撑爆这个区域即_StackOverflowError。_
ps:这让我想起了递归，如果递归层级过多，不进行尾递归优化那么方法一直在载入没有执行完毕，那么一记StackOverflowError送给你
程序计数器（ProgramCounter）寄存器 是cpu的一部分，离cpu最近，速度也最快。每个线程启动的时候，都会创建一个寄存器，保存正在执行jvm指令的地址和下一步指令的地址。寄存器的内容总是指向下一条将被执行指令的地址，这里的地址可以是一个本地指针，也可以是在方法区中相对应于该方法起始指令的偏移量。
ps:想想为什么需要保存啊，不是直接执行就行了么。NONONO，现在程序都是多线程运行的，cpu要同时执行多条命令呀！这句话说的也不对，多线程是个假象，就算是32核64线程也是假象，cpu短时间内会在不同线程之间切换运行指令，造成一种同时运行多任务的假象，不过假象很有效，足以骗过我们愚蠢的人类。所以任务切来切去不找个地方保存下一步需要执行的地方，我回过神来就会迷失方向了。
本地方法栈(也叫本地方法区) Nativemethodstack(本地方法栈)：保存native方法进入区域的地址。
方法区 method（方法区）又叫静态区，存放所有的①类（class），②静态变量（static变量），③静态方法，④常量和⑤成员方法。
1.又叫静态区，跟堆一样，被所有的线程共享。
2.方法区中存放的都是在整个程序中永远唯一的元素。这也是方法区被所有的线程共享的原因。
（顺便展开静态变量和常量的区别： 静态变量本质是变量，是整个类所有对象共享的一个变量，其值一旦改变对这个类的所有对象都有影响；常量一旦赋值后不能修改其引用，其中基本数据类型的常量不能修改其值。）
Java里面是没有静态变量这个概念的，不信你自己在某个成员方法里面定义一个static int i = 0；Java里只有静态成员变量。它属于类的属性。至于他放哪里？楼上说的是静态区。我不知道到底有没有这个翻译。但是深入JVM里是翻译为方法区的。虚拟机的体系结构：①Java栈，② 堆，③PC寄存器，④方法区，⑤本地方法栈，⑥运行常量池。而方法区保存的就是一个类的模板，堆是放类的实例（即对象）的。栈是一般来用来函数计算的。随便找本计算机底层的书都知道了。栈里的数据，函数执行完就不会存储了。这就是为什么局部变量每一次都是一样的。就算给他加一后，下次执行函数的时候还是原来的样子。
方法区的大小由-XX:PermSize和-XX:MaxPermSize来调节，类太多有可能撑爆永久代。静态变量或常量也有可能撑爆方法区。
 方法区的位置有三种情况：
java7之前，方法区位于永久代(PermGen)，永久代和堆相互隔离，永久代的大小在启动JVM时可以设置一个固定值，不可变； java7中，存储在永久代的部分数据就已经转移到Java Heap或者Native memory。但永久代仍存在于JDK 1.7中，并没有完全移除，譬如符号引用(Symbols)转移到了native memory；字符串常量池(interned strings)转移到了Java heap；类的静态变量(class statics)转移到了Java heap。 java8中，取消永久代，方法存放于元空间(Metaspace)，元空间仍然与堆不相连，但与堆共享物理内存，逻辑上可认为在堆中  Native memory：本地内存，也称为C-Heap，是供JVM自身进程使用的。当Java Heap空间不足时会触发GC，但Native memory空间不够却不会触发GC。
为什么移除永久代？
1、字符串存在永久代中，容易出现性能问题和内存溢出。
2、永久代大小不容易确定，PermSize指定太小容易造成永久代OOM
3、永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。
4、Oracle 可能会将HotSpot 与 JRockit 合二为一。
堆 类的对象放在heap（堆）中，所有的类对象都是通过new方法创建，创建后，在stack（栈）会创建类对象的引用（内存地址）。
一种常规用途的内存池（也在RAM（随机存取存储器 ）区域），其中保存了Java对象。和栈不同：“内存堆”或“堆”最吸引人的地方在于编译器不必知道要从堆里分配多少存储空间，也不必知道存储的数据要在堆里停留多长的时间。因此，用堆保存数据时会得到更大的灵活性。要求创建一个对象时，只需用new命令编辑相应的代码即可。执行这些代码时，会在堆里自动进行数据的保存。当然，为达到这种灵活性，必然会付出一定的代价：在堆里分配存储空间时会花掉更长的时间。
JVM将所有对象的实例（即用new创建的对象）（对应于对象的引用（引用就是内存地址））的内存都分配在堆上，堆所占内存的大小由-Xmx指令和-Xms指令来调节。
运行常量池 这儿的“静态”是指“位于固定位置”。程序运行期间，静态存储的数据将随时等候调用。可用static关键字指出一个对象的特定元素是静态的。但Java对象本身永远都不会置入静态存储空间。
这个区域属于方法区。该区域存放类和接口的常量，除此之外，它还存放成员变量和成员方法的所有引用。当一个成员变量或者成员方法被引用的时候，JVM就通过运行常量池中的这些引用来查找成员变量和成员方法在内存中的的实际地址。
举个例子 命令 java AppMain</description>
    </item>
    
  </channel>
</rss>
