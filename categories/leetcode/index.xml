<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>LeetCode on 西门吹风</title>
    <link>https://helixs.github.io/categories/leetcode/</link>
    <description>Recent content in LeetCode on 西门吹风</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 26 Mar 2021 06:33:01 +0000</lastBuildDate><atom:link href="https://helixs.github.io/categories/leetcode/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>LeetCode之在数组中计算某个两个数和等于目标值</title>
      <link>https://helixs.github.io/posts/2021-03-26-leetcode%E4%B9%8B%E5%9C%A8%E6%95%B0%E7%BB%84%E4%B8%AD%E8%AE%A1%E7%AE%97%E6%9F%90%E4%B8%AA%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%92%8C%E7%AD%89%E4%BA%8E%E7%9B%AE%E6%A0%87%E5%80%BC/</link>
      <pubDate>Fri, 26 Mar 2021 06:33:01 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2021-03-26-leetcode%E4%B9%8B%E5%9C%A8%E6%95%B0%E7%BB%84%E4%B8%AD%E8%AE%A1%E7%AE%97%E6%9F%90%E4%B8%AA%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%92%8C%E7%AD%89%E4%BA%8E%E7%9B%AE%E6%A0%87%E5%80%BC/</guid>
      <description>链接：https://leetcode-cn.com/problems/two-sum
我的第一想法 双循环
再看看大神
 看到没，循环只有一次，通过每次预推断补数，就直接下个循环判断有没有就行了。</description>
    </item>
    
    <item>
      <title>每日一篇leetcode之-矩阵旋转</title>
      <link>https://helixs.github.io/posts/2020-04-07-%E6%AF%8F%E6%97%A5%E4%B8%80%E7%AF%87leetcode%E4%B9%8B-%E7%9F%A9%E9%98%B5/</link>
      <pubDate>Tue, 07 Apr 2020 08:18:18 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2020-04-07-%E6%AF%8F%E6%97%A5%E4%B8%80%E7%AF%87leetcode%E4%B9%8B-%E7%9F%A9%E9%98%B5/</guid>
      <description>来源https://leetcode-cn.com/problems/rotate-matrix-lcci/ 解题思路 这里的N*N矩阵就会一个二维数组，并且行数=列数。操作旋转90度。我们发现一个很有意思的规律
转换后，现数据列数=总行数-原数据行数-1 ，现数据行数=原数据列数直接上代码吧
总的来说，注意一下深拷贝的问题，其实还是很简单啦。
 </description>
    </item>
    
    <item>
      <title>每日一篇leetcode之-按摩师</title>
      <link>https://helixs.github.io/posts/2020-03-24-%E6%AF%8F%E6%97%A5%E4%B8%80%E7%AF%87leetcode%E4%B9%8B-%E6%8C%89%E6%91%A9%E5%B8%88/</link>
      <pubDate>Tue, 24 Mar 2020 09:00:00 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2020-03-24-%E6%AF%8F%E6%97%A5%E4%B8%80%E7%AF%87leetcode%E4%B9%8B-%E6%8C%89%E6%91%A9%E5%B8%88/</guid>
      <description>一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。给定一个预约请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。
注意：本题相对原题稍作改动
 示例 1：
输入： [1,2,3,1]
输出： 4
解释： 选择 1 号预约和 3 号预约，总时长 = 1 + 3 = 4。
示例 2：
输入： [2,7,9,3,1]
输出： 12
解释： 选择 1 号预约、 3 号预约和 5 号预约，总时长 = 2 + 9 + 1 = 12。
示例 3：
输入： [2,1,4,5,3,1,1,3]
输出： 12
解释： 选择 1 号预约、 3 号预约、 5 号预约和 8 号预约，总时长 = 2 + 4 + 3 + 3 = 12。
来源：力扣（LeetCode）</description>
    </item>
    
    <item>
      <title>每日一篇leetcode之-买卖股票的最佳时机 II</title>
      <link>https://helixs.github.io/posts/2020-03-19-%E6%AF%8F%E6%97%A5%E4%B8%80%E7%AF%87leetcode%E4%B9%8B-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-ii/</link>
      <pubDate>Thu, 19 Mar 2020 10:34:57 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2020-03-19-%E6%AF%8F%E6%97%A5%E4%B8%80%E7%AF%87leetcode%E4%B9%8B-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-ii/</guid>
      <description>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。
设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。
**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
示例 1:
输入:
输出:
解释:
示例 2:
输入:
输出:
解释:
示例 3:
输入:
输出:
解释:
来自leetcode https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/ 分析：
1、[p1…..pn]为连续的交易日价格数组
2、必须买入在接下来的任意一天卖出，不可同时持有股票。
3、可以任意多次购买，但不能违背要求2
4、利润最大化
分析这张图
              可以看一下利润最大化只能是将所有的爬坡阶段加起来，中间下坡就是亏钱，所以不考虑。
 </description>
    </item>
    
    <item>
      <title>每日一篇leetcode之-最长回文串</title>
      <link>https://helixs.github.io/posts/2020-03-19-%E6%AF%8F%E6%97%A5%E4%B8%80%E7%AF%87leetcode%E4%B9%8B-2/</link>
      <pubDate>Thu, 19 Mar 2020 07:25:17 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2020-03-19-%E6%AF%8F%E6%97%A5%E4%B8%80%E7%AF%87leetcode%E4%B9%8B-2/</guid>
      <description>给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。
在构造过程中，请注意区分大小写。比如 &amp;quot;Aa&amp;quot; 不能当做一个回文字符串。
注意:
假设字符串的长度不会超过 1010。
示例 1:
题目来源 https://leetcode-cn.com/problems/longest-palindrome/ 开始解题，以来就直接想到了Hash表，表节点直接表示字符数量，要求是英文字母大小写，就是26*2=52个空间节点。上代码：
这个方法很像我前两天写的hash表拼接单词每日一篇leetcode之-拼写单词下面是官方的答案 感觉一般般
 </description>
    </item>
    
    <item>
      <title>每日一篇leetcode之-矩形重叠</title>
      <link>https://helixs.github.io/posts/2020-03-18-%E6%AF%8F%E6%97%A5%E4%B8%80%E7%AF%87leetcode%E4%B9%8B/</link>
      <pubDate>Wed, 18 Mar 2020 06:07:51 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2020-03-18-%E6%AF%8F%E6%97%A5%E4%B8%80%E7%AF%87leetcode%E4%B9%8B/</guid>
      <description>矩形以列表 [x1, y1, x2, y2] 的形式表示，其中 (x1, y1) 为左下角的坐标，(x2, y2) 是右上角的坐标。
如果相交的面积为正，则称两矩形重叠。需要明确的是，只在角或边接触的两个矩形不构成重叠。
给出两个矩形，判断它们是否重叠并返回结果。
 示例 1：
输入：rec1 = [0,0,2,2], rec2 = [1,1,3,3]
输出：true
示例 2：
输入：rec1 = [0,0,1,1], rec2 = [1,0,2,1]
输出：false
_ _
提示：
两个矩形 rec1 和 rec2 都以含有四个整数的列表的形式给出。
矩形中的所有坐标都处于 -10^9 和 10^9 之间。
x 轴默认指向右，y 轴默认指向上。
你可以仅考虑矩形是正放的情况。
来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/rectangle-overlap 
未参考的解答思路 花了一个草图来想象两个矩形
            矩形A1 矩形A2，按照A2不动的标准来跟A1作比较，如果两个不想交就说明需要满足两个XY方向条件
[A1(x1)≤A2(x0)||A1(x0)≥A2(x1)]&amp;amp;&amp;amp;[A1(y1)≤A2(y0)||A1(y0)≥A2(y1)]
计算了半天发现错了，因为不必满足所有条件，因为满足其中一个就行了，画蛇添足</description>
    </item>
    
    <item>
      <title>每日一篇leetcode之-拼写单词</title>
      <link>https://helixs.github.io/posts/2020-03-17-%E6%AF%8F%E6%97%A5%E4%B8%80%E7%AF%87leetcode%E4%B9%8B%E6%8B%BC%E5%86%99%E5%8D%95%E8%AF%8D/</link>
      <pubDate>Tue, 17 Mar 2020 07:18:37 +0000</pubDate>
      
      <guid>https://helixs.github.io/posts/2020-03-17-%E6%AF%8F%E6%97%A5%E4%B8%80%E7%AF%87leetcode%E4%B9%8B%E6%8B%BC%E5%86%99%E5%8D%95%E8%AF%8D/</guid>
      <description>给你一份『词汇表』（字符串数组） words 和一张『字母表』（字符串） chars。
假如你可以用 chars 中的『字母』（字符）拼写出 words 中的某个『单词』（字符串），那么我们就认为你掌握了这个单词。
注意：每次拼写时，chars 中的每个字母都只能用一次。
返回词汇表 words 中你掌握的所有单词的 长度之和。
 示例 1：
输入：words = [“cat”,”bt”,”hat”,”tree”], chars = “atach”
输出：6
解释：
可以形成字符串 “cat” 和 “hat”，所以答案是 3 + 3 = 6。
示例 2：
输入：words = [“hello”,”world”,”leetcode”], chars = “welldonehoneyr”
输出：10
解释：
可以形成字符串 “hello” 和 “world”，所以答案是 5 + 5 = 10。
_ _
提示：
1 &amp;lt;= words.length &amp;lt;= 1000
1 &amp;lt;= words[i].length, chars.length &amp;lt;= 100
所有字符串中都仅包含小写英文字母
通过次数21,660提交次数31,246</description>
    </item>
    
  </channel>
</rss>
