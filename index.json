[{"categories":[""],"content":" 这是个面试资料整理 还在编辑中\n 面试整理 Java相关 对象 java对象得创建过程 线程安全 Volatile DCL的单例一定是线程安全的吗 Java volatile如何防止指令重排序 kotlin相关 协程 协程1 安卓相关 项目架构 App壳、业务module、路由、module对外Api、核心资源库、第三方库包装代理、公共utils。\n绘制框架 RecyclerView RecyclerView RecyclerView1 RecyclerView2 事件分发 触屏事件分发 自定义View 自定义View 画中画 总结系列-Android画中画模式-看这篇就够啦 动画 转场动画 转场动画 任务 定时任务 Android 定时任务的8种实现方法 通信 Android AIDL浅析及异步使用 生命周期 项目配置 uses-permission和permission区别及使用 内存优化 内存泄露 GC Roots\n图中的每个圆节点代表对象的内存资源，箭头代表可达路径。当圆节点与 GC Roots 存在可达路径时，表示当前资源正被引用，虚拟机是无法对其进行回收的（如图中的黄色节点）。反过来，如果圆节点与 GC Roots 不存在可达路径，则意味着这块对象的内存资源不再被程序引用，系统虚拟机可以在 GC 过程中将其回收掉。\n从定义上讲，Android（Java）平台的内存泄漏是指没有用的对象资源任与GC-Root保持可达路径，导致系统无法进行回收。\n有哪些地方注意 static 如Activity view Context使用Application\n单例\n非静态异步超时方法\n非静态内部类\nHandler\nBitmap\nbroadcast 没有反注册\ncursor buffer等耗时操作没有关闭\nWebView（新进程）\n查找内存泄露 Inspect Code\nLeakCanary\nAndroid Monitor\n拓展 强引用(StrongReference)：JVM 宁可抛出 OOM ，也不会让 GC 回收具有强引用的对象；\n软引用(SoftReference)：只有在内存空间不足时，才会被回的对象；\n弱引用(WeakReference)：在 GC 时，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存；\n虚引用(PhantomReference)：任何时候都可以被GC回收，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否存在该对象的虚引用，来了解这个对象是否将要被回收。可以用来作为GC回收Object的标志。\n安全 Apk安全 启用混淆 枚举\n反射\ndata实体 框架自带 第三方库 jni 反射\n打包 字符串混淆\n加固\n加固 v1 基于 Jar签名\nv2 提高验证速度和覆盖度\nv3 密钥轮转\n各个版本的却别 四大组件 exported Broadcast(LocalBroadCast) allowBackup=false\n截屏 WindowManager.LayoutParams.FLAG_SECURE\nWebview WebView.getSettings().setSavePassword(false) addJavascriptInterface\n数据安全 不要将密钥放如java代码和资源文件中通过jni+算法实现\nSharePreferences 也不要放入敏感信息\nsqlite安全 加密\n日志等级输出 插件化开发中 下载路径、zip和文件进行校验 apk中存在的js html进行检查 so安全\n","date":"2021-11-22","img":"","permalink":"https://helixs.github.io/posts/2021-11-22-android%E9%9D%A2%E8%AF%95%E9%A2%98/","series":[],"tags":[""],"title":"Android面试题"},{"categories":null,"content":"Paint 类有一个这样的方法 setMaskFilter() 可以用不同的 MaskFilter 实现滤镜的效果，如滤化，立体等\n1setMaskFilter(MaskFilter maskfilter) MaskFilter 我们一般不会直接使用 MaskFilter，而是使用它的两个子类\n   类 说明     BlurMaskFilter 使用一个模糊的样式和半径来处理 Paint 的边缘   EmbossMaskFilter 通过指定光源的方向和环境光强度来添加浮雕效果    BlurMaskFilter 模糊效果 1BlurMaskFilter(float radius, BlurMaskFilter.Blur style)    参数 说明     radius 指定模糊边缘的半径   style 指定模糊的风格    BlurMaskFilter.Blur 的枚举常量有\n   值 说明     BlurMaskFilter.Blur.NORMAL 内外模糊   BlurMaskFilter.Blur.OUTER 外部模糊   BlurMaskFilter.Blur.INNER 内部模糊   BlurMaskFilter.Blur.SOLID 内部加粗，外部模糊    我们写一个范例来试验一下\n  1.创建一个 空的 Android 项目 cn.twle.android.BlurMaskFilter\n  2.自定义一个 View 类 BlurMaskFilterView.java\n1 package cn.twle.android.blurmaskfilter; 2 3 import android.content.Context; 4 import android.graphics.BlurMaskFilter; 5 import android.graphics.Canvas; 6 import android.graphics.Color; 7 import android.graphics.Paint; 8 import android.util.AttributeSet; 9 import android.view.View; 10 11 public class BlurMaskFilterView extends View{ 12 13 private String text = \u0026#34;简单教程，简单编程\u0026#34;; 14 15 public BlurMaskFilterView(Context context) { 16 super(context); 17 } 18 19 public BlurMaskFilterView(Context context, AttributeSet attrs) { 20 super(context, attrs); 21 } 22 23 public BlurMaskFilterView(Context context, AttributeSet attrs, int defStyleAttr) { 24 super(context, attrs, defStyleAttr); 25 } 26 27 @Override 28 protected void onDraw(Canvas canvas) { 29 30 BlurMaskFilter bmf = null; 31 Paint paint=new Paint(); 32 paint.setAntiAlias(true); //抗锯齿 33 paint.setColor(Color.RED);//画笔颜色 34 paint.setStyle(Paint.Style.FILL); //画笔风格 35 paint.setTextSize(68); //绘制文字大小，单位px 36 paint.setStrokeWidth(5); //画笔粗细 37 38 bmf = new BlurMaskFilter(10f,BlurMaskFilter.Blur.NORMAL); 39 paint.setMaskFilter(bmf); 40 canvas.drawText(text, 100, 100, paint); 41 bmf = new BlurMaskFilter(10f,BlurMaskFilter.Blur.OUTER); 42 paint.setMaskFilter(bmf); 43 canvas.drawText(text, 100, 200, paint); 44 bmf = new BlurMaskFilter(10f,BlurMaskFilter.Blur.INNER); 45 paint.setMaskFilter(bmf); 46 canvas.drawText(text, 100, 300, paint); 47 bmf = new BlurMaskFilter(10f,BlurMaskFilter.Blur.SOLID); 48 paint.setMaskFilter(bmf); 49 canvas.drawText(text, 100, 400, paint); 50 51 bmf = new BlurMaskFilter(50f,BlurMaskFilter.Blur.SOLID); 52 paint.setMaskFilter(bmf); 53 canvas.drawText(text, 100, 500, paint); 54 55 setLayerType(View.LAYER_TYPE_SOFTWARE, null); //关闭硬件加速 56 } 57 }   修改 MainActivity.java 设置 setContentView(new MsView(MainActivity.this))  1package cn.twle.android.blurmaskfilter; 2 3 4import android.os.Bundle; 5 6 7 protected void onCreate(Bundle savedInstanceState) { 8 super.onCreate(savedInstanceState); 9 setContentView(new EmbossMaskFilterView(MainActivity.this)); 10 } 11}    EmbossMaskFilter 浮雕效果 通过指定环境光源的方向和环境光强度来添加浮雕效果\n1EmbossMaskFilter(float[] direction, float ambient, float specular, float blurRadius) 参数说明\n   参数 说明     direction 浮点型数组，用于控制 x,y,z 轴的光源方向   ambient 设置环境光亮度，0到1之间   specular 镜面反射系数   blurRadius 模糊半径      1.复用上面的范例\n  2.创建另一个自定义 View 类 EmbossMaskFilterView.java\n1package cn.twle.android.blurmaskfilter; 2 3import android.content.Context; 4import android.graphics.Canvas; 5import android.graphics.Color; 6import android.graphics.EmbossMaskFilter; 7import android.graphics.Paint; 8import android.util.AttributeSet; 9import android.view.View; 10 11public class EmbossMaskFilterView extends View{ 12 13 public EmbossMaskFilterView(Context context) { 14 super(context); 15 } 16 17 public EmbossMaskFilterView(Context context, AttributeSet attrs) { 18 super(context, attrs); 19 } 20 21 public EmbossMaskFilterView(Context context, AttributeSet attrs, int defStyleAttr) { 22 super(context, attrs, defStyleAttr); 23 } 24 25 @Override 26 protected void onDraw(Canvas canvas) { 27 float[] direction = new float[]{ 1, 1, 3 }; // 设置光源的方向 28 float light = 0.4f; //设置环境光亮度 29 float specular = 8; // 定义镜面反射系数 30 float blur = 10.0f; //模糊半径 31 EmbossMaskFilter emboss= new EmbossMaskFilter(direction,light,specular,blur); 32 33 Paint paint = new Paint(); 34 paint.setAntiAlias(true); //抗锯齿 35 paint.setColor(Color.BLUE);//画笔颜色 36 paint.setStyle(Paint.Style.FILL); //画笔风格 37 paint.setTextSize(70); //绘制文字大小，单位px 38 paint.setStrokeWidth(8); //画笔粗细 39 paint.setMaskFilter(emboss); 40 41 paint.setMaskFilter(emboss); 42 canvas.drawText(\u0026#34;简单教程，简单编程\u0026#34;, 50, 100, paint); 43 44 setLayerType(View.LAYER_TYPE_SOFTWARE, null); //关闭硬件加速 45 } 46}   修改 MainActivity.java设置 setContentView(new MsView(MainActivity.this))  1package cn.twle.android.blurmaskfilter; 2 3import android.support.v7.app.AppCompatActivity; 4import android.os.Bundle; 5 6public class MainActivity extends AppCompatActivity { 7 8 @Override 9 protected void onCreate(Bundle savedInstanceState) { 10 super.onCreate(savedInstanceState); 11 setContentView(new EmbossMaskFilterView(MainActivity.this)); 12 } 13}   注意事项 如果不关闭硬件加速，那么 MaskFilter 就不会起效果了，这是因为 Android 在 API 14 以上版本都是默认开启硬件加速的，这样充分 利用 GPU 的特性，使得绘画更加平滑，但是会多消耗一些内存\n把硬件加速关了就好，可以在不同级别下打开或者关闭硬件加速，一般是关闭\n   Application ：在配置文件的 application 节点添加  1 android:hardwareAccelerated=\u0026#34;true\u0026#34;   Activity ：在配置文件的 activity 节点添加  1 android:hardwareAccelerated=\u0026#34;false\u0026#34;   View ：可以获得 View 对象后调用，或者直接在 View 的 onDraw() 方法里设置  1 view.setLayerType(View.LAYER_TYPE_HARDWARE, null);   转自https://www.twle.cn/l/yufei/android/android-basic-setmaskfilter.html ","date":"2021-11-11","img":"","permalink":"https://helixs.github.io/posts/android/paint/maskfilter/","series":null,"tags":null,"title":"MaskFilter"},{"categories":["flutter","编程生活"],"content":"公司这段时间新建了一个网站项目，因为是新项目，选择技术栈来说是比较值得探讨的问题，因为前端缺人，本身我们组又是移动应用开发为主，虽然前端也会，毕竟不是一直从事前端开发，不能那么快速将项目上线。刚好前不久Flutter2.0发布了，FlutterWeb也开启了正式之路，然后我就跟同事们说要不就用这玩意儿吧，来吃肉(填坑？)。然后大家就欣然同意。\n FlutterWeb实现原理基本上和移动应用一个道理，默认情况下都是使用的调用Canvaskit+skia引擎调用WebGL实现绘制。也可以使用html+css+canvas进行渲染，这样少了Skia引擎，会让包大小少2mb左右，不过展示的样式可能就是根据浏览器默认渲染的方式进行了，差别还是蛮大的。\n 1.字体乱码 使用默认Canvaskit渲染方式，并不会优先使用系统默认的字体(我至今也想不通为啥)，会导致打开网页长时间乱码。解决方式是自定义字体或者按照html渲染方式 解决。官方目前还没有什么有效的解决方式，问题在这里https://github.com/flutter/flutter/issues/73628  出现问题的主要原因是，自绘引擎需要字体库支持，FlutterWeb 默认会使用Noto字体，因为一般电脑上都不会带有这个字体，所以会在线寻找这个字体，比如google或者一些第三方字体库网站，导致加载缓慢和乱码。当然还有办法可以解决这个问题，就是将字体放到本地资源库，比如将Noto字体作为默认字体一起打包到web网站上，下载速度就快了很多,你也可以换一些自己的中文字体(注意版权问题)，不会出现乱码情况。坏处就是还是会增加一些服务器的负担。\n 1flutter:2fonts:3- family:Noto4fonts:5- asset:fonts/NotoSansSC-Bold.otf6- asset:fonts/NotoSansSC-Medium.otf7- asset:fonts/NotoSansSC-Regular.otf8style:normal其实ttf和otf等字体已经支持自适应宽度了，所以为了追求速度可以直接放入一个宽度的字体就行了，如”NotoSansSC-Regular.otf“就行。 试了一下发现它的单个字体大小仍然很大，达到了8Mb。因为汉语字实在是太多了，所以我们可以考虑精简我们的字体，将汉语中的常用的文字拿出来，然后重新打包成精简字体包，这个方法在很多客户端应用中也都有用到。可以看一下下面的教程，我提取出来3500字的一级字表，从8mb减少到了800kb，相应的传输速度也快了很多。\n常用3500字，常用6500字 通过 fontTools 精简字体 2.应用体积过大 我们大概做了十几个页面吧，打包下来最后会生成main.dart.js文件，搞下来已经7mb了，而且没办法拆分，意思就是你打开这个网站就等于加载了几乎整个应用渲染逻辑！更意味着打开网站下载js，执行js，渲染js 是你不得不面对的三道速度墙！记得如果你真的要用它，放到生产环境时候要给nginx或者其他方式实现brotli或者gzip压缩来减少传输时间！当然官方现在也没有很好的解决办法来如何拆分它！https://github.com/flutter/flutter/issues/46589 CanvasKit方式渲染会在线下载两个跟Skia引擎相关的文件canvaskit.js和canvaskit.wasm，后者直接达到了6Mb多，真的是服了。在线下载的地址是https://unpkg.com/browse/ (有多个版本，查看自己所要的就行了)，我这里压缩测试的大小2mb+，下载速度大概是200kb/s左右。如果你不差钱，嫌下载速度太慢，可以将两个文件下载下来放到国内云或者cdn上。具体的操作如下，打包命令后面添加参数\n1flutter build web --web-renderer canvaskit --release --dart-define=FLUTTER_WEB_CANVASKIT_URL=\u0026#34;https://xxx.com/\u0026#34; 注意，网址一定要是包含包含了canvaskit.js和canvaskit.wasm这两个文件的父目录哦！打包生成后可以到main.dart.js文件中找到你替换的地址，看看对不对。\n 还有一个加载体验优化,编译后会生成\u0026quot;index.html+main.dart.js\u0026quot;，因为网站默认会直接加载index.html文件,在html文件中直接写入CSS3的Loading动画，所以我们在加载js文件的同时，直接展示它避免初始化白屏的烦恼。是个小技巧哈！也可以放入下面这张图给用户哈哈！\n 3.复制粘贴 因为FlutterWeb是自绘引擎，默认是不支持文字选中和复制了，如果你需要文字选中和复制需要使用SelectableText ，从体验上来讲，还是有那么不太舒服哦，跟原生Web标准还是差很多。如果你的网页需要允许用户进行大量的复制操作，请谨慎尝试。\n4.可以防止网页爬虫 如果你的网页需要提高标签值被爬的难度，那么它可能是比较好的一个办法，一堆js等着别人去解析吧。\n5.注意事项 如果你是传统的App开发者，那么你就需要学习一些浏览器特性来对浏览器平台进行特定的处理。\n  1.对路由进行操作，如用户点击刷新、返回、多窗口等等是需要注意的点，通过Navigator2来进行编写，后续会花点时间进行单独写出来。 2.跨域安全问题。 3.储存加密安全(App都不能保证绝对安全，浏览器就更不能把什么对称密钥放到本地了)。   根据上面的信息，我大概确定的是它目前定位基本上和nativeApp一个级别的WebApp，也可以直接生成webApp应用给浏览器保留，所以他不合适用来做很多传统的WebPage应用了。虽然现在已经迈入5G时代，但是你让一个用户一进来就打开一个5mb左右的页面，还不包括图片和内容等，感觉还是有点得不偿失。倘若你要做的项目是统一UI平台，那么也可以试试。\n","date":"2021-04-27","img":"","permalink":"https://helixs.github.io/posts/2021-04-27-flutter-web%E4%BD%BF%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BF%83%E5%BE%97%E5%92%8C%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/","series":null,"tags":null,"title":"Flutter Web使用的一些心得和一些问题"},{"categories":["闲聊"],"content":"美国并不酷爱战争，但美国需要战争。过去20年里，美国是世界上唯一连打过四场对外战争的国家。美国为什么要如此频繁地发动战争？地球人不懂，恐怕美国人民也不懂，因为这四场战争，发生在三个不同的国家和地区，开战的理由也都十分充分且冠冕堂皇，谁会把它们与一张轻飘飘的绿纸联系在一起？为美元而战，这就是美式战争的全部秘密。\n美国人从未在他们公开的国家战略中谈论过这个话题。据说，上一任美联储主席格林斯潘就职当天，就曾告诫他的同僚：在这里（美联储）你们可以谈论一切，就是不许谈论美元。这是禁忌，美国人对这一关乎美国国家生存的话题讳莫如深。\n美国人在过去40年里，找到了一种在他们看来是最好的，也最便捷的国家生存方式，那就是用金融手段从全球向美国转移财富。美国人发现自己可以不用生产其他的产品，只生产一样东西就可以致富，就可以过得比世上所有人都好，这个方式就是印刷美元。\n从罗马帝国到大英帝国，基本上都是以一种相似的方式完成帝国积累财富、消耗财富的过程。这种方式是什么呢？就是占领别国的领土，掠夺别国的资源，奴役别国的人民。这就是经典的殖民帝国模式。但是两次世界大战的教训，使美国意识到，必须避免重蹈古典帝国模式的覆辙。因为一次大战德国向老牌殖民帝国挑战，想要获取自己的生存空间，结果失败了。20多年后德国再度崛起，再次向老牌殖民帝国发起挑战，又再度失败了。美国毫无疑问记取了这个历史教训：如果一个国家的崛起，一定要从老牌殖民帝国那里虎口夺食的话，就不可避免地会发生战争，而其结果只能是两败俱伤，最后徒使他人得利。美国就是两次大战最大的获利者。\n“布雷顿森林体系”的实质：全世界的货币锁定美元，而美元锁定黄金。美国政府向全世界承诺，每35美元可以兑换一盎司黄金，那个时候的美国可以说是志得意满，因为这个时候的美国有世界上最大的黄金储备，世界上80%的黄金都捏在美国人手里，与此同时，美国还拥有世界上最强大的生产能力和军事机器。\n没有足够多的黄金你就不能印足够多的美元！因为你对全世界有承诺，你是全世界的基准货币，你必须保持美元的稳定。这使美国陷入了空前的窘境。 1971年8月15日，当时的美国总统尼克松宣布：美元跟黄金脱钩。这一失信之举意味着美国可以不受黄金的羁绊，随意加印美元了。\n半年后，研究报告《黄金非货币化的影响》出炉。这份具有良知的报告中提醒美国政府，美元跟黄金脱钩，在短时间内对美国有好处，因为美国可以在全世界还没回过神来时多印钞票，用没有黄金背书的纸币去占全世界的便宜。但长期看，这对美国和全世界都决不是什么好事，尤其对美国，无疑是饮鸩止渴。\n而美国政府俨然如醍醐灌顶，大彻大悟！他们根本不理会作者迈克尔·赫德森的警告，对报告反其意而用之。既然这么干短期对美国有好处，干吗不把它变成一个长期的好处，让美国人永久享用呢？当然，这首先需要与黄金脱钩后完全变成一张绿纸的美元，在全世界面前，仍然保持它的信用。这就意味着美元必须保持它的霸权地位。怎样才能保持美元的霸权地位呢？美国政府认为最重要的是两根支柱，一根是美国强大的科技创新力。另一根是美国强大的军事实力。\n但美国人知道，与黄金脱钩后的美元，最好与世界上最重要的大宗商品挂钩，才能确保美元的地位稳如磐石。机会很快就来了。1973年的10月6日，第四次中东战争爆发。一开始，埃及人和叙利亚人两线出击，打了以色列一个措手不及，但不久后战况逆转，以色列反占上风。这让阿拉伯世界非常郁闷。坐拥石油的阿拉伯人决定，在战场上得不到的东西，就从其他地方去获得。于是，欧佩克——国际石油输出国组织——决定用石油做武器，抬高油价打击西方。这个办法果然比战争来得更有效，很快西方就承受不住了。\n这时，美国当时的财政部长西蒙秘密地飞到了沙特，去见沙特的石油大臣，也是首任欧佩克秘书长，告诉他：你们想把油价打多高我们不管， 但是要想不让美国人与你们为敌，你们必须接受一个条件，就是全球的石油交易用美元结算。这位沙特的石油大臣与整个世界一样，对美国人这一招棋的深远机心并不了然，于是就一口答应了美国人的要求，从此，全世界的石油交易与美元挂钩，而美元的信用也就在此后40年里，牢牢地与全球的能源需求挂上了钩。\n走到这一步，美国人设计出的这个新型帝国渐渐开始显现出轮廓，这就是人类帝国史上从未出现过的金融殖民帝国。美国人发现，比起当年德国人虎口夺食去争取一个国家的生存空间这种愚蠢做法来，更高明的办法，应该是通过让世人几乎觉察不到的方式，乖乖地让他们把手中财富交出来，而又不制造仇恨。要达此目的，没有比金融殖民更好的办法了，这办法可以把全世界都纳入美国的金融体系中，然后，像拧开自来水水龙头一样让财富滚滚流入美国人的口袋。\n美国人用比较优势理论把全世界分成了两块，一块是美国，美国人认为它的优势就在于生产美元；另一块是全世界。全世界的优势在哪儿呢？比如，中国人，你的比较优势就在于你有大量的廉价劳动力。由美国人作为一方，全世界作为另一方，由美国人负责生产美元，而全世界负责生产用美元交换的产品，这就是美国人主导的全球产业大分工的本质，从此，全球化浪潮席卷全球。\n美国用自己的金融体系，把全世界与美国紧紧捆绑在一起，这种由美国向世界输出美元，而世界向美国提供产品的交易模式，其结果就是全球财富快速向美国集中，这也就是美国在1990年前的200多年里，GDP最高时才不过达到7万亿美元，而在最近的短短20年里，GDP居然翻了一番，达到14万亿的根本原因。当然，美国人比全世界都清楚，用这种方式聚敛的财富，仅仅靠全球产业大分工是不够的，甚至再加上石油与美元挂钩也还不够，还需要一个非常强有力的手段，如果没有这个手段，美国不足以从世人手中掠走那么多的财富，而这个手段就是天下第一的军事实力。\n美国人为什么要打伊拉克战争？答曰：为了石油。那么，接下来的问题是：为什么美国占领伊拉克后，却不从伊拉克免费拉走一桶石油？当美国打下伊拉克时，首先出现的是什么情况？全球油价飙升。油价飙升，交易又以美元结算，意味着什么呢？意味着油价的飙升拉高了全球的美元需求，也就是说，美国人通过战争打出了全球的美元需求。打伊拉克战争之前，一桶石油38美元，打完了之后接近150美元，等于一场战争把美元的需求打高了近三倍。这样一来，美国政府就能以给全世界提供流动性的名义，开动印钞机，印刷更多的美元，而美国政府不是慈善家，不会白白把美元给你，你必须拿你的产品去换，从而再一次加入实物换绿纸的游戏。此时美国政府的印钞行为可以说名正言顺。更多的美元流到了其他国家的手里，流到了产油国的手里，也流到了需要购买石油的国家手里。\n这么多美元攥在这些国家手里能干什么呢？除了作为财富的符号让人开心外，就是变为废纸的前景让人担心，因为美元正以日新月异的速度在贬值，天天在贬值，天天都在变成废纸，这个时候你唯一的选择，就是美国人早就为你准备好的选择：购买美国的国债。\n购买美国国债使巨量的美元回流美国，也使美国成了全世界最大的债务国。那么，美国为什么需要让流向全世界的美元，再以购买美国国债的方式回流美国呢？一个几乎没有储蓄率的美国，必须始终保持资本项目的顺差，而这个顺差的额度在2001年前后的时候，大约是每年7000亿美元左右，也就是说，需要每天净流入美国20亿美元。因此，美国需要大量的世界资本回流美国，大部分美国人刷卡透支的好日子才能为继，\n为了保持资本项下的顺差，美国会不惜动用战争手段，去打坏别国、别的地区的投资环境，像驱赶羊群一样，把美元驱赶回美国。所以说，表面上看，两次伊拉克战争都和石油有关，但实际上主要是和美元有关。因为只要在产油区打仗，油价就会上升，美元的需求也就会随之上升。如此一来，美国人就可以开动印钞机，印更多的美元，从全球换回更多的实物财富，道理就这么简单。\n美国打科索沃的真正动机到底是什么？这场战争发生的时间是1999年3月，但耐人寻味的是，1999年1月1日，发生了另一个重大事件：欧元正式启动。当时欧元和美元的汇率是1∶1.07，欧元作为一种全新的国际结算货币，一上来就对美元霸权地位构成了挑战和威胁。仅仅两个月后，科索沃战争打响。战争还没结束，世人便发现，深受战争创伤的，不光是南联盟，还有欧元。有欧盟各国空军做帮手的72天的狂轰滥炸，其最重要的结果，不光是米洛舍维奇政权的垮台，还有欧元与美元汇率的倒挂，由1欧元兑换1.07美元，变为0.82美元兑换1欧元，欧元跌幅达30%。由此可以看出，美国人打科索沃战争是“项庄舞剑，意在‘欧元’”。\n结果，战争一打响，7000多亿热钱中有4000多亿立刻从欧洲抽逃，其中2000多亿去了美国，直接支持了美国已经连续90多个月的经济繁荣。美国历史上还从来没有过如此漫长的经济增长期。\n另外的2000多亿则去了香港，香港怎么可能在短时间内消化这么多钱？显然是那些投资人或投机家，看好中国内地市场，想拿香港做跳板，进入中国内地。让人备感蹊跷的是，恰在这个时候不早不晚发生了一件震惊世界的事情，美国人用5枚精确制导炸弹，“误炸”了中国驻南联盟大使馆。一个星期之后，滞留香港的2000多亿热钱从香港抽逃，最后去了哪儿呢？又去了美国，4000多亿热钱全部流到了美国，去支持美国已经连续90多个月的经济繁荣。\n“9·11”发生之后两个月不到，美国就打响了阿富汗战争，这完全不符合美国打一场局部战争的战争准备规律。1980年之后，美国人连打了四场战争，除阿富汗战争之外另外的三场战争，美国人的战争准备时间都在半年左右，这意味着美国打一场局部战争需要半年的准备，但是阿富汗战争却是个例外，不到两个月就仓促打响。\n因为这个时候正是“9·11”发生之后不久，大量的资金开始撤离美国。因为全球的投资人突然对全世界最安全的投资环境——美国产生了疑虑。美国是全球的金融中心，纽约是美国的金融中心，而华尔街是纽约的中心，世贸大厦则是中心的中心。现在，这个中心的中心居然让恐怖分子给撞毁了，谁还敢对你的投资环境保持信心呢？于是，从这时起，据说有三四千亿美元撤离了美国，前面提到美国每年需要吸纳大约7000多亿美元的净流入，这个时候有三四千亿美元撤离美国，而这一年还有几个月的日子要过，没有钱怎么行？所以美国迫切需要一场战争，需要用一场战争，打回全世界投资人对美国的信心。\n果然如此，当阿富汗战争打响之后，巡航导弹一落在阿富汗的土地上，道琼斯指数就在短期下探后很快回升，华尔街一片叫好，随着战况进展顺利，大量撤离的资金又陆续回到了美国，这场战争重新打回了全世界对美国投资环境的信心。\n美国人向全世界展示的现代战争理念是，如果我的投资环境不好而短期内又无法改变的话，那我就用战争把其他地方打得更坏，反衬出美国相对的好。你不是认为我的投资环境不安全吗？那我就打一场战争给你看，美国仍然是最强大的，美国人想打谁就打谁，你要觉得美国的投资环境不安全，还有别的地方比我更不安全，那个地方还在发生战争。这就是美国的军事力量如何为它的金融大战略服务。\n过去，美国人喜欢说，当世界上什么地方出现麻烦，美国总统的第一反应就是：我们的航空母舰在哪里？现在这种说法正在逐渐成为过去时。当互联网把全球连成一个整体，网上交易、网上支付已成家常便饭，随便敲几下键盘，成百亿、上千亿甚至数万亿的美元，就可以在瞬间完成转移或者是抽逃时，这种几乎以光速运行的资本流动，是每小时以三四十节的速度航行的航空母舰无法跟上的。即便是以超音速飞行的舰载机，也同样跟不上。\n为此，五角大楼对其军事力量提出了新的要求：尽快建立“全球快速打击系统”。这一系统要求美军的军事打击能力，能比航母为代表的传统军事手段更快捷地打击地球上任何目标，打击时限也一再缩短，从号称一小时打遍全球，缩短到28分钟打遍全球。意义就在于，它基本上可以跟上资本流动的速度了。\n做出上述一系列（军事开支）压缩之举的同时，我们会看到五角大楼的另一些耐人寻味的举措：比如说建立空天司令部，比如说建立全球第一支网军，又比如说全球第一架空天飞机的试飞，再比如说正在研发的5倍于音速的巡航导弹……所有这些，又都在向我们传递与前述信息相反的信息，那就是五角大楼比以往任何时候都更注重美军的速度——从部署的速度到打击的速度，而这一切，都与资本的流速和流向有关，因为美国人心里最清楚：今天的美国是一个建立在纸币上的帝国。要让这个帝国不垮塌，就必须保持美元的霸权，现在，要做到这一点，除了军事手段，美国人手上似乎已没有其他什么管用的家伙了。\n","date":"2021-04-19","img":"","permalink":"https://helixs.github.io/posts/2021-04-19-%E7%BE%8E%E5%9B%BD%E5%8F%91%E5%8A%A8%E4%BC%8A%E6%8B%89%E5%85%8B%E6%88%98%E4%BA%89%E7%9A%84%E4%B8%80%E7%A7%8D%E7%8C%9C%E6%83%B3/","series":null,"tags":null,"title":"美国发动伊拉克战争的一种猜想"},{"categories":["数据库","编程生活"],"content":"1$ sudo apt install mariadb-server 2#root权限 3$ sudo mysql_secure_installation 4 5NOTE: RUNNING ALL PARTS OF THIS SCRIPT IS RECOMMENDED FOR ALL MariaDB 6 SERVERS IN PRODUCTION USE! PLEASE READ EACH STEP CAREFULLY! 7 8In order to log into MariaDB to secure it, we\u0026#39;ll need the current 9password for the root user. If you\u0026#39;ve just installed MariaDB, and 10you haven\u0026#39;t set the root password yet, the password will be blank, 11so you should just press enter here. 12#两次回车 13Enter current password for root (enter for none): 14OK, successfully used password, moving on... 15 16Setting the root password ensures that nobody can log into the MariaDB 17root user without the proper authorisation. 18#是否设置root新密码 19Set root password? [Y/n] y 20New password: 21Re-enter new password: 22Password updated successfully! 23Reloading privilege tables.. 24 ... Success! 25 26 27By default, a MariaDB installation has an anonymous user, allowing anyone 28to log into MariaDB without having to have a user account created for 29them. This is intended only for testing, and to make the installation 30go a bit smoother. You should remove them before moving into a 31production environment. 32#是否删除其他的账户 33Remove anonymous users? [Y/n] y 34 ... Success! 35 36Normally, root should only be allowed to connect from \u0026#39;localhost\u0026#39;. This 37ensures that someone cannot guess at the root password from the network. 38#是否禁止远程登录root 39Disallow root login remotely? [Y/n] y 40 ... Success! 41 42By default, MariaDB comes with a database named \u0026#39;test\u0026#39; that anyone can 43access. This is also intended only for testing, and should be removed 44before moving into a production environment. 45#删除测试数据库 46Remove test database and access to it? [Y/n] y 47 - Dropping test database... 48 ... Success! 49 - Removing privileges on test database... 50 ... Success! 51 52Reloading the privilege tables will ensure that all changes made so far 53will take effect immediately. 54#重新加载 55Reload privilege tables now? [Y/n] y 56 ... Success! 57 58Cleaning up... 59 60All done! If you\u0026#39;ve completed all of the above steps, your MariaDB 61installation should now be secure. 62 63Thanks for using MariaDB!  这里针对的是知道 root 密码，而需要修改的情况。\n两种修改方法：\n1、直接在shell命令行使用 mysqladm 命令修改。\nmysqladmin -uroot -poldpassword password newpassword\n这种方法的弊端在于会明文显示密码。 2、登陆数据库修改密码。\nmysql -uroot -p\n2.1 更新 mysql 库中 user 表的字段：\n1MariaDB [(none)]\u0026gt; use mysql; 2MariaDB [mysql]\u0026gt; UPDATE user SET password=password(\u0026#39;newpassword\u0026#39;) WHERE user=\u0026#39;root\u0026#39;; 3MariaDB [mysql]\u0026gt; flush privileges; 4MariaDB [mysql]\u0026gt; exit; 2.2 或者，使用 set 指令设置root密码：\n1MariaDB [(none)]\u0026gt; SET password for \u0026#39;root\u0026#39;@\u0026#39;localhost\u0026#39;=password(\u0026#39;newpassword\u0026#39;); 2MariaDB [(none)]\u0026gt; exit; 如果是忘记了 root 密码，则需要以跳过授权的方式启动 mariadb 来修改密码。\n1、先停掉服务。\nsystemctl stop mariadb\n2、使用跳过授权的方式启动 mariadb。\nmysqld_safe --skip-grant-tables \u0026amp;\n[1] 1441 mysqld_safe Logging to \u0026lsquo;/var/log/mariadb/mariadb.log\u0026rsquo;. 170531 02:10:28 mysqld_safe Starting mysqld daemon with databases from /var/lib/mysql\nps -ef | grep 1441\nroot 1441 966 0 02:10 pts/0 00:00:00 /bin/sh /usr/bin/mysqld_safe \u0026ndash;skip-grant-tables\nmysql 1584 1441 0 02:10 pts/0 00:00:00 /usr/libexec/mysqld \u0026ndash;basedir=/usr \u0026ndash;datadir=/var/lib/mysql \u0026ndash;plugin-dir=/usr/lib64/mysql/plugin \u0026ndash;user=mysql \u0026ndash;skip-grant-tables \u0026ndash;log-error=/var/log/mariadb/mariadb.log \u0026ndash;pid-file=/var/run/mariadb/mariadb.pid \u0026ndash;socket=/var/lib/mysql/mysql.sock\n3、当跳过授权启动时，可以不需要密码直接登陆数据库。登陆更新密码即可。\nmysql\n1MariaDB [(none)]\u0026gt; use mysql; 2MariaDB [mysql]\u0026gt; UPDATE user SET password=password(\u0026#39;newpassword\u0026#39;) WHERE user=\u0026#39;root\u0026#39;; 3MariaDB [mysql]\u0026gt; flush privileges; 4MariaDB [mysql]\u0026gt; exit; 更新密码后，在跳过授权启动时也不能空密码直接登陆了。 4、关闭跳过授权启动的进程：\nkill -9 1441  5、正常启动 mariadb：\nsystemctl start mariadb\n启动远程连接 1cd /etc/mysql/mariadb.conf.d 2 3sudo vim 50-server.cnf 4 5# 找到 bind-address 删掉注释 设置为0.0.0.0 6 7#登录mysql  8sudo mysql -uroot -p 9#输入下面这段 root和password远程登录的密码，和本地密码不同。 10GRANT ALL PRIVILEGES ON *.* TO \u0026#39;root\u0026#39;@\u0026#39;%\u0026#39;IDENTIFIED BY \u0026#39;password\u0026#39; WITH GRANT OPTION; 11 flush privileges; 12#退出mysql 然后 13service mysql restar ","date":"2021-04-02","img":"","permalink":"https://helixs.github.io/posts/2021-04-02-mariadb%E5%AE%89%E8%A3%85%E8%AE%BE%E7%BD%AEroot%E5%AF%86%E7%A0%81/","series":null,"tags":null,"title":"Mariadb安装设置root密码"},{"categories":["数据结构和算法"],"content":"跟hashMap的区别就是所有node节点增加了after和before属性 形成了双向链表，通过牺牲空间来保证有序性。\n","date":"2021-03-30","img":"","permalink":"https://helixs.github.io/posts/2021-03-30-linkedhashmap%E5%9B%BE%E8%A7%A3/","series":null,"tags":null,"title":"LinkedHashMap图解"},{"categories":["LeetCode","数据结构和算法","编程生活"],"content":"1给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。 2你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。 3你可以按任意顺序返回答案。 4示例 1： 5输入：nums = [2,7,11,15], target = 9 6输出：[0,1] 7解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 8示例 2： 9输入：nums = [3,2,4], target = 6 10输出：[1,2] 11示例 3： 12输入：nums = [3,3], target = 6 13输出：[0,1] 14 链接：https://leetcode-cn.com/problems/two-sum 我的第一想法 双循环\n1public static int[] twoSum(int[] nums, int target) { 2 for (int i = 0; i \u0026lt; nums.length; i++) { 3 for (int i1 = 0; i1 \u0026lt; nums.length; i1++) { 4 if (i == i1) { 5 continue; 6 } 7 if (nums[i]+nums[i1]==target){ 8 return new int[]{i,i1}; 9 } 10 } 11 } 12 return new int[]{}; 13 } 14 再看看大神\n1public int[] twoSum(int[] nums, int target) { 2 int[] indexs = new int[2]; 3 4 // 建立k-v ，一一对应的哈希表 5 HashMap\u0026lt;Integer,Integer\u0026gt; hash = new HashMap\u0026lt;Integer,Integer\u0026gt;(); 6 for(int i = 0; i \u0026lt; nums.length; i++){ 7 if(hash.containsKey(nums[i])){ 8 indexs[0] = i; 9 indexs[1] = hash.get(nums[i]); 10 return indexs; 11 } 12 // 将数据存入 key为补数 ，value为下标 13 hash.put(target-nums[i],i); 14 } 15 16 return indexs; 17 } 看到没，循环只有一次，通过每次预推断补数，就直接下个循环判断有没有就行了。\n","date":"2021-03-26","img":"","permalink":"https://helixs.github.io/posts/2021-03-26-leetcode%E4%B9%8B%E5%9C%A8%E6%95%B0%E7%BB%84%E4%B8%AD%E8%AE%A1%E7%AE%97%E6%9F%90%E4%B8%AA%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%92%8C%E7%AD%89%E4%BA%8E%E7%9B%AE%E6%A0%87%E5%80%BC/","series":null,"tags":null,"title":"LeetCode之在数组中计算某个两个数和等于目标值"},{"categories":["Android开发","编程生活"],"content":"进行Android开发我们经常遇到一些依赖冲突，以及库版本号不一致导致出现各种问题。往往就下面这张图只是看到了你所有的依赖项，并不知道这些依赖都是从哪里来的，除非你进去一个个查看pow.xml那么蠢了。\n看了半天也不知道是从哪里依赖的。\n有个简单的方法，打开gradle工具，找到项目下如app模块-\u0026gt;Tasks-\u0026gt;help-\u0026gt;dependencies-\u0026gt;双击那么他会执行 :app:dependencies命令,会打印出依赖项及子依赖项\n往上说的那些什么插件的都是老方法了，新版的studio没办法直观反映\n还有别的一些方法可以试一试https://blog.csdn.net/songjianzaina/article/details/98175098 ","date":"2021-02-19","img":"","permalink":"https://helixs.github.io/posts/2021-02-19-androidstudio%E9%80%9A%E8%BF%87gradle%E6%9F%A5%E7%9C%8B%E7%AC%AC%E4%B8%89%E6%96%B9%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB/","series":null,"tags":["android","gradle"],"title":"AndroidStudio通过Gradle查看第三方依赖关系"},{"categories":["图像及视频资料","百科资料库"],"content":"本人对图像和视频知识方面基本上是个小白，饶有兴致的看看资料，把觉得有用的东西记录下来，资料均为网上收集。\n视频技术的实践介绍：图像、视频、编解码器（av1、vp9、h265）等（ffmpeg编码） 有多语言翻译。\nhttps://github.com/leandromoreira/digital_video_introduction 拜耳阵列\nhttps://www.cnblogs.com/morikokyuro/p/13256701.html https://zh.wikipedia.org/wiki/%E6%8B%9C%E7%88%BE%E6%BF%BE%E8%89%B2%E9%8F%A1 RGB和YUV关系和区别\nhttps://blog.csdn.net/asahinokawa/article/details/80596655 https://www.cnblogs.com/yunlambert/p/11234971.html https://www.cnblogs.com/justkong/p/6570914.html YUV 420 444 421 422 如何理解\nhttps://blog.csdn.net/xueyushenzhou/article/details/40817949 视频编码中的I/P/B帧\nhttps://www.cnblogs.com/yongdaimi/p/10676309.html https://blog.csdn.net/abcjennifer/article/details/6577934 ","date":"2021-02-09","img":"","permalink":"https://helixs.github.io/posts/2021-02-09-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E5%9B%BE%E5%83%8F%E5%8F%8A%E8%89%B2%E5%BD%A9%E7%94%9F%E6%88%90%E5%8E%9F%E7%90%86/","series":null,"tags":null,"title":"计算机中图像视频及色彩生成原理"},{"categories":[],"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution  Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\n Blockquote with attribution  Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.— Rob Pike1 Tables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\n   Name Age     Bob 27   Alice 23    Inline Markdown within tables    Italics Bold Code     italics bold code    Code Blocks Code block with backticks 1\u0026lt;!doctype html\u0026gt; 2\u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; 3\u0026lt;head\u0026gt; 4 \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; 5 \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; 6\u0026lt;/head\u0026gt; 7\u0026lt;body\u0026gt; 8 \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; 9\u0026lt;/body\u0026gt; 10\u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1\u0026lt;!doctype html\u0026gt; 2\u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; 3\u0026lt;head\u0026gt; 4 \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; 5 \u0026lt;title\u0026gt;Another Example HTML5 Document\u0026lt;/title\u0026gt; 6\u0026lt;/head\u0026gt; 7\u0026lt;body\u0026gt; 8 \u0026lt;p\u0026gt;A looooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooong text\u0026lt;/p\u0026gt; 9\u0026lt;/body\u0026gt; 10\u0026lt;/html\u0026gt; List Types Ordered List  First item Second item Third item  Unordered List  List item Another item And another item  Nested List  Fruit  Apple Orange Banana   Dairy  Milk Cheese    TODO List  Done WIP  Other Elements — abbr, sub, sup, kbd, mark GIFis a bitmap image format.\nH2O\nXn+ Yn= ZnPress CTRL+ALT+Deleteto end the session.\nMost salamandersare nocturnal, and hunt for insects, worms, and other small creatures.\n  The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","date":"2020-11-09","img":"https://helixs.github.io/images/markdown.png","permalink":"https://helixs.github.io/posts/markdown-syntax/","series":["Manual"],"tags":["Markdown","CSS","HTML"],"title":"Markdown Syntax Guide"},{"categories":["Android开发"],"content":"有这么一个需求，一个列表要满足一个条件\n 1、列表少于等于5条，列表的高度跟随item的数量变化而变化 2、如果超过5条，按照最大5条的高度显示，并支持滚动  所以基本的由于item高度不能定死，所以支持设置recyclerView高度是wrap_content\n然后具体操作看了下源码，大部分计算都是在LayoutManager中，找到这里\n1void setMeasuredDimensionFromChildren(int widthSpec, int heightSpec) { 2 final int count = getChildCount(); 3 if (count == 0) { 4 mRecyclerView.defaultOnMeasure(widthSpec, heightSpec); 5 return; 6 } 7 int minX = Integer.MAX_VALUE; 8 int minY = Integer.MAX_VALUE; 9 int maxX = Integer.MIN_VALUE; 10 int maxY = Integer.MIN_VALUE; 11 for (int i = 0; i \u0026lt; count; i++) { 12 View child = getChildAt(i); 13 final Rect bounds = mRecyclerView.mTempRect; 14 getDecoratedBoundsWithMargins(child, bounds); 15 if (bounds.left \u0026lt; minX) { 16 minX = bounds.left; 17 } 18 if (bounds.right \u0026gt; maxX) { 19 maxX = bounds.right; 20 } 21 if (bounds.top \u0026lt; minY) { 22 minY = bounds.top; 23 } 24 if (bounds.bottom \u0026gt; maxY) { 25 maxY = bounds.bottom; 26 } 27 } 28 mRecyclerView.mTempRect.set(minX, minY, maxX, maxY); 29 setMeasuredDimension(mRecyclerView.mTempRect, widthSpec, heightSpec); 30} 主要是通过这个方法测量子控件叠加的高度，方法居然给我是私有的，没办法继承，不然我就直接控制循环数量了。转而求其次，实现setMeasuredDimension方法\n1public static class MaxCountLayoutManager extends LinearLayoutManager { 2 private int maxCount = -1; 3 public MaxCountLayoutManager(Context context) { 4 super(context); 5 } 6 public MaxCountLayoutManager(Context context, int orientation, boolean reverseLayout) { 7 super(context, orientation, reverseLayout); 8 } 9 public MaxCountLayoutManager(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) { 10 super(context, attrs, defStyleAttr, defStyleRes); 11 } 12 public void setMaxCount(int maxCount) { 13 this.maxCount = maxCount; 14 } 15 @Override 16 public void setMeasuredDimension(int widthSize, int heightSize) { 17 int maxHeight = getMaxHeight(); 18 if (maxHeight\u0026gt;0\u0026amp;\u0026amp;maxHeight\u0026lt;heightSize){ 19 super.setMeasuredDimension(widthSize, maxHeight); 20 }else { 21 super.setMeasuredDimension(widthSize, heightSize); 22 } 23 } 24 private int getMaxHeight() { 25 if (getChildCount() == 0||maxCount\u0026lt;=0) { 26 return 0; 27 } 28 View child = getChildAt(0); 29 int height = child.getHeight(); 30 final LayoutParams lp = (LayoutParams) child.getLayoutParams(); 31 height += lp.topMargin + lp.bottomMargin; 32 return height*maxCount+getPaddingBottom()+getPaddingTop(); 33 } 34} 哈哈，是不是超级简单，具体用法\n1recyclerView.layoutManager = MaxHeightRecyclerView.MaxCountLayoutManager(context).apply { setMaxCount(5) } ","date":"2020-05-08","img":"","permalink":"https://helixs.github.io/posts/2020-05-08-android_recyclerview%E8%AE%BE%E7%BD%AE%E6%9C%80%E5%A4%A7%E6%95%B0%E9%87%8F%E9%AB%98%E5%BA%A6/","series":null,"tags":null,"title":"Android_RecyclerView设置最大数量高度"},{"categories":["Android开发","源码分析","编程生活"],"content":"Retrofit 是原Square 大神JakeWharton 面向Android和Java平台的http客户端。\n那么我们常用的Retrofit+Okhttp的关系是什么呢？其实Retrofit需要依赖Okhttp，就如同Okhttp依赖OkIO一样，Retrofit当使用Http请求时候方面了我们的结构化配置。\nOkhttp：\nAndroid为我们提供了两种HTTP交互的方式：HttpURLConnection和Apache HTTP Client（ Android 6.0——API 23已经不支持该方式了 ），虽然两者都支持HTTPS，流的上传和下载，配置超时IPv6和连接池，已足够满足我们各种HTTP请求的需求。但更高效的使用HTTP可以让我们的应用运行更快、更节省流量。这就诞生了Okhttp及Retrofit等HTTP库。OKHttp是一款高效的HTTP库，支持连接同一地址的链接共享同一个socket，通过连接池来减小响应延迟，还有透明的GZIP压缩，请求缓存等优势。OkHttp存在以下的特点：\n  支持HTTP2/SPDY socket自动选择最好路线，并支持自动重连 拥有自动维护的socket连接池，减少握手次数 拥有队列线程池，轻松写并发 拥有Interceptors轻松处理请求与响应（比如透明GZIP压缩,LOGGING） 基于Headers的缓存策略   Retrofit:retrofit就是对okhttp做了一层封装。把网络请求都交给给了Okhttp，我们只需要通过简单的配置就能使用retrofit来进行网络请求了。Retrofit框架存在的优势：\n  Retrofit使用注解方式，大大简化了我们的URL拼写形式，而且注解含义一目了然，简单易懂； Retrofit使用简单，结构层次分明，每一步都能清晰的表达出之所以要使用的寓意； Retrofit支持同步和异步执行，使得请求变得异常简单，只要调用enqueue/execute即可完成； Retrofit更大自由度的支持我们自定义的业务逻辑，如自定义Converters。 Retrofit支持多种文件解析(Gson,Json,XML,Protobuf) Retrofit支持RxJava   我们来看如何使用\n基于com.squareup.retrofit2:retrofit:2.8.1.\n1//1 2public interface GitHubService { 3 @GET(\u0026#34;users/{user}/repos\u0026#34;) 4 Call\u0026lt;List\u0026lt;Repo\u0026gt;\u0026gt; listRepos(@Path(\u0026#34;user\u0026#34;) String user); 5} 6//2 7Retrofit retrofit = new Retrofit.Builder() 8 .baseUrl(\u0026#34;https://api.github.com/\u0026#34;) 9 .build(); 10GitHubService service = retrofit.create(GitHubService.class); 11//3 12Call\u0026lt;List\u0026lt;Repo\u0026gt;\u0026gt; repos = service.listRepos(\u0026#34;octocat\u0026#34;); 13//callback为异步回调 14repos.enqueue(callBack); 15 看到没，是不是很方便呢，我们只需配置一个baseUrl，放置一个接口配置清单，我们就可以进行简单的网络请求了。\n分析源码\n下面这张图是Retrofit常用依赖包\nadapter和converter根据自己实际情况进行调整\n看看retrofit的东西，哟，不是很多，说明我们看它更加容易\nhttp下面都是一堆注解，什么http方法 HEAD QUERY 等等非常丰富，retrofit运行过程中会反射获取这些类型再进行合理的封装。\n看看Retrofit中的成员变量\n1public final class Retrofit { 2 //一个核心集合类 通过ConcurrentHashMap线程安全 来包装 网络请求配置对象和存储网络请求相关的配置， 3 // 如网络请求的方法、数据转换器、网络请求适配器、网络请求工厂、基地址等 4 private final Map\u0026lt;Method, ServiceMethod\u0026lt;?\u0026gt;\u0026gt; serviceMethodCache = new ConcurrentHashMap\u0026lt;\u0026gt;(); 5 //网络请求工厂 默认为 OkHttpClient 用来获取Call 6 final okhttp3.Call.Factory callFactory; 7 // okHttp HttpUrl 8 final HttpUrl baseUrl; 9 // 数据转换器工厂的集合 比如发送一个请求如何将一段map集合转为requestBody对象 10 //又如如何将一段response的Json转为我们需要的Response实体类都是通过它 11 // 如果我们需要封装返回值的时候我们都可能要自定义 12 final List\u0026lt;Converter.Factory\u0026gt; converterFactories; 13 //网络请求适配器工厂的集合，默认是DefaultCallAdapterFactory jdk8平台还会增加CompletableFutureCallAdapterFactory 14 final List\u0026lt;CallAdapter.Factory\u0026gt; callAdapterFactories; 15 //回调函数执行器人 在Android默认是 MainThreadExecutor 通过MainLooper Handler send msg 16 final @Nullable Executor callbackExecutor; 17 //一个开关，为true则会缓存创建的ServiceMethod 18 final boolean validateEagerly; 19 Retrofit(okhttp3.Call.Factory callFactory, HttpUrl baseUrl, 20 List\u0026lt;Converter.Factory\u0026gt; converterFactories, List\u0026lt;CallAdapter.Factory\u0026gt; callAdapterFactories, 21 @Nullable Executor callbackExecutor, boolean validateEagerly) { 22 this.callFactory = callFactory; 23 this.baseUrl = baseUrl; 24 this.converterFactories = converterFactories; // Copy+unmodifiable at call site. 25 this.callAdapterFactories = callAdapterFactories; // Copy+unmodifiable at call site. 26 this.callbackExecutor = callbackExecutor; 27 this.validateEagerly = validateEagerly; 28 } 29} Retrofit的Builder模式初始化\n1 public static final class Builder { 2 private final Platform platform; 3 private @Nullable okhttp3.Call.Factory callFactory; 4 private @Nullable HttpUrl baseUrl; 5 private final List\u0026lt;Converter.Factory\u0026gt; converterFactories = new ArrayList\u0026lt;\u0026gt;(); 6 private final List\u0026lt;CallAdapter.Factory\u0026gt; callAdapterFactories = new ArrayList\u0026lt;\u0026gt;(); 7 private @Nullable Executor callbackExecutor; 8 private boolean validateEagerly; 9 Builder(Platform platform) { 10 this.platform = platform; 11 } 12 public Builder() { 13 this(Platform.get());//1 14 } 15} 16//.... 17public Retrofit build() { 18 if (baseUrl == null) { 19 throw new IllegalStateException(\u0026#34;Base URL required.\u0026#34;); 20 } 21 okhttp3.Call.Factory callFactory = this.callFactory; 22 if (callFactory == null) { 23 //OKHttpClient 大多数情况下我们都是通过client(xx)方法将调用对象传进入的 这也就是OkHttp和Retrofit连接的地方 24 callFactory = new OkHttpClient(); 25 } 26 Executor callbackExecutor = this.callbackExecutor; 27 if (callbackExecutor == null) { 28 //默认为Android主线程 比较简单 29 callbackExecutor = platform.defaultCallbackExecutor(); 30 } 31 // Make a defensive copy of the adapters and add the default Call adapter. 32 // 网络调用适配器工厂集合 33 List\u0026lt;CallAdapter.Factory\u0026gt; callAdapterFactories = new ArrayList\u0026lt;\u0026gt;(this.callAdapterFactories); 34 callAdapterFactories.addAll(platform.defaultCallAdapterFactories(callbackExecutor)); 35 // Make a defensive copy of the converters. 36 //转换器工厂 37 List\u0026lt;Converter.Factory\u0026gt; converterFactories = new ArrayList\u0026lt;\u0026gt;( 38 1 + this.converterFactories.size() + platform.defaultConverterFactoriesSize()); 39 // Add the built-in converter factory first. This prevents overriding its behavior but also 40 // ensures correct behavior when using converters that consume all types. 41 //默认添加了BuiltInConverters内部转换器 如果它返回的转换器不是空的 那么就使用后面的 42 converterFactories.add(new BuiltInConverters()); 43 converterFactories.addAll(this.converterFactories); 44 converterFactories.addAll(platform.defaultConverterFactories());//2 45 return new Retrofit(callFactory, baseUrl, unmodifiableList(converterFactories), 46 unmodifiableList(callAdapterFactories), callbackExecutor, validateEagerly); 47 } 在1和2中我们看到了使用平台\n1/* 2* Copyright (C) 2013 Square, Inc. 3* 4* Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); 5* you may not use this file except in compliance with the License. 6* You may obtain a copy of the License at 7* 8* http://www.apache.org/licenses/LICENSE-2.0 9* 10* Unless required by applicable law or agreed to in writing, software 11* distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, 12* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 13* See the License for the specific language governing permissions and 14* limitations under the License. 15*/ 16package com.rta.common.http; 17import android.os.Build; 18import android.os.Handler; 19import android.os.Looper; 20import java.lang.invoke.MethodHandles; 21import java.lang.invoke.MethodHandles.Lookup; 22import java.lang.reflect.Constructor; 23import java.lang.reflect.Method; 24import java.util.List; 25import java.util.concurrent.Executor; 26import javax.annotation.Nullable; 27import retrofit2.CallAdapter; 28import retrofit2.CompletableFutureCallAdapterFactory; 29import retrofit2.Converter; 30import retrofit2.DefaultCallAdapterFactory; 31import retrofit2.OptionalConverterFactory; 32import static java.util.Arrays.asList; 33import static java.util.Collections.emptyList; 34import static java.util.Collections.singletonList; 35class Platform { 36 private static final Platform PLATFORM = findPlatform(); 37 static Platform get() { 38 return PLATFORM; 39 } 40 private static Platform findPlatform() { 41 try { 42 //当前平台是不是Android平台 43 Class.forName(\u0026#34;android.os.Build\u0026#34;); 44 if (Build.VERSION.SDK_INT != 0) { 45 return new Android(); 46 } 47 } catch (ClassNotFoundException ignored) { 48 } 49 //如果不是 那么就默认是Java8平台 所以尽量在JDK8以上使用它 50 return new Platform(true); 51 } 52 private final boolean hasJava8Types; 53 private final @Nullable Constructor\u0026lt;Lookup\u0026gt; lookupConstructor; 54 Platform(boolean hasJava8Types) { 55 this.hasJava8Types = hasJava8Types; 56 Constructor\u0026lt;Lookup\u0026gt; lookupConstructor = null; 57 if (hasJava8Types) { 58 try { 59 // Because the service interface might not be public, we need to use a MethodHandle lookup 60 // that ignores the visibility of the declaringClass. 61 // JAVA 7+ 通过 MethodHandles和Lookup 能够比反射实现更快的方法查找和调用 因为他们不是通过动态解析类型 而是通过JAVA字节码虚拟机层实现 62 lookupConstructor = Lookup.class.getDeclaredConstructor(Class.class, int.class); 63 lookupConstructor.setAccessible(true); 64 } catch (NoClassDefFoundError ignored) { 65 //24和25可能没有这个类 66 // Android API 24 or 25 where Lookup doesn\u0026#39;t exist. Calling default methods on non-public 67 // interfaces will fail, but there\u0026#39;s nothing we can do about it. 68 } catch (NoSuchMethodException ignored) { 69 // Assume JDK 14+ which contains a fix that allows a regular lookup to succeed. 70 // See https://bugs.openjdk.java.net/browse/JDK-8209005. 71 } 72 } 73 this.lookupConstructor = lookupConstructor; 74 } 75 @Nullable Executor defaultCallbackExecutor() { 76 return null; 77 } 78 List\u0026lt;? extends CallAdapter.Factory\u0026gt; defaultCallAdapterFactories( 79 @Nullable Executor callbackExecutor) { 80 DefaultCallAdapterFactory executorFactory = new DefaultCallAdapterFactory(callbackExecutor); 81 return hasJava8Types 82 ? asList(CompletableFutureCallAdapterFactory.INSTANCE, executorFactory) 83 : singletonList(executorFactory); 84 } 85 int defaultCallAdapterFactoriesSize() { 86 return hasJava8Types ? 2 : 1; 87 } 88 List\u0026lt;? extends Converter.Factory\u0026gt; defaultConverterFactories() { 89 //java8 增加了Optional这个包装类型 它的主要功能是存放类型T的东西 可以放Null 说白了 就是空值安全的一种方式 90 return hasJava8Types 91 ? singletonList(OptionalConverterFactory.INSTANCE) 92 : emptyList(); 93 } 94 int defaultConverterFactoriesSize() { 95 return hasJava8Types ? 1 : 0; 96 } 97 boolean isDefaultMethod(Method method) { 98 //检查这个方法是不是接口的默认方法(java8 增加了默认方法) 99 return hasJava8Types \u0026amp;\u0026amp; method.isDefault(); 100 } 101 @Nullable Object invokeDefaultMethod(Method method, Class\u0026lt;?\u0026gt; declaringClass, Object object, 102 @Nullable Object... args) throws Throwable { 103 //调用默认方法 一般情况下我们都不需要这个 104 //平台初始化的时候检查了是否有了有了Lookup(Class.class, int.class)这个构造方法 105 //如果有就按照当前的构造方法实例这个Lookup，如果没有这个就按照MethodHandles.lookup()的方式创建 106 Lookup lookup = lookupConstructor != null 107 ? lookupConstructor.newInstance(declaringClass, -1 /* trusted */) 108 : MethodHandles.lookup(); 109 //lookup.unreflectSpecial为method生成一个MethodHandle然后bind到object这个对象，最后通过invokeWithArguments调用方法 110 return lookup 111 .unreflectSpecial(method, declaringClass) 112 .bindTo(object) 113 .invokeWithArguments(args); 114 } 115 static final class Android extends Platform { 116 Android() { 117 super(Build.VERSION.SDK_INT \u0026gt;= 24); 118 } 119 @Override public Executor defaultCallbackExecutor() { 120 return new MainThreadExecutor(); 121 } 122 @Nullable @Override Object invokeDefaultMethod(Method method, Class\u0026lt;?\u0026gt; declaringClass, 123 Object object, @Nullable Object... args) throws Throwable { 124 //API26以下并不支持默认方法 125 if (Build.VERSION.SDK_INT \u0026lt; 26) { 126 throw new UnsupportedOperationException( 127 \u0026#34;Calling default methods on API 24 and 25 is not supported\u0026#34;); 128 } 129 return super.invokeDefaultMethod(method, declaringClass, object, args); 130 } 131 static final class MainThreadExecutor implements Executor { 132 private final Handler handler = new Handler(Looper.getMainLooper()); 133 @Override public void execute(Runnable r) { 134 handler.post(r); 135 } 136 } 137 } 138} Platform里面的东西其实不多，就是Callback的执行器和一些跟JAVA8特性相关，跟Retrofit核心关系不是很大。\ncreateSerivce\n1@SuppressWarnings(\u0026#34;unchecked\u0026#34;) // Single-interface proxy creation guarded by parameter safety. 2 public \u0026lt;T\u0026gt; T create(final Class\u0026lt;T\u0026gt; service) { 3 //检查服务接口 4 validateServiceInterface(service); 5 //动态代理模式 不然需要们一个个的实现interface中的方法了 有它就是666 这也是retrofit那么6的原因 6 return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class\u0026lt;?\u0026gt;[]{service}, 7 new InvocationHandler() { 8 private final Platform platform = Platform.get(); 9 private final Object[] emptyArgs = new Object[0]; 10 @Override 11 public @Nullable 12 Object invoke(Object proxy, Method method, 13 @Nullable Object[] args) throws Throwable { 14 //每次我们调用一个interface中的一个方法都需要进入这里面 15 // If the method is a method from Object then defer to normal invocation. 16 if (method.getDeclaringClass() == Object.class) { 17 //始终想不通什么情况下会进入这里面 毕竟 validateServiceInterface()已经判断过了 18 return method.invoke(this, args); 19 } 20 if (platform.isDefaultMethod(method)) { 21 //前面说的默认方法 java8+ 22 return platform.invokeDefaultMethod(method, service, proxy, args); 23 } 24 //大部分情况我们都是进入这里 25 return loadServiceMethod(method).invoke(args != null ? args : emptyArgs); 26 } 27 }); 28 } 29 private void validateServiceInterface(Class\u0026lt;?\u0026gt; service) { 30 //这个玩意儿到底是不是个Interface 31 if (!service.isInterface()) { 32 throw new IllegalArgumentException(\u0026#34;API declarations must be interfaces.\u0026#34;); 33 } 34 //创建一个双端队列 存放检查中的interface 默认容量是1 35 Deque\u0026lt;Class\u0026lt;?\u0026gt;\u0026gt; check = new ArrayDeque\u0026lt;\u0026gt;(1); 36 check.add(service); 37 //开启循环检查interface和interface的父类们 38 while (!check.isEmpty()) { 39 //即将检查这儿interface 先从队列中去掉 40 Class\u0026lt;?\u0026gt; candidate = check.removeFirst(); 41 if (candidate.getTypeParameters().length != 0) { 42 //获取Class类中声明的泛型数量 如果有泛型数量就报错 43 StringBuilder message = new StringBuilder(\u0026#34;Type parameters are unsupported on \u0026#34;) 44 .append(candidate.getName()); 45 if (candidate != service) { 46 message.append(\u0026#34; which is an interface of \u0026#34;) 47 .append(service.getName()); 48 } 49 throw new IllegalArgumentException(message.toString()); 50 } 51 // 52 Collections.addAll(check, candidate.getInterfaces()); 53 } 54 //如果需要极速验证通过，会提前缓存所有合法的ServiceMethod到serviceMethodCache，以提高访问性能， 55 //不然就访问一个缓存一个 56 //反射需要消耗时间性能 请酌情选用 57 if (validateEagerly) { 58 Platform platform = Platform.get(); 59 for (Method method : service.getDeclaredMethods()) { 60 //遍历interface中的所有方法 如果是默认方法和惊叹方法就不缓存了 61 if (!platform.isDefaultMethod(method) \u0026amp;\u0026amp; !Modifier.isStatic(method.getModifiers())) { 62 loadServiceMethod(method); 63 } 64 } 65 } 66 } 67 // 从缓存中获取ServiceMethod 68 // 如果没得到就解析出ServiceMethod并缓存 69 ServiceMethod\u0026lt;?\u0026gt; loadServiceMethod(Method method) { 70 ServiceMethod\u0026lt;?\u0026gt; result = serviceMethodCache.get(method); 71 if (result != null) return result; 72 synchronized (serviceMethodCache) { 73 //锁定获取插入 74 result = serviceMethodCache.get(method); 75 if (result == null) { 76 //解析方法的注解并生成ServiceMethod 77 result = ServiceMethod.parseAnnotations(this, method); 78 serviceMethodCache.put(method, result); 79 } 80 } 81 return result; 82 } 这里面用到了动态代理模式，可以学习一下。\n下面我们就来看看ServiceMethod是怎么获取的\n1abstract class ServiceMethod\u0026lt;T\u0026gt; { 2 static \u0026lt;T\u0026gt; ServiceMethod\u0026lt;T\u0026gt; parseAnnotations(Retrofit retrofit, Method method) { 3 //1 解析注解配置（工厂模式、内部使用了建造者模式） 4 //返回RequestFactory处理工厂，包含了对注释的各种处理操作，转换等等 5 RequestFactory requestFactory = RequestFactory.parseAnnRequestFactoryotations(retrofit, method); 6 7 Type returnType = method.getGenericReturnType(); 8 if (Utils.hasUnresolvableType(returnType)) { 9 throw methodError(method, 10 \u0026#34;Method return type must not include a type variable or wildcard: %s\u0026#34;, returnType); 11 } 12 if (returnType == void.class) { 13 throw methodError(method, \u0026#34;Service methods cannot return void.\u0026#34;); 14 } 15 //2最终是通过HttpServiceMethod构建的请求方法 16 return HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory); 17 } 18 abstract @Nullable 19 T invoke(Object[] args); 20} 1、RequestFactory\n1final class RequestFactory { 2 static RequestFactory parseAnnotations(Retrofit retrofit, Method method) { 3 //builder模式 4 return new Builder(retrofit, method).build(); 5 } 6//外部通过调用create方法 args参数通过ParameterHandler处理 最后转换成一个OkHttpRequest 7okhttp3.Request create(Object[] args) throws IOException { 8 @SuppressWarnings(\u0026#34;unchecked\u0026#34;) // It is an error to invoke a method with the wrong arg types. 9 ParameterHandler\u0026lt;Object\u0026gt;[] handlers = (ParameterHandler\u0026lt;Object\u0026gt;[]) parameterHandlers; 10 int argumentCount = args.length; 11 if (argumentCount != handlers.length) { 12 throw new IllegalArgumentException(\u0026#34;Argument count (\u0026#34; + argumentCount 13 + \u0026#34;) doesn\u0026#39;t match expected count (\u0026#34; + handlers.length + \u0026#34;)\u0026#34;); 14 } 15 RequestBuilder requestBuilder = new RequestBuilder(httpMethod, baseUrl, relativeUrl, 16 headers, contentType, hasBody, isFormEncoded, isMultipart); 17 if (isKotlinSuspendFunction) { 18 // The Continuation is the last parameter and the handlers array contains null at that index. 19 argumentCount--; 20 } 21 List\u0026lt;Object\u0026gt; argumentList = new ArrayList\u0026lt;\u0026gt;(argumentCount); 22 for (int p = 0; p \u0026lt; argumentCount; p++) { 23 argumentList.add(args[p]); 24 handlers[p].apply(requestBuilder, args[p]); 25 } 26 return requestBuilder.get() 27 .tag(Invocation.class, new Invocation(method, argumentList)) 28 .build(); 29} 30 static final class Builder { 31 .... 32 RequestFactory build() { 33 for (Annotation annotation : methodAnnotations) { 34 //循环解析方法注释 35 parseMethodAnnotation(annotation); 36 } 37 if (httpMethod == null) { 38 throw methodError(method, \u0026#34;HTTP method annotation is required (e.g., @GET, @POST, etc.).\u0026#34;); 39 } 40 if (!hasBody) { 41 if (isMultipart) { 42 throw methodError(method, 43 \u0026#34;Multipart can only be specified on HTTP methods with request body (e.g., @POST).\u0026#34;); 44 } 45 if (isFormEncoded) { 46 throw methodError(method, \u0026#34;FormUrlEncoded can only be specified on HTTP methods with \u0026#34; 47 + \u0026#34;request body (e.g., @POST).\u0026#34;); 48 } 49 } 50 //参数注解的数量 51 int parameterCount = parameterAnnotationsArray.length; 52 parameterHandlers = new ParameterHandler\u0026lt;?\u0026gt;[parameterCount]; 53 for (int p = 0, lastParameter = parameterCount - 1; p \u0026lt; parameterCount; p++) { 54 //解析参数 并对每个参数生成 ParameterHandler处理对象 55 parameterHandlers[p] = 56 parseParameter(p, parameterTypes[p], parameterAnnotationsArray[p], p == lastParameter); 57 } 58 if (relativeUrl == null \u0026amp;\u0026amp; !gotUrl) { 59 throw methodError(method, \u0026#34;Missing either @%s URL or @Url parameter.\u0026#34;, httpMethod); 60 } 61 if (!isFormEncoded \u0026amp;\u0026amp; !isMultipart \u0026amp;\u0026amp; !hasBody \u0026amp;\u0026amp; gotBody) { 62 throw methodError(method, \u0026#34;Non-body HTTP method cannot contain @Body.\u0026#34;); 63 } 64 if (isFormEncoded \u0026amp;\u0026amp; !gotField) { 65 throw methodError(method, \u0026#34;Form-encoded method must contain at least one @Field.\u0026#34;); 66 } 67 if (isMultipart \u0026amp;\u0026amp; !gotPart) { 68 throw methodError(method, \u0026#34;Multipart method must contain at least one @Part.\u0026#34;); 69 } 70 return new RequestFactory(this); 71 } 72 private void parseMethodAnnotation(Annotation annotation) { 73 //方法上面的注释 比如http请求的各种方法及Heads等 Multipart多文件 表单等 74 if (annotation instanceof DELETE) { 75 parseHttpMethodAndPath(\u0026#34;DELETE\u0026#34;, ((DELETE) annotation).value(), false); 76 } else if (annotation instanceof GET) { 77 parseHttpMethodAndPath(\u0026#34;GET\u0026#34;, ((GET) annotation).value(), false); 78 } else if (annotation instanceof HEAD) { 79 parseHttpMethodAndPath(\u0026#34;HEAD\u0026#34;, ((HEAD) annotation).value(), false); 80 } else if (annotation instanceof PATCH) { 81 parseHttpMethodAndPath(\u0026#34;PATCH\u0026#34;, ((PATCH) annotation).value(), true); 82 } else if (annotation instanceof POST) { 83 parseHttpMethodAndPath(\u0026#34;POST\u0026#34;, ((POST) annotation).value(), true); 84 } else if (annotation instanceof PUT) { 85 parseHttpMethodAndPath(\u0026#34;PUT\u0026#34;, ((PUT) annotation).value(), true); 86 } else if (annotation instanceof OPTIONS) { 87 parseHttpMethodAndPath(\u0026#34;OPTIONS\u0026#34;, ((OPTIONS) annotation).value(), false); 88 } else if (annotation instanceof HTTP) { 89 HTTP http = (HTTP) annotation; 90 parseHttpMethodAndPath(http.method(), http.path(), http.hasBody()); 91 } else if (annotation instanceof retrofit2.http.Headers) { 92 String[] headersToParse = ((retrofit2.http.Headers) annotation).value(); 93 if (headersToParse.length == 0) { 94 throw methodError(method, \u0026#34;@Headers annotation is empty.\u0026#34;); 95 } 96 headers = parseHeaders(headersToParse); 97 } else if (annotation instanceof Multipart) { 98 if (isFormEncoded) { 99 throw methodError(method, \u0026#34;Only one encoding annotation is allowed.\u0026#34;); 100 } 101 isMultipart = true; 102 } else if (annotation instanceof FormUrlEncoded) { 103 if (isMultipart) { 104 throw methodError(method, \u0026#34;Only one encoding annotation is allowed.\u0026#34;); 105 } 106 isFormEncoded = true; 107 } 108 } 109private void parseHttpMethodAndPath(String httpMethod, String value, boolean hasBody) { 110 if (this.httpMethod != null) { 111 throw methodError(method, \u0026#34;Only one HTTP method is allowed. Found: %s and %s.\u0026#34;, 112 this.httpMethod, httpMethod); 113 } 114 this.httpMethod = httpMethod; 115 this.hasBody = hasBody; 116 if (value.isEmpty()) { 117 return; 118 } 119 // Get the relative URL path and existing query string, if present. 120 //读取并判断接口地址 121 int question = value.indexOf(\u0026#39;?\u0026#39;); 122 if (question != -1 \u0026amp;\u0026amp; question \u0026lt; value.length() - 1) { 123 // Ensure the query string does not have any named parameters. 124 //确保查询字符串没有任何命名参数。 125 //提示一下retrofit是支持命名参数的不过不是?后面的query参数 而是/{xxxx}/路径下 然后在params中通过@Path(\u0026#34;...\u0026#34;)动态设置 126 //如果需要query请在params中使用@Query(\u0026#34;xxx\u0026#34;)或者@QueryMap 127 String queryParams = value.substring(question + 1); 128 Matcher queryParamMatcher = PARAM_URL_REGEX.matcher(queryParams); 129 if (queryParamMatcher.find()) { 130 throw methodError(method, \u0026#34;URL query string \\\u0026#34;%s\\\u0026#34; must not have replace block. \u0026#34; 131 + \u0026#34;For dynamic query parameters use @Query.\u0026#34;, queryParams); 132 } 133 } 134 //相对路径 135 this.relativeUrl = value; 136 //相对路径中的命名参数如/{path}/ 返回的是Set集合 137 this.relativeUrlParamNames = parsePathParameters(value); 138 } 139 private @Nullable ParameterHandler\u0026lt;?\u0026gt; parseParameter( 140 int p, Type parameterType, @Nullable Annotation[] annotations, boolean allowContinuation) { 141 ParameterHandler\u0026lt;?\u0026gt; result = null; 142 if (annotations != null) { 143 for (Annotation annotation : annotations) { 144 //循环解析参数上面的注释 代码较多 但是不难理解 就不贴出来了 145 //他们会针对参数的 类型、注释 生成不同的ParameterHandler实现类 146 //ParameterHandler中有可能包含了每个注解的参数转string的stringConvert 如果没有构造器实现stringConvert 用的是toString了 147 ParameterHandler\u0026lt;?\u0026gt; annotationAction = 148 parseParameterAnnotation(p, parameterType, annotations, annotation); 149 if (annotationAction == null) { 150 continue; 151 } 152 //每个参数只允许一个有效的Retrofit注释 153 if (result != null) { 154 throw parameterError(method, p, 155 \u0026#34;Multiple Retrofit annotations found, only one allowed.\u0026#34;); 156 } 157 result = annotationAction; 158 } 159 } 160 if (result == null) { 161 if (allowContinuation) { 162 try { 163 if (Utils.getRawType(parameterType) == Continuation.class) { 164 isKotlinSuspendFunction = true; 165 return null; 166 } 167 } catch (NoClassDefFoundError ignored) { 168 } 169 } 170 throw parameterError(method, p, \u0026#34;No Retrofit annotation found.\u0026#34;); 171 } 172 return result; 173 } 174 } 175} 176 2、HttpServiceMethod\n我们生成了RequestFactory后就马上调用了 HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory);\n1static \u0026lt;ResponseT, ReturnT\u0026gt; HttpServiceMethod\u0026lt;ResponseT, ReturnT\u0026gt; parseAnnotations( 2 Retrofit retrofit, Method method, retrofit2.RequestFactory requestFactory) { 3 boolean isKotlinSuspendFunction = requestFactory.isKotlinSuspendFunction; 4 boolean continuationWantsResponse = false; 5 boolean continuationBodyNullable = false; 6 Annotation[] annotations = method.getAnnotations(); 7 Type adapterType; 8 if (isKotlinSuspendFunction) { 9 //如果是kotlin协程的挂起函数 通过协程我们可以解决掉万恶的回调了 暂时不多说 10 Type[] parameterTypes = method.getGenericParameterTypes(); 11 Type responseType = Utils.getParameterLowerBound(0, 12 (ParameterizedType) parameterTypes[parameterTypes.length - 1]); 13 if (getRawType(responseType) == Response.class \u0026amp;\u0026amp; responseType instanceof ParameterizedType) { 14 // Unwrap the actual body type from Response\u0026lt;T\u0026gt;. 15 responseType = Utils.getParameterUpperBound(0, (ParameterizedType) responseType); 16 continuationWantsResponse = true; 17 } else { 18 // TODO figure out if type is nullable or not 19 // Metadata metadata = method.getDeclaringClass().getAnnotation(Metadata.class) 20 // Find the entry for method 21 // Determine if return type is nullable or not 22 } 23 adapterType = new Utils.ParameterizedTypeImpl(null, Call.class, responseType); 24 annotations = SkipCallbackExecutorImpl.ensurePresent(annotations); 25 } else { 26 adapterType = method.getGenericReturnType(); 27 } 28 //1 根据网络请求接口方法的返回值和注解类型， 29 //返回一个合适的调用适配器 在retrofit初始化的时候配置的那些 30 CallAdapter\u0026lt;ResponseT, ReturnT\u0026gt; callAdapter = 31 createCallAdapter(retrofit, method, adapterType, annotations); 32 Type responseType = callAdapter.responseType(); 33 if (responseType == okhttp3.Response.class) { 34 throw methodError(method, \u0026#34;\u0026#39;\u0026#34; 35 + getRawType(responseType).getName() 36 + \u0026#34;\u0026#39; is not a valid response body type. Did you mean ResponseBody?\u0026#34;); 37 } 38 if (responseType == Response.class) { 39 throw methodError(method, \u0026#34;Response must include generic type (e.g., Response\u0026lt;String\u0026gt;)\u0026#34;); 40 } 41 // TODO support Unit for Kotlin? 42 if (requestFactory.httpMethod.equals(\u0026#34;HEAD\u0026#34;) \u0026amp;\u0026amp; !Void.class.equals(responseType)) { 43 throw methodError(method, \u0026#34;HEAD method must use Void as response type.\u0026#34;); 44 } 45 //根据返回类型和注释 在ConvertFactorys中找到到一个Response转换器 46 Converter\u0026lt;ResponseBody, ResponseT\u0026gt; responseConverter = 47 createResponseConverter(retrofit, method, responseType); 48 okhttp3.Call.Factory callFactory = retrofit.callFactory; 49 if (!isKotlinSuspendFunction) { 50 //然后把这些参数都传进去 创建一个HttpServiceMethod的子类 51 return new CallAdapted\u0026lt;\u0026gt;(requestFactory, callFactory, responseConverter, callAdapter); 52 } else if (continuationWantsResponse) { 53 //noinspection unchecked Kotlin compiler guarantees ReturnT to be Object. 54 return (HttpServiceMethod\u0026lt;ResponseT, ReturnT\u0026gt;) new SuspendForResponse\u0026lt;\u0026gt;(requestFactory, 55 callFactory, responseConverter, (CallAdapter\u0026lt;ResponseT, Call\u0026lt;ResponseT\u0026gt;\u0026gt;) callAdapter); 56 } else { 57 //noinspection unchecked Kotlin compiler guarantees ReturnT to be Object. 58 return (HttpServiceMethod\u0026lt;ResponseT, ReturnT\u0026gt;) new SuspendForBody\u0026lt;\u0026gt;(requestFactory, 59 callFactory, responseConverter, (CallAdapter\u0026lt;ResponseT, Call\u0026lt;ResponseT\u0026gt;\u0026gt;) callAdapter, 60 continuationBodyNullable); 61 } 62 } 63 在1中createCallAdapter最终遍历callAdapaterFactorys 获取合适的Adapter ，比如获取的是DefautCallFactory\n1final class DefaultCallAdapterFactory extends CallAdapter.Factory { 2 private final @Nullable Executor callbackExecutor; 3 private CallAdapter.Factory Utils; 4 DefaultCallAdapterFactory(@Nullable Executor callbackExecutor) { 5 this.callbackExecutor = callbackExecutor; 6 } 7 @Override public @Nullable CallAdapter\u0026lt;?, ?\u0026gt; get( 8 Type returnType, Annotation[] annotations, Retrofit retrofit) { 9 //如果不是返回的Call类型 直接不采用 10 if (getRawType(returnType) != Call.class) { 11 return null; 12 } 13 if (!(returnType instanceof ParameterizedType)) { 14 throw new IllegalArgumentException( 15 \u0026#34;Call return type must be parameterized as Call\u0026lt;Foo\u0026gt; or Call\u0026lt;? extends Foo\u0026gt;\u0026#34;); 16 } 17 final Type responseType = Utils.getParameterUpperBound(0, (ParameterizedType) returnType); 18 final Executor executor = Utils.isAnnotationPresent(annotations, SkipCallbackExecutor.class) 19 ? null 20 : callbackExecutor; 21 //返回CallAdapter CallAdapter是真正的网络调用者 比如调用OkHttpCall对象 22 //比如返回的ExecutorCallbackCall就是一个代理对象，调用enqueue 实际上还是会调用OkHttpCall.enqueue 23 //并且回调函数也是通过这个触发 executor为Android调用主线程 24 return new CallAdapter\u0026lt;Object, Call\u0026lt;?\u0026gt;\u0026gt;() { 25 @Override public Type responseType() { 26 return responseType; 27 } 28 @Override public Call\u0026lt;Object\u0026gt; adapt(Call\u0026lt;Object\u0026gt; call) { 29 //如果需要callback切换线程就是稍微包装一下 30 return executor == null 31 ? call 32 : new ExecutorCallbackCall\u0026lt;\u0026gt;(executor, call); 33 } 34 }; 35 } 36} 1//最后通过invoke 生成interface方法中的返回对象 通过传入的callFactory进行连接OkHttp 2//也就是Proxy代理中的invoke方法 3 @Override final @Nullable ReturnT invoke(Object[] args) { 4 Call\u0026lt;ResponseT\u0026gt; call = new OkHttpCall\u0026lt;\u0026gt;(requestFactory, args, callFactory, responseConverter); 5 return adapt(call, args); 6 } 7 最终不管是Call对象还是RxJava的Obserable对象都通过它获取了，进入最后的调用过程，拿默认的ExecutorCallbackCall来说\n1static final class ExecutorCallbackCall\u0026lt;T\u0026gt; implements Call\u0026lt;T\u0026gt; { 2 final Executor callbackExecutor; 3 final Call\u0026lt;T\u0026gt; delegate; 4 ExecutorCallbackCall(Executor callbackExecutor, Call\u0026lt;T\u0026gt; delegate) { 5 this.callbackExecutor = callbackExecutor; 6 this.delegate = delegate; 7 } 8 @Override public void enqueue(final Callback\u0026lt;T\u0026gt; callback) { 9 Objects.requireNonNull(callback, \u0026#34;callback == null\u0026#34;); 10 delegate.enqueue(new Callback\u0026lt;T\u0026gt;() { 11 @Override public void onResponse(Call\u0026lt;T\u0026gt; call, final Response\u0026lt;T\u0026gt; response) { 12 callbackExecutor.execute(() -\u0026gt; { 13 if (delegate.isCanceled()) { 14 // Emulate OkHttp\u0026#39;s behavior of throwing/delivering an IOException on cancellation. 15 callback.onFailure(ExecutorCallbackCall.this, new IOException(\u0026#34;Canceled\u0026#34;)); 16 } else { 17 callback.onResponse(ExecutorCallbackCall.this, response); 18 } 19 }); 20 } 21 @Override public void onFailure(Call\u0026lt;T\u0026gt; call, final Throwable t) { 22 callbackExecutor.execute(() -\u0026gt; callback.onFailure(ExecutorCallbackCall.this, t)); 23 } 24 }); 25 } 26 @Override public boolean isExecuted() { 27 return delegate.isExecuted(); 28 } 29 @Override public Response\u0026lt;T\u0026gt; execute() throws IOException { 30 return delegate.execute(); 31 } 32} 33 它们最终都会进入这里，调用OkhttpCall\n1 @Override public void enqueue(final Callback\u0026lt;T\u0026gt; callback) { 2 Objects.requireNonNull(callback, \u0026#34;callback == null\u0026#34;); 3 okhttp3.Call call; 4 Throwable failure; 5 synchronized (this) { 6 if (executed) throw new IllegalStateException(\u0026#34;Already executed.\u0026#34;); 7 executed = true; 8 call = rawCall; 9 failure = creationFailure; 10 if (call == null \u0026amp;\u0026amp; failure == null) { 11 try { 12 call = rawCall = createRawCall(); 13 } catch (Throwable t) { 14 throwIfFatal(t); 15 failure = creationFailure = t; 16 } 17 } 18 } 19 if (failure != null) { 20 callback.onFailure(this, failure); 21 return; 22 } 23 if (canceled) { 24 call.cancel(); 25 } 26 call.enqueue(new okhttp3.Callback() { 27 @Override public void onResponse(okhttp3.Call call, okhttp3.Response rawResponse) { 28 Response\u0026lt;T\u0026gt; response; 29 try { 30 response = parseResponse(rawResponse); 31 } catch (Throwable e) { 32 throwIfFatal(e); 33 callFailure(e); 34 return; 35 } 36 try { 37 callback.onResponse(OkHttpCall.this, response); 38 } catch (Throwable t) { 39 throwIfFatal(t); 40 t.printStackTrace(); // TODO this is not great 41 } 42 } 43 @Override public void onFailure(okhttp3.Call call, IOException e) { 44 callFailure(e); 45 } 46 private void callFailure(Throwable e) { 47 try { 48 callback.onFailure(OkHttpCall.this, e); 49 } catch (Throwable t) { 50 throwIfFatal(t); 51 t.printStackTrace(); // TODO this is not great 52 } 53 } 54 }); 55 } 56@Override public Response\u0026lt;T\u0026gt; execute() throws IOException { 57 okhttp3.Call call; 58 synchronized (this) { 59 if (executed) throw new IllegalStateException(\u0026#34;Already executed.\u0026#34;); 60 executed = true; 61 call = getRawCall(); 62 } 63 if (canceled) { 64 call.cancel(); 65 } 66 return parseResponse(call.execute()); 67 } 68 Retrofit用了丰富的工厂用来动态的获取不同的CallAdapter和RequestConvert，ResponseConvert。代理模式生成Api实现类。反射在这里用的恰到好处。\n","date":"2020-04-26","img":"","permalink":"https://helixs.github.io/posts/2020-04-26-android%E6%BA%90%E7%A0%81%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8Bretrofit/","series":null,"tags":null,"title":"Android源码一步一步分析系列之Retrofit"},{"categories":["源码分析"],"content":"终于来到了最后一个拦截器，主要是通过上一个拦截器建立起来的连接通道通过交换机进行数据 包装发送 和 接受解包。\n  写入请求 Header 如果请求头的 Expect: 100-continue 时，只发送请求头 根据返回的结果判断是否继续请求流程 写入请求体，完成请求 得到响应头，构建初步响应 构建响应体，完成最终响应 返回响应   1/* 2* Copyright (C) 2016 Square, Inc. 3* 4* Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); 5* you may not use this file except in compliance with the License. 6* You may obtain a copy of the License at 7* 8* http://www.apache.org/licenses/LICENSE-2.0 9* 10* Unless required by applicable law or agreed to in writing, software 11* distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, 12* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 13* See the License for the specific language governing permissions and 14* limitations under the License. 15*/ 16package com.rta.rts.login.ui; 17import java.io.IOException; 18import java.net.ProtocolException; 19import okhttp3.Interceptor; 20import okhttp3.Request; 21import okhttp3.Response; 22import okhttp3.internal.Util; 23import okhttp3.internal.connection.Exchange; 24import okhttp3.internal.http.HttpMethod; 25import okhttp3.internal.http.RealInterceptorChain; 26import okio.BufferedSink; 27import okio.Okio; 28/** This is the last interceptor in the chain. It makes a network call to the server. */ 29public final class CallServerInterceptor implements Interceptor { 30 private final boolean forWebSocket; 31 public CallServerInterceptor(boolean forWebSocket) { 32 this.forWebSocket = forWebSocket; 33 } 34 @Override public Response intercept(Chain chain) throws IOException { 35 RealInterceptorChain realChain = (RealInterceptorChain) chain; 36 //这个就是在上一篇提到的交换器 37 Exchange exchange = realChain.exchange(); 38 Request request = realChain.request(); 39 //记录请求发送时间 40 long sentRequestMillis = System.currentTimeMillis(); 41 //将request中的header按照一定的格式写入到交换机的编码器中 42 exchange.writeRequestHeaders(request); 43 boolean responseHeadersStarted = false; 44 Response.Builder responseBuilder = null; 45 //检查请求方法是不是GET或者HEAD方法，因为它们并不带Body请求体。并且body不为null 46 if (HttpMethod.permitsRequestBody(request.method()) \u0026amp;\u0026amp; request.body() != null) { 47 // If there\u0026#39;s a \u0026#34;Expect: 100-continue\u0026#34; header on the request, wait for a \u0026#34;HTTP/1.1 100 48 // Continue\u0026#34; response before transmitting the request body. If we don\u0026#39;t get that, return 49 // what we did get (such as a 4xx response) without ever transmitting the request body. 50 // 关于 Expect:100-continue 可以查看 https://zhuanlan.zhihu.com/p/30830041 51 if (\u0026#34;100-continue\u0026#34;.equalsIgnoreCase(request.header(\u0026#34;Expect\u0026#34;))) { 52 //如果是100-continue 就先进行head请求，让服务器决定是否接受body的数据，根据结果进行判断是否继续 53 exchange.flushRequest(); 54 responseHeadersStarted = true; 55 exchange.responseHeadersStart(); 56 responseBuilder = exchange.readResponseHeaders(true); 57 } 58 //如果有请求体的情况 59 if (responseBuilder == null) { 60 if (request.body().isDuplex()) { 61 // Prepare a duplex body so that the application can send a request body later. 62 //双工模式 通信双方都能在同一时刻进行发送和接收操作的传送方式 63 exchange.flushRequest(); 64 BufferedSink bufferedRequestBody = Okio.buffer( 65 exchange.createRequestBody(request, true)); 66 request.body().writeTo(bufferedRequestBody); 67 } else { 68 // Write the request body if the \u0026#34;Expect: 100-continue\u0026#34; expectation was met. 69 //如果不是双工模式 70 //写入数据到 sink中 71 BufferedSink bufferedRequestBody = Okio.buffer( 72 exchange.createRequestBody(request, false)); 73 request.body().writeTo(bufferedRequestBody); 74 //关闭 75 bufferedRequestBody.close(); 76 } 77 } else { 78 exchange.noRequestBody(); 79 if (!exchange.connection().isMultiplexed()) { 80 //谁能帮我翻译一下 81 // If the \u0026#34;Expect: 100-continue\u0026#34; expectation wasn\u0026#39;t met, prevent the HTTP/1 connection 82 // from being reused. Otherwise we\u0026#39;re still obligated to transmit the request body to 83 // leave the connection in a consistent state. 84 exchange.noNewExchangesOnConnection(); 85 } 86 } 87 } else { 88 exchange.noRequestBody(); 89 } 90 if (request.body() == null || !request.body().isDuplex()) { 91 // 将Buffer中的数据写给服务端 92 exchange.finishRequest(); 93 } 94 if (!responseHeadersStarted) { 95 exchange.responseHeadersStart(); 96 } 97 if (responseBuilder == null) { 98 // 获取响应头 99 responseBuilder = exchange.readResponseHeaders(false); 100 } 101 //构建response 写入request 握手协议 数据发送时间 数据返回时间 102 Response response = responseBuilder 103 .request(request) 104 .handshake(exchange.connection().handshake()) 105 .sentRequestAtMillis(sentRequestMillis) 106 .receivedResponseAtMillis(System.currentTimeMillis()) 107 .build(); 108 int code = response.code(); 109 if (code == 100) { 110 // server sent a 100-continue even though we did not request one. 111 // try again to read the actual response 112 response = exchange.readResponseHeaders(false) 113 .request(request) 114 .handshake(exchange.connection().handshake()) 115 .sentRequestAtMillis(sentRequestMillis) 116 .receivedResponseAtMillis(System.currentTimeMillis()) 117 .build(); 118 code = response.code(); 119 } 120 exchange.responseHeadersEnd(response); 121 if (forWebSocket \u0026amp;\u0026amp; code == 101) { 122 // Connection is upgrading, but we need to ensure interceptors see a non-null response body. 123 response = response.newBuilder() 124 .body(Util.EMPTY_RESPONSE) 125 .build(); 126 } else { 127 //包装responseBody 128 response = response.newBuilder() 129 .body(exchange.openResponseBody(response)) 130 .build(); 131 } 132 if (\u0026#34;close\u0026#34;.equalsIgnoreCase(response.request().header(\u0026#34;Connection\u0026#34;)) 133 || \u0026#34;close\u0026#34;.equalsIgnoreCase(response.header(\u0026#34;Connection\u0026#34;))) { 134 exchange.noNewExchangesOnConnection(); 135 } 136 if ((code == 204 || code == 205) \u0026amp;\u0026amp; response.body().contentLength() \u0026gt; 0) { 137 throw new ProtocolException( 138 \u0026#34;HTTP \u0026#34; + code + \u0026#34; had non-zero Content-Length: \u0026#34; + response.body().contentLength()); 139 } 140 return response; 141 } 142} ","date":"2020-04-10","img":"","permalink":"https://helixs.github.io/posts/2020-04-10-android%E6%BA%90%E7%A0%81%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8Bokhttp6-callserverinterceptor/","series":null,"tags":null,"title":"Android源码一步一步分析系列之OkHttp(6)——CallServerInterceptor"},{"categories":["源码分析"],"content":"ConnectInterceptor拦截器里面的东西不多，主要是调用了连接池里面的东西。\n为什么需要这个拦截器，当我们每次发送一次Http请求的时候，如果每次都进行TCP3次握手，耗费的时间和精力是很多的。\n在Http1.1中通过增加了head字段Connection和Keep-Alive来告诉服务器保持一个常在连接通道，那么后面很多的request请求在这个时间范围内都可以用这个连接进行发送。\n这个拦截器就是来干这个事的。\n我们下面来看看\n1/* 2* Licensed to the Apache Software Foundation (ASF) under one or more 3* contributor license agreements. See the NOTICE file distributed with 4* this work for additional information regarding copyright ownership. 5* The ASF licenses this file to You under the Apache License, Version 2.0 6* (the \u0026#34;License\u0026#34;); you may not use this file except in compliance with 7* the License. You may obtain a copy of the License at 8* 9* http://www.apache.org/licenses/LICENSE-2.0 10* 11* Unless required by applicable law or agreed to in writing, software 12* distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, 13* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 14* See the License for the specific language governing permissions and 15* limitations under the License. 16*/ 17package okhttp3.internal.connection; 18import java.io.IOException; 19import okhttp3.Interceptor; 20import okhttp3.OkHttpClient; 21import okhttp3.Request; 22import okhttp3.Response; 23import okhttp3.internal.http.RealInterceptorChain; 24/** Opens a connection to the target server and proceeds to the next interceptor. */ 25public final class ConnectInterceptor implements Interceptor { 26 public final OkHttpClient client; 27 public ConnectInterceptor(OkHttpClient client) { 28 this.client = client; 29 } 30 @Override public Response intercept(Chain chain) throws IOException { 31 RealInterceptorChain realChain = (RealInterceptorChain) chain; 32 Request request = realChain.request(); 33 Transmitter transmitter = realChain.transmitter(); 34 35 // We need the network to satisfy this request. Possibly for validating a conditional GET. 36 boolean doExtensiveHealthChecks = !request.method().equals(\u0026#34;GET\u0026#34;); 37 //返回一个交换器 这个东西主要用在下一个拦截器 CallServerInterceptor 中， 用来传输单个http请求和返回，并且连接和管理实际的IO。 38 Exchange exchange = transmitter.newExchange(chain, doExtensiveHealthChecks); 39 return realChain.proceed(request, transmitter, exchange); 40 } 41} 42 进入newExchange\n1Exchange newExchange(Interceptor.Chain chain, boolean doExtensiveHealthChecks) { 2 synchronized (connectionPool) { 3 //noMoreExchanges 一般情况下是触发异常和返回完成才会当做 true 4 if (noMoreExchanges) throw new IllegalStateException(\u0026#34;released\u0026#34;); 5 //当前已经存在交换机 6 if (exchange != null) throw new IllegalStateException(\u0026#34;exchange != null\u0026#34;); 7 } 8 //exchangeFinder为查找器 找到一个处理request和response的加解码器 9 ExchangeCodec codec = exchangeFinder.find(client, chain, doExtensiveHealthChecks); 10 //创建一个交换机 11 Exchange result = new Exchange(this, call, eventListener, exchangeFinder, codec); 12 synchronized (connectionPool) { 13 this.exchange = result; 14 this.exchangeRequestDone = false; 15 this.exchangeResponseDone = false; 16 return result; 17 } 18} 进入find\n1public ExchangeCodec find( 2 OkHttpClient client, Interceptor.Chain chain, boolean doExtensiveHealthChecks) { 3 int connectTimeout = chain.connectTimeoutMillis(); 4 int readTimeout = chain.readTimeoutMillis(); 5 int writeTimeout = chain.writeTimeoutMillis(); 6 int pingIntervalMillis = client.pingIntervalMillis(); 7 boolean connectionRetryEnabled = client.retryOnConnectionFailure(); 8 try { 9 //返回一个真实可用的连接 10 RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout, 11 writeTimeout, pingIntervalMillis, connectionRetryEnabled, doExtensiveHealthChecks); 12 //返回加解码器有两种一种是http1和http2的 具体的可以自己看一下 这里不多说 13 return resultConnection.newCodec(client, chain); 14 } catch (RouteException e) { 15 trackFailure(); 16 throw e; 17 } catch (IOException e) { 18 trackFailure(); 19 throw new RouteException(e); 20 } 21} 进入findHealthyConnection\n1/** 2* Finds a connection and returns it if it is healthy. If it is unhealthy the process is repeated 3* until a healthy connection is found. 4* 找到一个真实可用的连接，如果没有找到就重复操作，直到找到为止 5*/ 6 private RealConnection findHealthyConnection(int connectTimeout, int readTimeout, 7 int writeTimeout, int pingIntervalMillis, boolean connectionRetryEnabled, 8 boolean doExtensiveHealthChecks) throws IOException { 9 while (true) { 10 RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout, 11 pingIntervalMillis, connectionRetryEnabled); 12 // If this is a brand new connection, we can skip the extensive health checks. 13 synchronized (connectionPool) { 14 // 如果是新链接，跳过 healthy 判断直接返回 15 if (candidate.successCount == 0) { 16 return candidate; 17 } 18 } 19 // 这条链接是否可用 20 // Do a (potentially slow) check to confirm that the pooled connection is still good. If it 21 // isn\u0026#39;t, take it out of the pool and start again. 22 if (!candidate.isHealthy(doExtensiveHealthChecks)) { 23 candidate.noNewExchanges(); 24 continue; 25 } 26 return candidate; 27 } 28 } 29 进入findConnection\n1 2/** 3* Returns a connection to host a new stream. This prefers the existing connection if it exists, 4* then the pool, finally building a new connection. 5* 返回一个连接，如果连接池中有可用的连接直接返回，如果没有就会重新建立一个连接，当然建立过程是通过socket阻塞的 6*/ 7 private RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout, 8 int pingIntervalMillis, boolean connectionRetryEnabled) throws IOException { 9 boolean foundPooledConnection = false; 10 RealConnection result = null; 11 Route selectedRoute = null; 12 RealConnection releasedConnection; 13 Socket toClose; 14 synchronized (connectionPool) { 15 if (transmitter.isCanceled()) throw new IOException(\u0026#34;Canceled\u0026#34;); 16 hasStreamFailure = false; // This is a fresh attempt. 17 //尝试使用当前transmitter的连接 如果有效的话 18 Route previousRoute = retryCurrentRoute() 19 ? transmitter.connection.route() 20 : null; 21 // Attempt to use an already-allocated connection. We need to be careful here because our 22 // already-allocated connection may have been restricted from creating new exchanges. 23 releasedConnection = transmitter.connection; 24 // 若不可用了，则关闭 25 toClose = transmitter.connection != null \u0026amp;\u0026amp; transmitter.connection.noNewExchanges 26 ? transmitter.releaseConnectionNoEvents() 27 : null; 28 if (transmitter.connection != null) { 29 // We had an already-allocated connection and it\u0026#39;s good. 30 result = transmitter.connection; 31 releasedConnection = null; 32 } 33 if (result == null) { 34 // Attempt to get a connection from the pool. 35 //如果当前transmitter没有连接 那么就尝试从线程池中获取connection 36 if (connectionPool.transmitterAcquirePooledConnection(address, transmitter, null, false)) { 37 foundPooledConnection = true; 38 result = transmitter.connection; 39 } else { 40 selectedRoute = previousRoute; 41 } 42 } 43 } 44 // 释放没用的 connection 45 closeQuietly(toClose); 46 if (releasedConnection != null) { 47 eventListener.connectionReleased(call, releasedConnection); 48 } 49 // 如果找到复用的，则使用这条链接，回调 50 if (foundPooledConnection) { 51 eventListener.connectionAcquired(call, result); 52 } 53 if (result != null) { 54 // 找到一条可复用的链接 55 // If we found an already-allocated or pooled connection, we\u0026#39;re done. 56 return result; 57 } 58 // 59 // If we need a route selection, make one. This is a blocking operation. 60 //切换路由再在链接池里面找，如果有则返回 61 boolean newRouteSelection = false; 62 if (selectedRoute == null \u0026amp;\u0026amp; (routeSelection == null || !routeSelection.hasNext())) { 63 newRouteSelection = true; 64 routeSelection = routeSelector.next(); 65 } 66 List\u0026lt;Route\u0026gt; routes = null; 67 synchronized (connectionPool) { 68 if (transmitter.isCanceled()) throw new IOException(\u0026#34;Canceled\u0026#34;); 69 if (newRouteSelection) { 70 // Now that we have a set of IP addresses, make another attempt at getting a connection from 71 // the pool. This could match due to connection coalescing. 72 routes = routeSelection.getAll(); 73 if (connectionPool.transmitterAcquirePooledConnection( 74 address, transmitter, routes, false)) { 75 foundPooledConnection = true; 76 result = transmitter.connection; 77 } 78 } 79 if (!foundPooledConnection) { 80 if (selectedRoute == null) { 81 // 没找到则创建一条 82 selectedRoute = routeSelection.next(); 83 } 84 // Create a connection and assign it to this allocation immediately. This makes it possible 85 // for an asynchronous cancel() to interrupt the handshake we\u0026#39;re about to do. 86 result = new RealConnection(connectionPool, selectedRoute); 87 connectingConnection = result; 88 } 89 } 90 // If we found a pooled connection on the 2nd time around, we\u0026#39;re done. 91 if (foundPooledConnection) { 92 eventListener.connectionAcquired(call, result); 93 return result; 94 } 95 //建立链接 96 // Do TCP + TLS handshakes. This is a blocking operation. 97 result.connect(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis, 98 connectionRetryEnabled, call, eventListener); 99 // 将这条路由从错误缓存中清除 100 connectionPool.routeDatabase.connected(result.route()); 101 Socket socket = null; 102 synchronized (connectionPool) { 103 connectingConnection = null; 104 // Last attempt at connection coalescing, which only occurs if we attempted multiple 105 // concurrent connections to the same host. 106 // 检测一下，若多并发情况下同 address 下导致创建多个，则将当前这个释放掉 107 if (connectionPool.transmitterAcquirePooledConnection(address, transmitter, routes, true)) { 108 // We lost the race! Close the connection we created and return the pooled connection. 109 result.noNewExchanges = true; 110 socket = result.socket(); 111 result = transmitter.connection; 112 } else { 113 // 将这个请求加入链接池 114 connectionPool.put(result); 115 transmitter.acquireConnectionNoEvents(result); 116 } 117 } 118 // 释放掉 socket 119 closeQuietly(socket); 120 eventListener.connectionAcquired(call, result); 121 return result; 122 } 进入RealConnectionPool.transmitterAcquirePooledConnection\n1 2/** 3* 4* #class RealConnectionPool 5* 6*遍历 pool 中的 connections(ArrayQueue)，如果链接是可以复用的则将这个连接放到transmitter 7*/ 8boolean transmitterAcquirePooledConnection(Address address, Transmitter transmitter, 9 @Nullable List\u0026lt;Route\u0026gt; routes, boolean requireMultiplexed) { 10 assert (Thread.holdsLock(this)); 11 for (RealConnection connection : connections) { 12 if (requireMultiplexed \u0026amp;\u0026amp; !connection.isMultiplexed()) continue; 13 if (!connection.isEligible(address, routes)) continue; 14 transmitter.acquireConnectionNoEvents(connection); 15 return true; 16 } 17 return false; 18} 进入RealConnectionPool.isEligible\n1/** 2* #class RealConnectionPool 3* Returns true if this connection can carry a stream allocation to {@code address}. If non-null 4* {@code route} is the resolved route for a connection. 5* 这个连接是符合地址和路由要求的 6*/ 7 boolean isEligible(Address address, @Nullable List\u0026lt;Route\u0026gt; routes) { 8 // If this connection is not accepting new exchanges, we\u0026#39;re done. 9 // 如果当前这次连接的最大并发数达到上限，返回 false 10 if (transmitters.size() \u0026gt;= allocationLimit || noNewExchanges) return false; 11 // If the non-host fields of the address don\u0026#39;t overlap, we\u0026#39;re done. 12 //// 如果两个 address 的其他参数不相同，返回 false 13 if (!Internal.instance.equalsNonHost(this.route.address(), address)) return false; 14 // If the host exactly matches, we\u0026#39;re done: this connection can carry the address. 15 // 如果两个 address 的 url 的 host 相同，返回 true, 16 if (address.url().host().equals(this.route().address().url().host())) { 17 return true; // This connection is a perfect match. 18 } 19 // 如果上面的不符合，在下面的情况下可以合并链接 20 // At this point we don\u0026#39;t have a hostname match. But we still be able to carry the request if 21 // our connection coalescing requirements are met. See also: 22 // https://hpbn.co/optimizing-application-delivery/#eliminate-domain-sharding 23 // https://daniel.haxx.se/blog/2016/08/18/http2-connection-coalescing/ 24 // 1. This connection must be HTTP/2. 25 //// 首先这个链接需要是 HTTP/2 26 if (http2Connection == null) return false; 27 //同一 IP 28 // 2. The routes must share an IP address. 29 if (routes == null || !routeMatchesAny(routes)) return false; 30 // 这个连接的服务器证书必须覆盖新的主机 31 // 3. This connection\u0026#39;s server certificate\u0026#39;s must cover the new host. 32 if (address.hostnameVerifier() != OkHostnameVerifier.INSTANCE) return false; 33 if (!supportsUrl(address.url())) return false; 34 // 证书将必须匹配主机 35 // 4. Certificate pinning must match the host. 36 try { 37 address.certificatePinner().check(address.url().host(), handshake().peerCertificates()); 38 } catch (SSLPeerUnverifiedException e) { 39 return false; 40 } 41 return true; // The caller\u0026#39;s address can be carried by this connection. 42 } isEligible返回后进入 Transmitter.acquireConnectionNoEvents(connection);\n1//将当前的transmitter添加到这个connection的transmitter弱引用集合中 可以用来检查这个连接的transmitter数量 2 void acquireConnectionNoEvents(RealConnection connection) { 3 assert (Thread.holdsLock(connectionPool)); 4 if (this.connection != null) throw new IllegalStateException(); 5 this.connection = connection; 6 connection.transmitters.add(new TransmitterReference(this, callStackTrace)); 7 } 8 告一段落\n 在findConnection方法后面，会有一个put方法把创建新的连接加入到连接池connectionPool中，进入put方法\n1public final class RealConnectionPool { 2 /** 3* Background threads are used to cleanup expired connections. There will be at most a single 4* thread running per connection pool. The thread pool executor permits the pool itself to be 5* garbage collected. 6* 线程池，用来清理过期和不符合要求的连接 7*/ 8 private static final Executor executor = new ThreadPoolExecutor(0 /* corePoolSize */, 9 Integer.MAX_VALUE /* maximumPoolSize */, 60L /* keepAliveTime */, TimeUnit.SECONDS, 10 new SynchronousQueue\u0026lt;\u0026gt;(), Util.threadFactory(\u0026#34;OkHttp ConnectionPool\u0026#34;, true)); 11 /** The maximum number of idle connections for each address. */ 12 /** 13* 每个地址的最大空闲连接数 14* 默认 5个 15*/ 16 private final int maxIdleConnections; 17 /** 18* 默认5分钟 19* 每个连接能维持的时间 20*/ 21 private final long keepAliveDurationNs; 22 /** 23* 每次有put插入动作的时候都会进行检查清理connection操作 24*/ 25 private final Runnable cleanupRunnable = () -\u0026gt; { 26 while (true) { 27 //cleanup代码就不贴出来了 28 // 1、循环遍历connections 找到第一个空闲的连接 29 // 2、检查keepAliveDurationNs maxIdleConnections 是否都超过限制 30 // 3、如果两者之一超过限制 就直接移除 把它从线程池中移除 并且close它 31 // 4、如果没有超过限制，就返回离倒计时的时间 就是下面的waitNanos 32 // 5、如果没有空闲的连接 直接跳出 33 long waitNanos = cleanup(System.nanoTime()); 34 if (waitNanos == -1) return; 35 if (waitNanos \u0026gt; 0) { 36 long waitMillis = waitNanos / 1000000L; 37 waitNanos -= (waitMillis * 1000000L); 38 synchronized (RealConnectionPool.this) { 39 try { 40 //等待到waitNanos后才释放这个锁然后再进行cleanup 41 RealConnectionPool.this.wait(waitMillis, (int) waitNanos); 42 } catch (InterruptedException ignored) { 43 } 44 } 45 } 46 } 47 }; 48 /** 49* 连接的双端队列，方面存取互不干扰 50*/ 51 private final Deque\u0026lt;RealConnection\u0026gt; connections = new ArrayDeque\u0026lt;\u0026gt;(); 52 final RouteDatabase routeDatabase = new RouteDatabase(); 53 boolean cleanupRunning; 54 // 55 //public ConnectionPool() { 56 // this(5, 5, TimeUnit.MINUTES); 57 // } 58 public RealConnectionPool(int maxIdleConnections, long keepAliveDuration, TimeUnit timeUnit) { 59 this.maxIdleConnections = maxIdleConnections; 60 this.keepAliveDurationNs = timeUnit.toNanos(keepAliveDuration); 61 // Put a floor on the keep alive duration, otherwise cleanup will spin loop. 62 if (keepAliveDuration \u0026lt;= 0) { 63 throw new IllegalArgumentException(\u0026#34;keepAliveDuration \u0026lt;= 0: \u0026#34; + keepAliveDuration); 64 } 65 } 66 void put(RealConnection connection) { 67 assert (Thread.holdsLock(this)); 68 //检查是否在清理连接中中，保证每次只有一个线程进行清理操作 69 if (!cleanupRunning) { 70 cleanupRunning = true; 71 //启动清理操作 72 executor.execute(cleanupRunnable); 73 } 74 // 将新建的连接插入到双端队列中 75 connections.add(connection); 76 } 连接池的代码较多，主要就是复用连接，创建连接，保存连接，移除连接的操作。\n","date":"2020-04-10","img":"","permalink":"https://helixs.github.io/posts/2020-04-10-android%E6%BA%90%E7%A0%81%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8Bokhttp5-connectinterceptor/","series":null,"tags":null,"title":"Android源码一步一步分析系列之OkHttp(5)——ConnectInterceptor"},{"categories":["源码分析"],"content":"CacheInterceptor主要是处理缓存的拦截器，其实他不是自己的一些什么缓存机制。基本上还是根据http的缓存协议基础上，进行缓存本地化的改造操作。\n我们要了解缓存就必须理解Http缓存协议\u0026ndash;彻底弄懂HTTP缓存机制及原理 如果大家对缓存协议不清楚，最好看一下上面的内容，Okhttp缓存就是根据它的协议进行开发的，没有太大的改造。\nCacheInterceptor流程\n  1.读取候选缓存； 2.创建缓存策略（根据头信息，判断强制缓存，对比缓存等策略)； 3.根据策略，不使用网络，缓存又没有直接报错； 4.根据策略，不使用网络，有缓存就直接返回； 5.前面个都没有返回，读取网络结果（跑下一个拦截器）； 6.接收到的网络结果，如果是code 304, 使用缓存，返回缓存结果（对比缓存） 7.读取网络结果； 8.对数据进行缓存； 9.返回网络读取的结果。   1/* 2* Licensed to the Apache Software Foundation (ASF) under one or more 3* contributor license agreements. See the NOTICE file distributed with 4* this work for additional information regarding copyright ownership. 5* The ASF licenses this file to You under the Apache License, Version 2.0 6* (the \u0026#34;License\u0026#34;); you may not use this file except in compliance with 7* the License. You may obtain a copy of the License at 8* 9* http://www.apache.org/licenses/LICENSE-2.0 10* 11* Unless required by applicable law or agreed to in writing, software 12* distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, 13* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 14* See the License for the specific language governing permissions and 15* limitations under the License. 16*/ 17package com.rta.rts.login.ui; 18import java.io.IOException; 19import javax.annotation.Nullable; 20import okhttp3.Headers; 21import okhttp3.Interceptor; 22import okhttp3.Protocol; 23import okhttp3.Request; 24import okhttp3.Response; 25import okhttp3.internal.Internal; 26import okhttp3.internal.Util; 27import okhttp3.internal.cache.CacheRequest; 28import okhttp3.internal.cache.CacheStrategy; 29import okhttp3.internal.cache.InternalCache; 30import okhttp3.internal.http.ExchangeCodec; 31import okhttp3.internal.http.HttpHeaders; 32import okhttp3.internal.http.HttpMethod; 33import okhttp3.internal.http.RealResponseBody; 34import okio.Buffer; 35import okio.BufferedSink; 36import okio.BufferedSource; 37import okio.Okio; 38import okio.Sink; 39import okio.Source; 40import okio.Timeout; 41import static java.net.HttpURLConnection.HTTP_NOT_MODIFIED; 42import static java.util.concurrent.TimeUnit.MILLISECONDS; 43import static okhttp3.internal.Util.closeQuietly; 44import static okhttp3.internal.Util.discard; 45/** Serves requests from the cache and writes responses to the cache. */ 46public final class CacheInterceptor implements Interceptor { 47 final @Nullable InternalCache cache; 48 public CacheInterceptor(@Nullable InternalCache cache) { 49 this.cache = cache; 50 } 51 @Override public Response intercept(Chain chain) throws IOException { 52 //1. 读取候选缓存； 53 //根据request得到cache中缓存的response 54 Response cacheCandidate = cache != null 55 ? cache.get(chain.request()) 56 : null; 57 long now = System.currentTimeMillis(); 58 //2. 创建缓存策略（强制缓存，对比缓存等策略)； 59 //request判断缓存的策略，是否要使用了网络，缓存或两者都使用 60 CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get(); 61 Request networkRequest = strategy.networkRequest; 62 Response cacheResponse = strategy.cacheResponse; 63 if (cache != null) { 64 cache.trackResponse(strategy); 65 } 66 if (cacheCandidate != null \u0026amp;\u0026amp; cacheResponse == null) { 67 closeQuietly(cacheCandidate.body()); // The cache candidate wasn\u0026#39;t applicable. Close it. 68 } 69 // If we\u0026#39;re forbidden from using the network and the cache is insufficient, fail. 70 //3根据策略，不使用网络，缓存又没有直接报错； 71 if (networkRequest == null \u0026amp;\u0026amp; cacheResponse == null) { 72 return new Response.Builder() 73 .request(chain.request()) 74 .protocol(Protocol.HTTP_1_1) 75 .code(504) 76 .message(\u0026#34;Unsatisfiable Request (only-if-cached)\u0026#34;) 77 .body(Util.EMPTY_RESPONSE) 78 .sentRequestAtMillis(-1L) 79 .receivedResponseAtMillis(System.currentTimeMillis()) 80 .build(); 81 } 82 // If we don\u0026#39;t need the network, we\u0026#39;re done. 83 // 4. 根据策略，不使用网络，有缓存就直接返回； 84 if (networkRequest == null) { 85 return cacheResponse.newBuilder() 86 .cacheResponse(stripBody(cacheResponse)) 87 .build(); 88 } 89 Response networkResponse = null; 90 try { 91 // 5. 前面个都没有返回，读取网络结果（跑下一个拦截器）； 92 // 93 networkResponse = chain.proceed(networkRequest); 94 } finally { 95 // If we\u0026#39;re crashing on I/O or otherwise, don\u0026#39;t leak the cache body. 96 if (networkResponse == null \u0026amp;\u0026amp; cacheCandidate != null) { 97 closeQuietly(cacheCandidate.body()); 98 } 99 } 100 //6. 接收到的网络结果，如果是code 304, 使用缓存，返回缓存结果（对比缓存） 101 // If we have a cache response too, then we\u0026#39;re doing a conditional get. 102 //// 如果本地已经存在cacheResponse，那么让它和网络得到的networkResponse做比较，决定是否来更新缓存的cacheResponse 103 if (cacheResponse != null) { 104 if (networkResponse.code() == HTTP_NOT_MODIFIED) { 105 Response response = cacheResponse.newBuilder() 106 .headers(combine(cacheResponse.headers(), networkResponse.headers())) 107 .sentRequestAtMillis(networkResponse.sentRequestAtMillis()) 108 .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis()) 109 .cacheResponse(stripBody(cacheResponse)) 110 .networkResponse(stripBody(networkResponse)) 111 .build(); 112 networkResponse.body().close(); 113 // Update the cache after combining headers but before stripping the 114 // Content-Encoding header (as performed by initContentStream()). 115 cache.trackConditionalCacheHit(); 116 cache.update(cacheResponse, response); 117 return response; 118 } else { 119 closeQuietly(cacheResponse.body()); 120 } 121 } 122 //7. 读取网络结果； 123 Response response = networkResponse.newBuilder() 124 .cacheResponse(stripBody(cacheResponse)) 125 .networkResponse(stripBody(networkResponse)) 126 .build(); 127 //8. 对数据进行缓存； 128 if (cache != null) { 129 if (HttpHeaders.hasBody(response) \u0026amp;\u0026amp; CacheStrategy.isCacheable(response, networkRequest)) { 130 // Offer this request to the cache. 131 //// 缓存未经缓存过的response 132 CacheRequest cacheRequest = cache.put(response); 133 return cacheWritingResponse(cacheRequest, response); 134 } 135 //9. 返回网络读取的结果。 136 if (HttpMethod.invalidatesCache(networkRequest.method())) { 137 try { 138 cache.remove(networkRequest); 139 } catch (IOException ignored) { 140 // The cache cannot be written. 141 } 142 } 143 } 144 return response; 145 } 146 private static Response stripBody(Response response) { 147 return response != null \u0026amp;\u0026amp; response.body() != null 148 ? response.newBuilder().body(null).build() 149 : response; 150 } 151 /** 152* Returns a new source that writes bytes to {@code cacheRequest} as they are read by the source 153* consumer. This is careful to discard bytes left over when the stream is closed; otherwise we 154* may never exhaust the source stream and therefore not complete the cached response. 155*/ 156 private Response cacheWritingResponse(final CacheRequest cacheRequest, Response response) 157 throws IOException { 158 // Some apps return a null body; for compatibility we treat that like a null cache request. 159 if (cacheRequest == null) return response; 160 Sink cacheBodyUnbuffered = cacheRequest.body(); 161 if (cacheBodyUnbuffered == null) return response; 162 final BufferedSource source = response.body().source(); 163 final BufferedSink cacheBody = Okio.buffer(cacheBodyUnbuffered); 164 Source cacheWritingSource = new Source() { 165 boolean cacheRequestClosed; 166 @Override public long read(Buffer sink, long byteCount) throws IOException { 167 long bytesRead; 168 try { 169 bytesRead = source.read(sink, byteCount); 170 } catch (IOException e) { 171 if (!cacheRequestClosed) { 172 cacheRequestClosed = true; 173 cacheRequest.abort(); // Failed to write a complete cache response. 174 } 175 throw e; 176 } 177 if (bytesRead == -1) { 178 if (!cacheRequestClosed) { 179 cacheRequestClosed = true; 180 cacheBody.close(); // The cache response is complete! 181 } 182 return -1; 183 } 184 sink.copyTo(cacheBody.buffer(), sink.size() - bytesRead, bytesRead); 185 cacheBody.emitCompleteSegments(); 186 return bytesRead; 187 } 188 @Override public Timeout timeout() { 189 return source.timeout(); 190 } 191 @Override public void close() throws IOException { 192 if (!cacheRequestClosed 193 \u0026amp;\u0026amp; !discard(this, ExchangeCodec.DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) { 194 cacheRequestClosed = true; 195 cacheRequest.abort(); 196 } 197 source.close(); 198 } 199 }; 200 String contentType = response.header(\u0026#34;Content-Type\u0026#34;); 201 long contentLength = response.body().contentLength(); 202 return response.newBuilder() 203 .body(new RealResponseBody(contentType, contentLength, Okio.buffer(cacheWritingSource))) 204 .build(); 205 } 206 /** Combines cached headers with a network headers as defined by RFC 7234, 4.3.4. */ 207 private static Headers combine(Headers cachedHeaders, Headers networkHeaders) { 208 Headers.Builder result = new Headers.Builder(); 209 for (int i = 0, size = cachedHeaders.size(); i \u0026lt; size; i++) { 210 String fieldName = cachedHeaders.name(i); 211 String value = cachedHeaders.value(i); 212 if (\u0026#34;Warning\u0026#34;.equalsIgnoreCase(fieldName) \u0026amp;\u0026amp; value.startsWith(\u0026#34;1\u0026#34;)) { 213 continue; // Drop 100-level freshness warnings. 214 } 215 if (isContentSpecificHeader(fieldName) 216 || !isEndToEnd(fieldName) 217 || networkHeaders.get(fieldName) == null) { 218 Internal.instance.addLenient(result, fieldName, value); 219 } 220 } 221 for (int i = 0, size = networkHeaders.size(); i \u0026lt; size; i++) { 222 String fieldName = networkHeaders.name(i); 223 if (!isContentSpecificHeader(fieldName) \u0026amp;\u0026amp; isEndToEnd(fieldName)) { 224 Internal.instance.addLenient(result, fieldName, networkHeaders.value(i)); 225 } 226 } 227 return result.build(); 228 } 229 /** 230* Returns true if {@code fieldName} is an end-to-end HTTP header, as defined by RFC 2616, 231* 13.5.1. 232*/ 233 static boolean isEndToEnd(String fieldName) { 234 return !\u0026#34;Connection\u0026#34;.equalsIgnoreCase(fieldName) 235 \u0026amp;\u0026amp; !\u0026#34;Keep-Alive\u0026#34;.equalsIgnoreCase(fieldName) 236 \u0026amp;\u0026amp; !\u0026#34;Proxy-Authenticate\u0026#34;.equalsIgnoreCase(fieldName) 237 \u0026amp;\u0026amp; !\u0026#34;Proxy-Authorization\u0026#34;.equalsIgnoreCase(fieldName) 238 \u0026amp;\u0026amp; !\u0026#34;TE\u0026#34;.equalsIgnoreCase(fieldName) 239 \u0026amp;\u0026amp; !\u0026#34;Trailers\u0026#34;.equalsIgnoreCase(fieldName) 240 \u0026amp;\u0026amp; !\u0026#34;Transfer-Encoding\u0026#34;.equalsIgnoreCase(fieldName) 241 \u0026amp;\u0026amp; !\u0026#34;Upgrade\u0026#34;.equalsIgnoreCase(fieldName); 242 } 243 /** 244* Returns true if {@code fieldName} is content specific and therefore should always be used 245* from cached headers. 246*/ 247 static boolean isContentSpecificHeader(String fieldName) { 248 return \u0026#34;Content-Length\u0026#34;.equalsIgnoreCase(fieldName) 249 || \u0026#34;Content-Encoding\u0026#34;.equalsIgnoreCase(fieldName) 250 || \u0026#34;Content-Type\u0026#34;.equalsIgnoreCase(fieldName); 251 } 252} ","date":"2020-04-09","img":"","permalink":"https://helixs.github.io/posts/2020-04-09-android%E6%BA%90%E7%A0%81%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8Bokhttp3-cacheinterceptor/","series":null,"tags":null,"title":"Android源码一步一步分析系列之OkHttp(4)——CacheInterceptor"},{"categories":["源码分析"],"content":"了解更多请看\nAndroid源码一步一步分析系列之OkHttp(1)——揭开面纱Android源码一步一步分析系列之OkHttp(2)——RetryAndFollowUpInterceptor BridgeInterceptor这个拦截器类容比较简单 主要是包装head和处理压缩数据的\n1/* 2* Licensed to the Apache Software Foundation (ASF) under one or more 3* contributor license agreements. See the NOTICE file distributed with 4* this work for additional information regarding copyright ownership. 5* The ASF licenses this file to You under the Apache License, Version 2.0 6* (the \u0026#34;License\u0026#34;); you may not use this file except in compliance with 7* the License. You may obtain a copy of the License at 8* 9* http://www.apache.org/licenses/LICENSE-2.0 10* 11* Unless required by applicable law or agreed to in writing, software 12* distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, 13* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 14* See the License for the specific language governing permissions and 15* limitations under the License. 16*/ 17package com.rta.rts.login.ui; 18import java.io.IOException; 19import java.util.List; 20import okhttp3.Cookie; 21import okhttp3.CookieJar; 22import okhttp3.Headers; 23import okhttp3.Interceptor; 24import okhttp3.MediaType; 25import okhttp3.Request; 26import okhttp3.RequestBody; 27import okhttp3.Response; 28import okhttp3.internal.Version; 29import okhttp3.internal.http.HttpHeaders; 30import okhttp3.internal.http.RealResponseBody; 31import okio.GzipSource; 32import okio.Okio; 33import static okhttp3.internal.Util.hostHeader; 34/** 35* Bridges from application code to network code. First it builds a network request from a user 36* request. Then it proceeds to call the network. Finally it builds a user response from the network 37* response. 38* 在请求前对Header进行处理，如果用户有设置就直接使用，如果没有设置就使用默认的。 39* 通过Chain调用下一个拦截器。 40* 对与返回的结果，进行Gzip, Header, 以及cookie的处理。 41*/ 42public final class BridgeInterceptor implements Interceptor { 43 private final CookieJar cookieJar; 44 public BridgeInterceptor(CookieJar cookieJar) { 45 this.cookieJar = cookieJar; 46 } 47 @Override public Response intercept(Chain chain) throws IOException { 48 Request userRequest = chain.request(); 49 Request.Builder requestBuilder = userRequest.newBuilder(); 50 //一下部分是对http request的主要head字段进行处理 51 RequestBody body = userRequest.body(); 52 if (body != null) { 53 MediaType contentType = body.contentType(); 54 if (contentType != null) { 55 requestBuilder.header(\u0026#34;Content-Type\u0026#34;, contentType.toString()); 56 } 57 long contentLength = body.contentLength(); 58 if (contentLength != -1) { 59 requestBuilder.header(\u0026#34;Content-Length\u0026#34;, Long.toString(contentLength)); 60 requestBuilder.removeHeader(\u0026#34;Transfer-Encoding\u0026#34;); 61 } else { 62 requestBuilder.header(\u0026#34;Transfer-Encoding\u0026#34;, \u0026#34;chunked\u0026#34;); 63 requestBuilder.removeHeader(\u0026#34;Content-Length\u0026#34;); 64 } 65 } 66 if (userRequest.header(\u0026#34;Host\u0026#34;) == null) { 67 requestBuilder.header(\u0026#34;Host\u0026#34;, hostHeader(userRequest.url(), false)); 68 } 69 //这样做，连接就不会中断，而是保持连接。当客户端发送另一个请求时， 70 // 它会使用同一个连接。这一直继续到客户端或服务器端认为会话已经结束，其中一方中断连接。+ 71 //同时需要注意的是，在HTTP/2 协议中， Connection 和 Keep-Alive 是被忽略的；在其中采用其他机制来进行连接管理。 72 if (userRequest.header(\u0026#34;Connection\u0026#34;) == null) { 73 requestBuilder.header(\u0026#34;Connection\u0026#34;, \u0026#34;Keep-Alive\u0026#34;); 74 } 75 // If we add an \u0026#34;Accept-Encoding: gzip\u0026#34; header field we\u0026#39;re responsible for also decompressing 76 // the transfer stream. 77 boolean transparentGzip = false; 78 if (userRequest.header(\u0026#34;Accept-Encoding\u0026#34;) == null \u0026amp;\u0026amp; userRequest.header(\u0026#34;Range\u0026#34;) == null) { 79 //客户端可以事先声明一系列的可以支持压缩模式 默认是gzip unix平台gzip 80 transparentGzip = true; 81 requestBuilder.header(\u0026#34;Accept-Encoding\u0026#34;, \u0026#34;gzip\u0026#34;); 82 } 83 //管理cookies 84 List\u0026lt;Cookie\u0026gt; cookies = cookieJar.loadForRequest(userRequest.url()); 85 if (!cookies.isEmpty()) { 86 requestBuilder.header(\u0026#34;Cookie\u0026#34;, cookieHeader(cookies)); 87 } 88 if (userRequest.header(\u0026#34;User-Agent\u0026#34;) == null) { 89 requestBuilder.header(\u0026#34;User-Agent\u0026#34;, Version.userAgent()); 90 } 91 Response networkResponse = chain.proceed(requestBuilder.build()); 92 //cookiesJar是暴露给外部使用的 93 HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers()); 94 Response.Builder responseBuilder = networkResponse.newBuilder() 95 .request(userRequest); 96 if (transparentGzip 97 \u0026amp;\u0026amp; \u0026#34;gzip\u0026#34;.equalsIgnoreCase(networkResponse.header(\u0026#34;Content-Encoding\u0026#34;)) 98 \u0026amp;\u0026amp; HttpHeaders.hasBody(networkResponse)) { 99 //Gzip的解压缩算法在okio中 100 GzipSource responseBody = new GzipSource(networkResponse.body().source()); 101 Headers strippedHeaders = networkResponse.headers().newBuilder() 102 .removeAll(\u0026#34;Content-Encoding\u0026#34;) 103 .removeAll(\u0026#34;Content-Length\u0026#34;) 104 .build(); 105 responseBuilder.headers(strippedHeaders); 106 String contentType = networkResponse.header(\u0026#34;Content-Type\u0026#34;); 107 //写入解压后的数据到responseBody中 108 responseBuilder.body(new RealResponseBody(contentType, -1L, Okio.buffer(responseBody))); 109 } 110 return responseBuilder.build(); 111 } 112 /** Returns a \u0026#39;Cookie\u0026#39; HTTP request header with all cookies, like {@code a=b; c=d}. 113* 处理request cookies 114**/ 115 private String cookieHeader(List\u0026lt;Cookie\u0026gt; cookies) { 116 StringBuilder cookieHeader = new StringBuilder(); 117 for (int i = 0, size = cookies.size(); i \u0026lt; size; i++) { 118 if (i \u0026gt; 0) { 119 cookieHeader.append(\u0026#34;; \u0026#34;); 120 } 121 Cookie cookie = cookies.get(i); 122 cookieHeader.append(cookie.name()).append(\u0026#39;=\u0026#39;).append(cookie.value()); 123 } 124 return cookieHeader.toString(); 125 } 126} 127 ","date":"2020-04-07","img":"","permalink":"https://helixs.github.io/posts/2020-04-07-android%E6%BA%90%E7%A0%81%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8Bokhttp3-bridgeinterceptor/","series":null,"tags":null,"title":"Android源码一步一步分析系列之OkHttp(3)——BridgeInterceptor"},{"categories":["LeetCode"],"content":" 给你一幅由 N × N 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。 不占用额外内存空间能否做到？\n  示例 1:\n给定 matrix =[ [1,2,3],\n[4,5,6],\n[7,8,9]\n],\n原地旋转输入矩阵，使其变为: [\n[7,4,1],\n[8,5,2],\n[9,6,3]\n]\n  示例 2:\n给定 matrix =\n[\n[ 5, 1, 9,11],\n[ 2, 4, 8,10],\n[13, 3, 6, 7],\n[15,14,12,16]\n],\n原地旋转输入矩阵，使其变为: [\n[15,13, 2, 5],\n[14, 3, 4, 1],\n[12, 6, 8, 9],\n[16, 7,10,11]\n]\n 来源https://leetcode-cn.com/problems/rotate-matrix-lcci/ 解题思路 这里的N*N矩阵就会一个二维数组，并且行数=列数。操作旋转90度。我们发现一个很有意思的规律\n转换后，现数据列数=总行数-原数据行数-1 ，现数据行数=原数据列数 直接上代码吧\n1fun rotate(matrix: Array\u0026lt;IntArray\u0026gt;): Unit { 2 if (matrix.isEmpty()) { 3 return 4 } 5 6 //val copyMatrix= matrix.copyOf() 7 //高阶函数 深拷贝 不然会出现copy引用的情况 8 val copyMatrix= matrix.map { it.clone() }.toTypedArray() 9 val lines = copyMatrix.size 10 copyMatrix.forEachIndexed { index, lineArray -\u0026gt; 11 lineArray.forEachIndexed { cIndex, cInt -\u0026gt; 12 matrix[cIndex][lines-index-1]=cInt 13 } 14 } 15 // matrix.forEach { 16 // println(it.toList().toString()) 17 // } 18} 总的来说，注意一下深拷贝的问题，其实还是很简单啦。\n ","date":"2020-04-07","img":"","permalink":"https://helixs.github.io/posts/2020-04-07-%E6%AF%8F%E6%97%A5%E4%B8%80%E7%AF%87leetcode%E4%B9%8B-%E7%9F%A9%E9%98%B5/","series":null,"tags":null,"title":"每日一篇leetcode之-矩阵旋转"},{"categories":["源码分析"],"content":"可以看一下上一篇文章\nAndroid源码一步一步分析系列之OkHttp(1)——揭开面纱 RetryAndFollowUpInterceptor拦截器是满足一定条件下用来处理失败重试和重定向的一些操作。\n1/* 2* Copyright (C) 2016 Square, Inc. 3* 4* Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); 5* you may not use this file except in compliance with the License. 6* You may obtain a copy of the License at 7* 8* http://www.apache.org/licenses/LICENSE-2.0 9* 10* Unless required by applicable law or agreed to in writing, software 11* distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, 12* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 13* See the License for the specific language governing permissions and 14* limitations under the License. 15*/ 16package com.rta.rts.login.ui; 17import java.io.FileNotFoundException; 18import java.io.IOException; 19import java.io.InterruptedIOException; 20import java.net.ProtocolException; 21import java.net.Proxy; 22import java.net.SocketTimeoutException; 23import java.security.cert.CertificateException; 24import javax.annotation.Nullable; 25import javax.net.ssl.SSLHandshakeException; 26import javax.net.ssl.SSLPeerUnverifiedException; 27import okhttp3.HttpUrl; 28import okhttp3.Interceptor; 29import okhttp3.OkHttpClient; 30import okhttp3.Request; 31import okhttp3.RequestBody; 32import okhttp3.Response; 33import okhttp3.Route; 34import okhttp3.internal.Internal; 35import okhttp3.internal.connection.Exchange; 36import okhttp3.internal.connection.RouteException; 37import okhttp3.internal.connection.Transmitter; 38import okhttp3.internal.http.HttpMethod; 39import okhttp3.internal.http.RealInterceptorChain; 40import okhttp3.internal.http2.ConnectionShutdownException; 41import static java.net.HttpURLConnection.HTTP_CLIENT_TIMEOUT; 42import static java.net.HttpURLConnection.HTTP_MOVED_PERM; 43import static java.net.HttpURLConnection.HTTP_MOVED_TEMP; 44import static java.net.HttpURLConnection.HTTP_MULT_CHOICE; 45import static java.net.HttpURLConnection.HTTP_PROXY_AUTH; 46import static java.net.HttpURLConnection.HTTP_SEE_OTHER; 47import static java.net.HttpURLConnection.HTTP_UNAUTHORIZED; 48import static java.net.HttpURLConnection.HTTP_UNAVAILABLE; 49import static okhttp3.internal.Util.closeQuietly; 50import static okhttp3.internal.Util.sameConnection; 51import static okhttp3.internal.http.StatusLine.HTTP_PERM_REDIRECT; 52import static okhttp3.internal.http.StatusLine.HTTP_TEMP_REDIRECT; 53/** 54* This interceptor recovers from failures and follows redirects as necessary. It may throw an 55* {@link IOException} if the call was canceled. 56* 该拦截器从失败中恢复，并根据需要进行重定向。如果调用者被取消，则可能会抛出一个IO异常。 57*/ 58public final class RetryAndFollowUpInterceptor implements Interceptor { 59 /** 60* How many redirects and auth challenges should we attempt? Chrome follows 21 redirects; Firefox, 61* curl, and wget follow 20; Safari follows 16; and HTTP/1.0 recommends 5. 62* 最大重定向的次数 chrome21次 firefox curl和wget两个命令为21次 safari 21次 http1.0为5次 63*/ 64 private static final int MAX_FOLLOW_UPS = 20; 65 private final OkHttpClient client; 66 public RetryAndFollowUpInterceptor(OkHttpClient client) { 67 this.client = client; 68 } 69 @Override 70 public Response intercept(Chain chain) throws IOException { 71 Request request = chain.request(); 72 RealInterceptorChain realChain = (RealInterceptorChain) chain; 73 /* 74* Transmitter类是OkHttp的应用层和网络层的一个桥梁类 75*这个类包含了更高级的应用层原函数 76* 连接、请求、响应、流 77* public Transmitter(OkHttpClient client, Call call) { 78* this.client = client; 79* 设置连接池，其实最终调用的还是OkHttpClient中通过Builder设置的连接池对象 80* 如果外部没有设置自定义的连接池，会默认使用系统设置的连接池，可参见【ConnectionPool】类 81* this.connectionPool = Internal.instance.realConnectionPool(client.connectionPool()); 82* this.call = call; 83* 设置相关指标的监听器。我们可以通过扩展这个类来监听程序的HTTP的调用数量、大小和持续时间 84* 设置的监听器最终还是调用的OkHttpClient中通过Builder设置的监听对象 85* this.eventListener = client.eventListenerFactory().create(call); 86* this.timeout.timeout(client.callTimeoutMillis(), MILLISECONDS); 87* } 88* 在上一篇文章中 我们说看到newRealCall方法中实例化了 89* call.transmitter = new Transmitter(client, call); 90* 我们可以看到了他把client和call都传入进去了 91* 92*/ 93 Transmitter transmitter = realChain.transmitter(); 94 int followUpCount = 0; 95 Response priorResponse = null; 96 while (true) { 97 //准备连接 transmitter 如果scheme host port 是一样的那么就重用上一次的交换器和request，第一次这两个都没有 98 transmitter.prepareToConnect(request); 99 // 如果请求被cancel掉了 那么就抛出io异常 100 if (transmitter.isCanceled()) { 101 throw new IOException(\u0026#34;Canceled\u0026#34;); 102 } 103 Response response; 104 boolean success = false; 105 try { 106 //调用下一个拦截器之下一个拦截器.....返回-返回-返回到这个拦截器结果 107 response = realChain.proceed(request, transmitter, null); 108 //到了这里 这次请求算是成功了 109 success = true; 110 } catch (RouteException e) { 111 // The attempt to connect via a route failed. The request will not have been sent. 112 //路由异常，请求是不会被发送到服务器的 113 // 试图恢复连接，如果无法恢复则 抛出第一次路由异常 114 if (!recover(e.getLastConnectException(), transmitter, false, request)) { 115 throw e.getFirstConnectException(); 116 } 117 continue; 118 } catch (IOException e) { 119 // An attempt to communicate with a server failed. The request may have been sent. 120 //IO异常 ，这个请求可能已经被发送了 121 //如果无法恢复则抛出异常 122 boolean requestSendStarted = !(e instanceof ConnectionShutdownException); 123 if (!recover(e, transmitter, requestSendStarted, request)) throw e; 124 continue; 125 } finally { 126 // The network call threw an exception. Release any resources. 127 if (!success) { 128 //如果没有成功就跑出IllegalStateException异常 129 transmitter.exchangeDoneDueToException(); 130 } 131 } 132 // Attach the prior response if it exists. Such responses never have a body. 133 //priorResponse 是用来保存前一个 Response 的，当发现需要重定向，则将当前 Response 设置给 priorResponse，再执行一遍流程， 134 // 这里可以看到将前一个 Response 和当前的 Response 结合在一起了， 135 // 直到不需要重定向了则将 priorResponse 和 Response 结合起来。 136 if (priorResponse != null) { 137 response = response.newBuilder() 138 .priorResponse(priorResponse.newBuilder() 139 .body(null) 140 .build()) 141 .build(); 142 } 143 Exchange exchange = Internal.instance.exchange(response); 144 Route route = exchange != null ? exchange.connection().route() : null; 145 // 判断是否需要重定向,如果需要重定向则返回一个重定向的 Request，没有则为 null 146 Request followUp = followUpRequest(response, route); 147 if (followUp == null) { 148 // 不需要重定向 149 if (exchange != null \u0026amp;\u0026amp; exchange.isDuplex()) { 150 transmitter.timeoutEarlyExit(); 151 } 152 //成功返回请求 153 return response; 154 } 155 // 需要重定向 156 RequestBody followUpBody = followUp.body(); 157 if (followUpBody != null \u0026amp;\u0026amp; followUpBody.isOneShot()) { 158 return response; 159 } 160 // 关闭buffer响应流 161 closeQuietly(response.body()); 162 if (transmitter.hasExchange()) { 163 exchange.detachWithViolence(); 164 } 165 // 重定向次数++,并且小于最大重定向次数MAX_FOLLOW_UPS（20） 166 if (++followUpCount \u0026gt; MAX_FOLLOW_UPS) { 167 throw new ProtocolException(\u0026#34;Too many follow-up requests: \u0026#34; + followUpCount); 168 } 169 request = followUp; 170 priorResponse = response; 171 } 172 } 173 /** 174* RouteException 和 IOException 异常检测都会调用 recover() 方法进行判断重试 175* 176* Report and attempt to recover from a failure to communicate with a server. Returns true if 177* {@code e} is recoverable, or false if the failure is permanent. Requests with a body can only 178* be recovered if the body is buffered or if the failure occurred before the request has been 179* sent. 180*/ 181 private boolean recover(IOException e, Transmitter transmitter, 182 boolean requestSendStarted, Request userRequest) { 183 // The application layer has forbidden retries. 184 // 判断 OkHttpClient 是否开启失败重连的机制 185 if (!client.retryOnConnectionFailure()) return false; 186 // We can\u0026#39;t send the request body again. 187 // 与之前版本的 UnrepeatableRequestBody 类似，只能请求一次的请求 188 if (requestSendStarted \u0026amp;\u0026amp; requestIsOneShot(e, userRequest)) return false; 189 // This exception is fatal. 190 //检测该异常是否是致命的 191 if (!isRecoverable(e, requestSendStarted)) return false; 192 // No more routes to attempt. 193 // 是否有更多的路线 194 if (!transmitter.canRetry()) return false; 195 // For failure recovery, use the same route selector with a new connection. 196 return true; 197 } 198 private boolean requestIsOneShot(IOException e, Request userRequest) { 199 RequestBody requestBody = userRequest.body(); 200 return (requestBody != null \u0026amp;\u0026amp; requestBody.isOneShot()) 201 || e instanceof FileNotFoundException; 202 } 203 private boolean isRecoverable(IOException e, boolean requestSendStarted) { 204 //协议问题，不能重试 205 //如果是超时问题，并且请求没有被发送，可以重试，其他的就不要重试了 206 //安全问题，不要重试 207 // If there was a protocol problem, don\u0026#39;t recover. 208 //ProtocolException 属于严重异常，不能进行重新连接 209 if (e instanceof ProtocolException) { 210 return false; 211 } 212 // If there was an interruption don\u0026#39;t recover, but if there was a timeout connecting to a route 213 // we should try the next route (if there is one). 214 // 当异常为中断异常时 215 if (e instanceof InterruptedIOException) { 216 return e instanceof SocketTimeoutException \u0026amp;\u0026amp; !requestSendStarted; 217 } 218 // Look for known client-side or negotiation errors that are unlikely to be fixed by trying 219 // again with a different route. 220 //握手异常 221 if (e instanceof SSLHandshakeException) { 222 // If the problem was a CertificateException from the X509TrustManager, 223 // do not retry. 224 if (e.getCause() instanceof CertificateException) { 225 return false; 226 } 227 } 228 //验证异常 229 if (e instanceof SSLPeerUnverifiedException) { 230 // e.g. a certificate pinning error. 231 return false; 232 } 233 // An example of one we might want to retry with a different route is a problem connecting to a 234 // proxy and would manifest as a standard IOException. Unless it is one we know we should not 235 // retry, we return true and try a new route. 236 return true; 237 } 238 /** 239* Figures out the HTTP request to make in response to receiving {@code userResponse}. This will 240* either add authentication headers, follow redirects or handle a client request timeout. If a 241* follow-up is either unnecessary or not applicable, this returns null. 242*/ 243 private Request followUpRequest(Response userResponse, @Nullable Route route) throws IOException { 244 if (userResponse == null) throw new IllegalStateException(); 245 int responseCode = userResponse.code(); 246 final String method = userResponse.request().method(); 247 switch (responseCode) { 248 case HTTP_PROXY_AUTH: 249 Proxy selectedProxy = route != null 250 ? route.proxy() 251 : client.proxy(); 252 if (selectedProxy.type() != Proxy.Type.HTTP) { 253 throw new ProtocolException(\u0026#34;Received HTTP_PROXY_AUTH (407) code while not using proxy\u0026#34;); 254 } 255 return client.proxyAuthenticator().authenticate(route, userResponse); 256 case HTTP_UNAUTHORIZED: 257 return client.authenticator().authenticate(route, userResponse); 258 case HTTP_PERM_REDIRECT: 259 case HTTP_TEMP_REDIRECT: 260 // \u0026#34;If the 307 or 308 status code is received in response to a request other than GET 261 // or HEAD, the user agent MUST NOT automatically redirect the request\u0026#34; 262 if (!method.equals(\u0026#34;GET\u0026#34;) \u0026amp;\u0026amp; !method.equals(\u0026#34;HEAD\u0026#34;)) { 263 return null; 264 } 265 // fall-through 266 case HTTP_MULT_CHOICE: 267 case HTTP_MOVED_PERM: 268 case HTTP_MOVED_TEMP: 269 case HTTP_SEE_OTHER: 270 // Does the client allow redirects? 271 if (!client.followRedirects()) return null; 272 String location = userResponse.header(\u0026#34;Location\u0026#34;); 273 if (location == null) return null; 274 HttpUrl url = userResponse.request().url().resolve(location); 275 // Don\u0026#39;t follow redirects to unsupported protocols. 276 if (url == null) return null; 277 // If configured, don\u0026#39;t follow redirects between SSL and non-SSL. 278 boolean sameScheme = url.scheme().equals(userResponse.request().url().scheme()); 279 if (!sameScheme \u0026amp;\u0026amp; !client.followSslRedirects()) return null; 280 // Most redirects don\u0026#39;t include a request body. 281 Request.Builder requestBuilder = userResponse.request().newBuilder(); 282 if (HttpMethod.permitsRequestBody(method)) { 283 final boolean maintainBody = HttpMethod.redirectsWithBody(method); 284 if (HttpMethod.redirectsToGet(method)) { 285 requestBuilder.method(\u0026#34;GET\u0026#34;, null); 286 } else { 287 RequestBody requestBody = maintainBody ? userResponse.request().body() : null; 288 requestBuilder.method(method, requestBody); 289 } 290 if (!maintainBody) { 291 requestBuilder.removeHeader(\u0026#34;Transfer-Encoding\u0026#34;); 292 requestBuilder.removeHeader(\u0026#34;Content-Length\u0026#34;); 293 requestBuilder.removeHeader(\u0026#34;Content-Type\u0026#34;); 294 } 295 } 296 // When redirecting across hosts, drop all authentication headers. This 297 // is potentially annoying to the application layer since they have no 298 // way to retain them. 299 if (!sameConnection(userResponse.request().url(), url)) { 300 requestBuilder.removeHeader(\u0026#34;Authorization\u0026#34;); 301 } 302 return requestBuilder.url(url).build(); 303 case HTTP_CLIENT_TIMEOUT: 304 // 408\u0026#39;s are rare in practice, but some servers like HAProxy use this response code. The 305 // spec says that we may repeat the request without modifications. Modern browsers also 306 // repeat the request (even non-idempotent ones.) 307 if (!client.retryOnConnectionFailure()) { 308 // The application layer has directed us not to retry the request. 309 return null; 310 } 311 RequestBody requestBody = userResponse.request().body(); 312 if (requestBody != null \u0026amp;\u0026amp; requestBody.isOneShot()) { 313 return null; 314 } 315 if (userResponse.priorResponse() != null 316 \u0026amp;\u0026amp; userResponse.priorResponse().code() == HTTP_CLIENT_TIMEOUT) { 317 // We attempted to retry and got another timeout. Give up. 318 return null; 319 } 320 if (retryAfter(userResponse, 0) \u0026gt; 0) { 321 return null; 322 } 323 return userResponse.request(); 324 case HTTP_UNAVAILABLE: 325 if (userResponse.priorResponse() != null 326 \u0026amp;\u0026amp; userResponse.priorResponse().code() == HTTP_UNAVAILABLE) { 327 // We attempted to retry and got another timeout. Give up. 328 return null; 329 } 330 if (retryAfter(userResponse, Integer.MAX_VALUE) == 0) { 331 // specifically received an instruction to retry without delay 332 return userResponse.request(); 333 } 334 return null; 335 default: 336 return null; 337 } 338 } 339 private int retryAfter(Response userResponse, int defaultDelay) { 340 String header = userResponse.header(\u0026#34;Retry-After\u0026#34;); 341 if (header == null) { 342 return defaultDelay; 343 } 344 // https://tools.ietf.org/html/rfc7231#section-7.1.3 345 // currently ignores a HTTP-date, and assumes any non int 0 is a delay 346 if (header.matches(\u0026#34;\\\\d+\u0026#34;)) { 347 return Integer.valueOf(header); 348 } 349 return Integer.MAX_VALUE; 350 } 351} 352 ","date":"2020-04-07","img":"","permalink":"https://helixs.github.io/posts/2020-04-07-android%E6%BA%90%E7%A0%81%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8Bokhttp2-retryandfollowupinterceptor/","series":null,"tags":null,"title":"Android源码一步一步分析系列之OkHttp(2)——RetryAndFollowUpInterceptor"},{"categories":["源码分析"],"content":"说来很惭愧，做了这么多年Android没有仔仔细细的看过Okhttp源代码，空余时间都在学习些周边的技术。现在按照新手方式看一步写一步。\nOkHttp就是一种HTTP客户端连接，它有如下特性：\n  HTTP/2多路复用Socket到同一个主机，共享链接。 采用连接池技术，可以有效的减少Http链接数量。 无缝集成GZIP压缩技术。 支持Response Cache，避免重复请求。 域名多IP支持。   OkHttp会自动管理HTTP连接的生命周期：\n  操作Response.body().string()等类型的API，OkHttp会自动将该HTTP连接加入到ConnectionPool中或者直接释放连接 如果采用stream方式操作流，则需要自己手动关闭，否则会发生HTTP连接泄漏（OkHttp通过WeakReference机制，尽最大努力管理这些泄漏的HTTP连接） OkHttp不读取Resonse#Head#Keep-Alive属性来决定该HTTP连接是否能复用，而是直接加入到ConnectionPool进行复用 当从ConnectionPool中获取HTTP连接的时候，OkHttp发现该HTTP连接已经失效，则关闭该连接，并且重新选择一个HTTP连接进行复用   GET 请求 基于3.14版本，最新的4.x版本全部都使用了kotlin编写。实在话，kotlin是门好语言，不过看代码还是java比较舒服\ncom.squareup.okhttp3:okhttp:3.14.0\n1//初始化Okhttp客户端，一个app上基本上我们可以做一个全局单例，这里就不提了 2OkHttpClient client = new OkHttpClient(); 3//新建一个Request对象 其中包括了head body 等等操作 4Request request = new Request.Builder() .url(url) .build(); 5//开始一个同步请求 Response为返回结果 6Response response = client.newCall(request).execute(); 7System.out.println(response.body().string()); 8//开始一个异步请求 9Request asnycRequest = new Request.Builder() .url(url) .build(); 10Response asnycResponse = client.newCall(request).enqueue(new Callback() { 11 @Override 12 public void onFailure(Call call, IOException e) { 13 System.out.println(e.getMessage()); 14 } 15 @Override 16 public void onResponse(Call call, Response response) throws IOException { 17 if (response.isSuccessful()) { 18 System.out.println(response.body().string()); 19 } 20 } 21}); 22//一个request只能对应一个response 23//response code 24//100~199：指示信息，表示请求已接收，继续处理 25//200~299：请求成功，表示请求已被成功接收、理解 26//300~399：重定向，要完成请求必须进行更进一步的操作 27//400~499：客户端错误，请求有语法错误或请求无法实现 28//500~599：服务器端错误，服务器未能实现合法的请求 29 OkHttpClient\n1public OkHttpClient() { 2 this(new Builder()); 3 } 4 OkHttpClient(Builder builder) { 5 this.dispatcher = builder.dispatcher; 6 this.proxy = builder.proxy; 7 this.protocols = builder.protocols; 8 this.connectionSpecs = builder.connectionSpec 9 ...... 10} 11 //Builder建造者模式，多用于配置属性较多的方式，最终都会放入OkhttpClient中 12 public static final class Builder { 13 Dispatcher dispatcher;//分发器，用于分发每个同步和异步任务 14 @Nullable Proxy proxy;//代理 15 List\u0026lt;Protocol\u0026gt; protocols;//请求协议 默认为http/1.1和h2(Http2) 16 List\u0026lt;ConnectionSpec\u0026gt; connectionSpecs;//连接规范 主要是https要用到,包括了TLS的各个版本和相关联的加密方式 17 final List\u0026lt;Interceptor\u0026gt; interceptors = new ArrayList\u0026lt;\u0026gt;();//拦截器 用于请求、响应过程中数据的读取、修改、保持 此功能偏向于业务层面 不关心网络重定向等操作 18 final List\u0026lt;Interceptor\u0026gt; networkInterceptors = new ArrayList\u0026lt;\u0026gt;();//网络拦截器 会响应重定向和传输操作 19 EventListener.Factory eventListenerFactory;//监听网络时间 开始 连接 dns 完成 失败等 20 ProxySelector proxySelector;//代理选择器 21 CookieJar cookieJar;//cookies的操作类 22 @Nullable Cache cache;//http的缓存操作 可以节省时间和流量 默认是没有实现的 23 @Nullable InternalCache internalCache;/okhttp内部缓存 不用实现 24 SocketFactory socketFactory;套接字工厂 25 @Nullable SSLSocketFactory sslSocketFactory;//安全套工厂 用于https 26 @Nullable CertificateChainCleaner certificateChainCleaner;// 受信任的证书链 27 CertificatePinner certificatePinner;//证书锁定，使用CertificatePinner来约束哪些认证机构被信任。 28 Authenticator proxyAuthenticator;//代理身份验证 29 Authenticator authenticator;//身份验证 30 ConnectionPool connectionPool;//连接池 31 Dns dns;// dns配置 32 boolean followSslRedirects;//安全套接层重定向 33 boolean followRedirects;//本地重定向 34 boolean retryOnConnectionFailure;//连接失败重试 35 int callTimeout;//覆盖整个调用过程的超时时间 下面三个各自模块的超时 36 int connectTimeout; 37 int readTimeout; 38 int writeTimeout; 39 int pingInterval;//http2和websocket的心跳间隔时间 那么这个连接通道会一直保持 不必每次进行tcp握手 40 public Builder() { 41 dispatcher = new Dispatcher(); 42 protocols = DEFAULT_PROTOCOLS; 43 connectionSpecs = DEFAULT_CONNECTION_SPECS; 44 eventListenerFactory = EventListener.factory(EventListener.NONE); 45 proxySelector = ProxySelector.getDefault(); 46 if (proxySelector == null) { 47 proxySelector = new NullProxySelector(); 48 } 49 cookieJar = CookieJar.NO_COOKIES; 50 socketFactory = SocketFactory.getDefault(); 51 hostnameVerifier = OkHostnameVerifier.INSTANCE; 52 certificatePinner = CertificatePinner.DEFAULT; 53 proxyAuthenticator = Authenticator.NONE; 54 authenticator = Authenticator.NONE; 55 connectionPool = new ConnectionPool(); 56 dns = Dns.SYSTEM; 57 followSslRedirects = true; 58 followRedirects = true; 59 retryOnConnectionFailure = true; 60 callTimeout = 0; 61 connectTimeout = 10_000; 62 readTimeout = 10_000; 63 writeTimeout = 10_000; 64 pingInterval = 0; 65 } 66 public OkHttpClient build() { 67 return new OkHttpClient(this); 68 } 开启一个同步请求 1Response response = client.newCall(request).execute(); 2//#class OkHttpClient 3/** 4* Prepares the {@code request} to be executed at some point in the future. 5*/ 6 @Override public Call newCall(Request request) { 7 return RealCall.newRealCall(this, request, false /* for web socket */); 8 } 9//#class RealCall RealCall为真正的请求执行者 10static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) { 11 // Safely publish the Call instance to the EventListener. 12 RealCall call = new RealCall(client, originalRequest, forWebSocket); 13 call.transmitter = new Transmitter(client, call); 14 return call; 15 } 16//#class RealCall 17@Override public Response execute() throws IOException { 18 synchronized (this) { 19// 每个Call只能执行一次 20 if (executed) throw new IllegalStateException(\u0026#34;Already Executed\u0026#34;); 21 executed = true; 22 } 23 transmitter.timeoutEnter(); 24 transmitter.callStart(); 25 try { 26 // 通知dispatcher已经进入执行状态 27 client.dispatcher().executed(this); 28//// 通过一系列的拦截器请求处理和响应处理得到最终的返回结果 29 return getResponseWithInterceptorChain(); 30 } finally { 31 // 通知 dispatcher 自己已经执行完毕 32 client.dispatcher().finished(this); 33 } 34 } 35//#class Dispatcher 添加call到同步执行队列中 36/** Used by {@code Call#execute} to signal it is in-flight. */ 37 synchronized void executed(RealCall call) { 38 runningSyncCalls.add(call); 39 } 40//#class RealCall 这里就是我们拦截器所调用的地方 采用的责任链栈的方式 注意看看他们添加的顺序 41Response getResponseWithInterceptorChain() throws IOException { 42 // Build a full stack of interceptors. 43 List\u0026lt;Interceptor\u0026gt; interceptors = new ArrayList\u0026lt;\u0026gt;(); 44 //我们自己定义的拦截器 45 interceptors.addAll(client.interceptors()); 46 //负责失败重试以及重定向 47 interceptors.add(new RetryAndFollowUpInterceptor(client)); 48 //请求时，对必要的Header进行一些添加，如cookies，接收响应时，移除必要的Header 49 interceptors.add(new BridgeInterceptor(client.cookieJar())); 50 //负责读取缓存直接返回、更新缓存 51 interceptors.add(new CacheInterceptor(client.internalCache())); 52 //负责和服务器建立连接 53 interceptors.add(new ConnectInterceptor(client)); 54 if (!forWebSocket) { 55 interceptors.addAll(client.networkInterceptors()); 56 } 57 //负责向服务器发送请求数据、从服务器读取响应数据 最后一步 58 interceptors.add(new CallServerInterceptor(forWebSocket)); 59 Interceptor.Chain chain = new RealInterceptorChain(interceptors, transmitter, null, 0, 60 originalRequest, this, client.connectTimeoutMillis(), 61 client.readTimeoutMillis(), client.writeTimeoutMillis()); 62 boolean calledNoMoreExchanges = false; 63 try { 64 // 使用责任链模式开启链式调用 65 Response response = chain.proceed(originalRequest); 66 if (transmitter.isCanceled()) { 67 closeQuietly(response); 68 throw new IOException(\u0026#34;Canceled\u0026#34;); 69 } 70 return response; 71 } catch (IOException e) { 72 calledNoMoreExchanges = true; 73 throw transmitter.noMoreExchanges(e); 74 } finally { 75 if (!calledNoMoreExchanges) { 76 transmitter.noMoreExchanges(null); 77 } 78 } 79 } 80//#class RealInterceptorChain 拦截器释按照添加顺序放到list集合中，从第一个RealInterceptorChain的proceed方法开始，都会重新实例化一个RealInterceptorChain并把interceptors和集合的index+1放进去。 81//在方法中interceptor.intercept(next);会把下一步的RealInterceptorChain传进区，interceptor会调用传入的Chain.proceed方法又开始重复实现，就这样形成了任务链 82//request和response在他们当中的顺序中是相反的哦。 83@Override public Response proceed(Request request) throws IOException { 84 return proceed(request, transmitter, exchange); 85 } 86 public Response proceed(Request request, Transmitter transmitter, @Nullable Exchange exchange) 87 throws IOException { 88 if (index \u0026gt;= interceptors.size()) throw new AssertionError(); 89 calls++; 90 // If we already have a stream, confirm that the incoming request will use it. 91 if (this.exchange != null \u0026amp;\u0026amp; !this.exchange.connection().supportsUrl(request.url())) { 92 throw new IllegalStateException(\u0026#34;network interceptor \u0026#34; + interceptors.get(index - 1) 93 + \u0026#34; must retain the same host and port\u0026#34;); 94 } 95 // If we already have a stream, confirm that this is the only call to chain.proceed(). 96 if (this.exchange != null \u0026amp;\u0026amp; calls \u0026gt; 1) { 97 throw new IllegalStateException(\u0026#34;network interceptor \u0026#34; + interceptors.get(index - 1) 98 + \u0026#34; must call proceed() exactly once\u0026#34;); 99 } 100 // Call the next interceptor in the chain. 101 RealInterceptorChain next = new RealInterceptorChain(interceptors, transmitter, exchange, 102 index + 1, request, call, connectTimeout, readTimeout, writeTimeout); 103 Interceptor interceptor = interceptors.get(index); 104 Response response = interceptor.intercept(next); 105 // Confirm that the next interceptor made its required call to chain.proceed(). 106 if (exchange != null \u0026amp;\u0026amp; index + 1 \u0026lt; interceptors.size() \u0026amp;\u0026amp; next.calls != 1) { 107 throw new IllegalStateException(\u0026#34;network interceptor \u0026#34; + interceptor 108 + \u0026#34; must call proceed() exactly once\u0026#34;); 109 } 110 // Confirm that the intercepted response isn\u0026#39;t null. 111 if (response == null) { 112 throw new NullPointerException(\u0026#34;interceptor \u0026#34; + interceptor + \u0026#34; returned null\u0026#34;); 113 } 114 if (response.body() == null) { 115 throw new IllegalStateException( 116 \u0026#34;interceptor \u0026#34; + interceptor + \u0026#34; returned a response with no body\u0026#34;); 117 } 118 return response; 119 } 开启一个异步请求 1Request request = new Request.Builder() 2 .url(\u0026#34;http://publicobject.com/helloworld.txt\u0026#34;) 3 .build(); 4client.newCall(request).enqueue(new Callback() { 5 @Override 6 public void onFailure(Call call, IOException e) { 7 e.printStackTrace(); 8 } 9 @Override 10 public void onResponse(Call call, Response response) throws IOException { 11 ... 12 } 13//#class RealCall 14//#qeque在于 工作密取模式 两段都可以取存东西 加快了效率 15// 正在准备中的异步请求队列 16private final Deque\u0026lt;AsyncCall\u0026gt; readyAsyncCalls = new ArrayDeque\u0026lt;\u0026gt;(); 17// 运行中的异步请求 18private final Deque\u0026lt;AsyncCall\u0026gt; runningAsyncCalls = new ArrayDeque\u0026lt;\u0026gt;(); 19// 同步请求 20private final Deque\u0026lt;RealCall\u0026gt; runningSyncCalls = new ArrayDeque\u0026lt;\u0026gt;(); 21@Override public void enqueue(Callback responseCallback) { 22 synchronized (this) { 23 if (executed) throw new IllegalStateException(\u0026#34;Already Executed\u0026#34;); 24 executed = true; 25 } 26 transmitter.callStart(); 27 client.dispatcher().enqueue(new AsyncCall(responseCallback)); 28 } 29//#class Dispatcher 30 void enqueue(AsyncCall call) { 31 synchronized (this) { 32 readyAsyncCalls.add(call); 33 // Mutate the AsyncCall so that it shares the AtomicInteger of an existing running call to 34 // the same host. 35 if (!call.get().forWebSocket) { 36 AsyncCall existingCall = findExistingCallWithHost(call.host()); 37 if (existingCall != null) call.reuseCallsPerHostFrom(existingCall); 38 } 39 } 40 promoteAndExecute(); 41 } 42//#class Dispatcher 43 private boolean promoteAndExecute() { 44 assert (!Thread.holdsLock(this)); 45 List\u0026lt;AsyncCall\u0026gt; executableCalls = new ArrayList\u0026lt;\u0026gt;(); 46 boolean isRunning; 47 synchronized (this) { 48 for (Iterator\u0026lt;AsyncCall\u0026gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) { 49 AsyncCall asyncCall = i.next(); 50 // 如果其中的runningAsynCalls不满，且call占用的host小于最大数量，则将call加入到runningAsyncCalls中执行， 51 // 同时利用线程池执行call；否者将call加入到readyAsyncCalls中。 52 if (runningAsyncCalls.size() \u0026gt;= maxRequests) break; // Max capacity. 53 if (asyncCall.callsPerHost().get() \u0026gt;= maxRequestsPerHost) continue; // Host max capacity. 54 i.remove(); 55 asyncCall.callsPerHost().incrementAndGet(); 56 executableCalls.add(asyncCall); 57 runningAsyncCalls.add(asyncCall); 58 } 59 isRunning = runningCallsCount() \u0026gt; 0; 60 } 61 for (int i = 0, size = executableCalls.size(); i \u0026lt; size; i++) { 62 AsyncCall asyncCall = executableCalls.get(i); 63 asyncCall.executeOn(executorService()); 64 } 65 return isRunning; 66 } 67//#class Dispatcher 这就是获取异步线程池的操作 68public synchronized ExecutorService executorService() { 69 if (executorService == null) { 70 //不存在常驻核心线程 不限制非核心线程的创建 线程空闲存活时间为60秒 SynchronousQueue 表示对于提交的任务，如果有空闲线程，则使用空闲线程来处理；否则新建一个线程来处理任务 不要有任务等待在队列中 71 executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS, 72 new SynchronousQueue\u0026lt;\u0026gt;(), Util.threadFactory(\u0026#34;OkHttp Dispatcher\u0026#34;, false)); 73 } 74 return executorService; 75 } 76//#class RealCall 77void executeOn(ExecutorService executorService) { 78 assert (!Thread.holdsLock(client.dispatcher())); 79 boolean success = false; 80 try { 81 executorService.execute(this); 82 success = true; 83 } catch (RejectedExecutionException e) { 84 InterruptedIOException ioException = new InterruptedIOException(\u0026#34;executor rejected\u0026#34;); 85 ioException.initCause(e); 86 transmitter.noMoreExchanges(ioException); 87 responseCallback.onFailure(RealCall.this, ioException); 88 } finally { 89 if (!success) { 90 client.dispatcher().finished(this); // This call is no longer running! 91 } 92 } 93 } 94//#class RealCall 95@Override protected void execute() { 96 boolean signalledCallback = false; 97 transmitter.timeoutEnter(); 98 try { 99 //这基本上和同步任务一样了 100 Response response = getResponseWithInterceptorChain(); 101 signalledCallback = true; 102 responseCallback.onResponse(RealCall.this, response); 103 } catch (IOException e) { 104 if (signalledCallback) { 105 // Do not signal the callback twice! 106 Platform.get().log(INFO, \u0026#34;Callback failure for \u0026#34; + toLoggableString(), e); 107 } else { 108 responseCallback.onFailure(RealCall.this, e); 109 } 110 } finally { 111 client.dispatcher().finished(this); 112 } 113 } 114 ","date":"2020-04-02","img":"","permalink":"https://helixs.github.io/posts/2020-04-02-android%E6%BA%90%E7%A0%81%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8Bokhttp1-%E6%8F%AD%E5%BC%80%E9%9D%A2%E7%BA%B1/","series":null,"tags":null,"title":"Android源码一步一步分析系列之OkHttp(1)——揭开面纱"},{"categories":["Android开发"],"content":" Android 4.4（API 级别 19）引入了存储访问框架 (SAF)。借助 SAF，用户可轻松在其所有首选文档存储提供程序中浏览并打开文档、图像及其他文件。用户可通过易用的标准界面，以统一方式在所有应用和提供程序中浏览文件，以及访问最近使用的文件。 云存储服务或本地存储服务可实现封装其服务的 ``DocumentsProvider ，进而参与此生态系统。只需几行代码，便可将需要访问提供程序文档的客户端应用与 SAF 进行集成。 简单的来说，不需要自己主动读取sdcard的媒体和文档，系统给你统一的UI，统一的选择器，让你获取资料。\n SAF 包含以下内容：\n 文档提供程序 — 一种内容提供程序，可让存储服务（如 Google Drive）显示其管理的文件。文档提供程序以DocumentsProvider 类的子类形式实现。文档提供程序的架构基于传统的文件层次结构，但其实际的数据存储方式由您决定。Android 平台包含若干内置文档提供程序，如 Downloads、Images 和 Videos。 客户端应用 — 一种自定义应用，它会调用ACTION_OPEN_DOCUMENT 或ACTION_CREATE_DOCUMENT ACTION_OPEN_DOCUMENT_TREE 这三种Intent的Action,来实现打开，创建文档，以及打开文档树。 选择器 — 一种系统界面，可让用户访问所有满足客户端应用搜索条件的文档提供程序内的文档。   左边是我们的客户端， 中间SystemUI 选择器， 右边是我们的文档提供程序 就是实现了_DocumentsProvider 的提供方\n在 Android 4.3 及更低版本中，如果您想让应用从其他应用中检索文件，则该应用必须调用ACTION_PICK 或ACTION_GET_CONTENT 等 Intent。然后，用户必须选择一个要从中选取文件的应用，并且所选应用必须提供用户界面，以便用户浏览和选取可用文件。\n在 Android 4.4 及更高版本中，您还可选择使用ACTION_OPEN_DOCUMENT Intent，此 Intent 会显示由系统控制的选择器界面，以便用户浏览其他应用提供的所有文件。借助此界面，用户便可从任何受支持的应用中选取文件。\nACTION_OPEN_DOCUMENT 并非用于代替ACTION_GET_CONTENT 。您应根据应用需求选择所使用的 Intent：\n 如果您只想让应用读取/导入数据，请使用ACTION_GET_CONTENT 。使用此方法时，应用会导入数据（如图片文件）的副本。 如果您想让应用获得对文档提供程序所拥有文档的长期、持续性访问权限，请使用ACTION_OPEN_DOCUMENT 。例如，照片编辑应用可让用户编辑存储在文档提供程序中的图像。  SAF 所围绕的内容提供程序是DocumentsProvider 类的一个子类。在文档提供程序内，数据结构采用传统的文件层次结构：  每个文档提供程序都会报告一个或多个“根目录”（探索文档树的起点）。每个根目录都有唯一的COLUMN_ROOT_ID ，并且指向表示该根目录下内容的文档（目录）。根目录采用动态设计，以支持多个帐户、临时 USB 存储设备或用户登录/注销等用例。 每个根目录下都有一个文档。该文档指向 1 至_N_个文档，其中每个文档又可指向 1 至_N_个文档。 每个存储后端都会使用唯一的COLUMN_DOCUMENT_ID 引用各个文件和目录，从而将其显示出来。文档 ID 必须具有唯一性，且一经发出便不得更改，因为它们用于所有设备重启过程中的 URI 持久授权。 文档可以是可打开的文件（具有特定的 MIME类型）或包含附加文档的目录（具有MIME_TYPE_DIR MIME 类型）。 如COLUMN_FLAGS 所述，每个文档可拥有不同功能。例如，FLAG_SUPPORTS_WRITE 、FLAG_SUPPORTS_DELETE 和FLAG_SUPPORTS_THUMBNAIL 。多个目录中可包含相同的COLUMN_DOCUMENT_ID 。  下面是常用的操作类\n DocumentsContacts：协议类，规范了客户端app和DocumentProvider之间的交互，其子类Root和Document就代表了我们之前介绍的文件结构中的根和文档。该类同时定义了文档的操作，例如删除，新建，重命名等。 DocumentFile : 辅助操作类，直接使用DocumentsContact类比较麻烦，也不符合大家的操作习惯。因此google推出了DocumentFile类来帮助大家进行文档操作，该类的api和File类较为接近。其三个子类，TreeDocumentFile代表了一个文档树，SingleDocumentFile仅仅代表单个文档。RawDocumentFile比较特殊，它代表的是一个普通的文件，而非SAF框架的Document uri DocumentProvider : 文档提供者，它的各个子类真正提供了文档的内容，例如我们访问外置sd卡，就是其子类ExternalStorageProvider提供的内容。它是真正的数据处理者，我们通过DocumentsContacts发出的各个文件操作，都将由它来实际完成。 PickActivity,OpenExternalDirectoryActivity : DocumentUi提供的页面，可以显示文档树，以及文档操作授权页面。  以下代码段使用ACTION_OPEN_DOCUMENT 来搜索包含图片文件的文档提供程序：\n启动\n1private const val READ_REQUEST_CODE: Int = 42 2... 3/** 4* Fires an intent to spin up the \u0026#34;file chooser\u0026#34; UI and select an image. 5*/ 6fun performFileSearch() { 7 // ACTION_OPEN_DOCUMENT is the intent to choose a file via the system\u0026#39;s file 8 // browser. 9 val intent = Intent(Intent.ACTION_OPEN_DOCUMENT).apply { 10 // Filter to only show results that can be \u0026#34;opened\u0026#34;, such as a 11 // file (as opposed to a list of contacts or timezones) 12 //文档需要是可以打开的 13 addCategory(Intent.CATEGORY_OPENABLE) 14 //是否支持多选操作 15 putExtra(Intent.EXTRA_ALLOW_MULTIPLE,false) 16 // Filter to show only images, using the image MIME data type. 17 // If one wanted to search for ogg vorbis files, the type would be \u0026#34;audio/ogg\u0026#34;. 18 // To search for all documents available via installed storage providers, 19 // it would be \u0026#34;*/*\u0026#34;. 20 //指定文档的minitype 21 type = \u0026#34;image/*\u0026#34; 22 } 23 startActivityForResult(intent, READ_REQUEST_CODE) 24}  当应用触发ACTION_OPEN_DOCUMENT Intent 时，该 Intent 会启动选择器，以显示所有匹配的文档提供程序。 在 Intent 中添加CATEGORY_OPENABLE 类别可对结果进行过滤，从而只显示可打开的文档（如图片文件）。 intent.setType(\u0026quot;image/*\u0026quot;)语句可做进一步过滤，从而只显示 MIME 数据类型为图像的文档。  使用比较简单，我们直接构建了一个Intent请求，并调用startActivityForResult方法，请求打开DocumentUi界面，让它提供一个打开文档的视图给我们。我们可以通过设置EXTRA_ALLOW_MULTIPLE来支持多选，其他一些可以选择的EXTRA字段，可以在DocumentsContract类中自行查找。\n 返回结果\n当用户在选择器中选择文档后，系统会调用 onActivityResult() 。resultData参数包含指向所选文档的 URI。您可以使用getData() 提取该 URI。获得 URI 后，您可以用它来检索用户所需文档。例如：\n1override fun onActivityResult(requestCode: Int, resultCode: Int, resultData: Intent?) { 2 // The ACTION_OPEN_DOCUMENT intent was sent with the request code 3 // READ_REQUEST_CODE. If the request code seen here doesn\u0026#39;t match, it\u0026#39;s the 4 // response to some other intent, and the code below shouldn\u0026#39;t run at all. 5 if (requestCode == READ_REQUEST_CODE \u0026amp;\u0026amp; resultCode == Activity.RESULT_OK) { 6 // The document selected by the user won\u0026#39;t be returned in the intent. 7 // Instead, a URI to that document will be contained in the return intent 8 // provided to this method as a parameter. 9 // Pull that URI using resultData.getData(). 10 resultData?.data?.also { uri -\u0026gt; 11 Log.i(TAG, \u0026#34;Uri: $uri\u0026#34;) 12 dumpImageMetaData(uri) 13 } 14 } 15} 检查文档元数据\n获得文档的 URI 后，您可以访问该文档的元数据。以下代码段用于获取 URI 所指定文档的元数据，并将其记入日志：\n1fun dumpImageMetaData(uri: Uri) { 2 // The query, since it only applies to a single document, will only return 3 // one row. There\u0026#39;s no need to filter, sort, or select fields, since we want 4 // all fields for one document. 5 val cursor: Cursor? = contentResolver.query( uri, null, null, null, null, null) 6 cursor?.use { 7 // moveToFirst() returns false if the cursor has 0 rows. Very handy for 8 // \u0026#34;if there\u0026#39;s anything to look at, look at it\u0026#34; conditionals. 9 if (it.moveToFirst()) { 10 // Note it\u0026#39;s called \u0026#34;Display Name\u0026#34;. This is 11 // provider-specific, and might not necessarily be the file name. 12 //开打开的文档必须支持OpenableColumns的列 13 val displayName: String = 14 it.getString(it.getColumnIndex(OpenableColumns.DISPLAY_NAME)) 15 Log.i(TAG, \u0026#34;Display Name: $displayName\u0026#34;) 16 val sizeIndex: Int = it.getColumnIndex(OpenableColumns.SIZE) 17 // If the size is unknown, the value stored is null. But since an 18 // int can\u0026#39;t be null in Java, the behavior is implementation-specific, 19 // which is just a fancy term for \u0026#34;unpredictable\u0026#34;. So as 20 // a rule, check if it\u0026#39;s null before assigning to an int. This will 21 // happen often: The storage API allows for remote files, whose 22 // size might not be locally known. 23 val size: String = if (!it.isNull(sizeIndex)) { 24 // Technically the column stores an int, but cursor.getString() 25 // will do the conversion automatically. 26 it.getString(sizeIndex) 27 } else { 28 \u0026#34;Unknown\u0026#34; 29 } 30 Log.i(TAG, \u0026#34;Size: $size\u0026#34;) 31 } 32 } 33} 打开文档\n获得文档的 URI 后，您可以打开文档，或随意对其执行任何其他操作。\n1//以下为直接从该uri中获取InputSteam，并读取出文本的内容的操作，这个是纯粹的java流操作，大家应该已经很熟悉了 2 //我就不多解释了。另外这里也可以直接使用OutputSteam，向文档中写入数据。 3 BufferedReader br = null; 4 try { 5 InputStream is = getContentResolver().openInputStream(uri); 6 br = new BufferedReader(new InputStreamReader(is)); 7 String line; 8 sb.append(\u0026#34;\\r\\n content : \u0026#34;); 9 while((line = br.readLine())!=null){ 10 sb.append(line); 11 } 12 showToast(sb.toString()); 13 } catch (IOException e) { 14 e.printStackTrace(); 15 }finally { 16 closeSafe(br); 17 } 18 1@Throws(IOException::class) 2private fun getBitmapFromUri(uri: Uri): Bitmap { 3 val parcelFileDescriptor: ParcelFileDescriptor = contentResolver.openFileDescriptor(uri, \u0026#34;r\u0026#34;) 4 val fileDescriptor: FileDescriptor = parcelFileDescriptor.fileDescriptor 5 //val fileOutputStream =FileOutputStream(fd.getFileDescriptor()); 6 val image: Bitmap = BitmapFactory.decodeFileDescriptor(fileDescriptor) 7 parcelFileDescriptor.close() 8 return image 9} 10 获取 InputStream\n以下示例展示了如何从 URI 中获取 InputStream。在此代码段中，系统会将文件行读取到字符串中：\n1@Throws(IOException::class) 2private fun readTextFromUri(uri: Uri): String { 3 val stringBuilder = StringBuilder() 4 contentResolver.openInputStream(uri)?.use { inputStream -\u0026gt; 5 BufferedReader(InputStreamReader(inputStream)).use { reader -\u0026gt; 6 var line: String? = reader.readLine() 7 while (line != null) { 8 stringBuilder.append(line) 9 line = reader.readLine() 10 } 11 } 12 } 13 return stringBuilder.toString() 14} ACTION_OPEN_DOCUMENT_TREE\n上面我们说到了如何打开文档，这个ACTION可以让我们直接打开文档树。类比的话，上面的Action相当于打开一个文件，这个相当于打开一个文件夹，这样大家就知道它们的区别在哪里了。我们依旧看一下示例。\n1val intent = Intent(Intent.ACTION_OPEN_DOCUMENT_TREE) 2//.... 1private fun handleTreeAction(data: Intent) { 2 val treeUri: Uri = data.data 3 //授予打开的文档树永久性的读写权限 4 val takeFlags: Int = (intent.getFlags() 5 and (Intent.FLAG_GRANT_READ_URI_PERMISSION 6 or Intent.FLAG_GRANT_WRITE_URI_PERMISSION)) 7 getContentResolver().takePersistableUriPermission(uri, takeFlags) 8 //使用DocumentFile构建一个根文档，之后的操作可以在该文档上进行 9 mRoot = DocumentFile.fromTreeUri(this, treeUri) 10 //显示结果toast 11 showToast(\u0026#34; open tree uri $treeUri\u0026#34;) 12 }  对于我们打开的文档树，系统会赋予我们对该文档树下所有文档的读写权限，因此我们可以自由的使用我们上面介绍的输入输出流或者文件的方式来进行读写，该授权会一直保留到用户重启设备。 但是有时候，我们需要能够永久性的访问这些文件的权限，而不是重启就需要重新授权，因此我们使用了takePersistableUriPermission方法来保留系统对我们的uri的授权，即使设备重启也不影响。 我们可能保存了应用最近访问的 URI，但它们可能不再有效 — 另一个应用可能已删除或修改了文档。 因此，应该调用 getContentResolver().takePersistableUriPermission() 以检查有无最新数据。 拿到了根目录的uri,我们就可用使用DocumentFile辅助类来方便的进行创建，删除文件等操作了，我们之后介绍。  1// Here are some examples of how you might call this method. 2// The first parameter is the MIME type, and the second parameter is the name 3// of the file you are creating: 4// 5// createFile(\u0026#34;text/plain\u0026#34;, \u0026#34;foobar.txt\u0026#34;); 6// createFile(\u0026#34;image/png\u0026#34;, \u0026#34;mypicture.png\u0026#34;); 7// Unique request code. 8private const val WRITE_REQUEST_CODE: Int = 43 9... 10private fun createFile(mimeType: String, fileName: String) { 11 val intent = Intent(Intent.ACTION_CREATE_DOCUMENT).apply { 12 // Filter to only show results that can be \u0026#34;opened\u0026#34;, such as 13 // a file (as opposed to a list of contacts or timezones). 14 addCategory(Intent.CATEGORY_OPENABLE) 15 // Create a file with the requested MIME type. 16 type = mimeType 17 putExtra(Intent.EXTRA_TITLE, fileName) 18 } 19 startActivityForResult(intent, WRITE_REQUEST_CODE) 20} 创建新文档后，您可以在 onActivityResult() 中获取该文档的 URI，以便继续向其写入内容。\n编辑文档\n您可以随时使用 SAF 编辑文本文档。以下代码段会触发ACTION_OPEN_DOCUMENT Intent 并使用CATEGORY_OPENABLE 类别，从而只显示可打开的文档。它会进一步过滤，从而只显示文本文件：\n1private const val EDIT_REQUEST_CODE: Int = 44 2/** 3* Open a file for writing and append some text to it. 4*/ 5private fun editDocument() { 6 // ACTION_OPEN_DOCUMENT is the intent to choose a file via the system\u0026#39;s 7 // file browser. 8 val intent = Intent(Intent.ACTION_OPEN_DOCUMENT).apply { 9 // Filter to only show results that can be \u0026#34;opened\u0026#34;, such as a 10 // file (as opposed to a list of contacts or timezones). 11 addCategory(Intent.CATEGORY_OPENABLE) 12 // Filter to show only text files. 13 type = \u0026#34;text/plain\u0026#34; 14 } 15 startActivityForResult(intent, EDIT_REQUEST_CODE) 16} 17private fun alterDocument(uri: Uri) { 18 try { 19 contentResolver.openFileDescriptor(uri, \u0026#34;w\u0026#34;)?.use { 20 // use{} lets the document provider know you\u0026#39;re done by automatically closing the stream 21 FileOutputStream(it.fileDescriptor).use { 22 it.write( 23 (\u0026#34;Overwritten by MyCloud at ${System.currentTimeMillis()}\\n\u0026#34;).toByteArray() 24 ) 25 } 26 } 27 } catch (e: FileNotFoundException) { 28 e.printStackTrace() 29 } catch (e: IOException) { 30 e.printStackTrace() 31 } 32} 1private fun handleCreateDocumentAction(data: Intent?) { 2 if (data == null) { 3 return 4 } 5 var bw: BufferedWriter? = null 6 try { 7 val os: OutputStream = getContentResolver().openOutputStream(uri) 8 bw = BufferedWriter(OutputStreamWriter(os)) 9 bw.write(\u0026#34; i am a text \u0026#34;) 10 showToast(\u0026#34; create document succeed uri $uri\u0026#34;) 11 } catch (e: IOException) { 12 e.printStackTrace() 13 } finally { 14 closeSafe(bw) 15 } 16 } 保留权限\n当应用打开文件进行读取或写入时，系统会为其提供针对该文件的 URI 授权，有效期直至用户设备重启。但假定您的应用是图像编辑应用，而且您希望用户能直接从应用中访问其编辑的最后 5 张图像。如果用户的设备已重启，则您必须让用户回到系统选择器以查找这些文件，而这显然不是理想的做法。\n为防止出现此情况，您可以保留系统向应用授予的权限。实际上，您的应用是“获取”了系统提供的 URI 持久授权。如此一来，用户便可通过您的应用持续访问文件，即使设备已重启也不受影响：\n1val takeFlags: Int = intent.flags and 2 (Intent.FLAG_GRANT_READ_URI_PERMISSION or Intent.FLAG_GRANT_WRITE_URI_PERMISSION) 3// Check for the freshest data. 4contentResolver.takePersistableUriPermission(uri, takeFlags) 还有最后一个步骤。应用最近访问的 URI 可能不再有效，原因是另一个应用可能删除或修改了文档。因此，您应始终调用getContentResolver().takePersistableUriPermission()，以检查有无最新数据。\n文件操作\n上面我们提到的三个Action中，ACTION_OPEN_DOCUMENT和ACTION_CREATE_DOCUMENT会返回给我们一个文件对应的uri，而ACTION_OPEN_TREE_CODE返回给我们的则是一个文件夹对应的uri，但是之前我们学习的只是使用输入输出流来读取或者写入文件的内容，如果我们需要对文件执行删除，重命名或者复制等操作要怎么办呢？\n答案就是使用google给我们提供的DocumentsContact以及帮助类DocumentFile,我们可以利用它来方便快捷的完成上述那些文件操作。\nDocumentFile类介绍 DocumentFile是google为了方便大家使用SAF进行文件操作，而推出的帮助类。它的api和java的File类比较接近，更符合一般用户的习惯，且内部实质都是使用了DocumentsContact类的方法来对文件进行操作。也就是说，我们也可以完全不使用DocumentFile而是使用DocumentsContact来完成SAF框架提供的文件操作，DocumentFile提供了三个静态工厂方法来创建自身。\n fromSingleUri,该方法需要传入一个SAF返回的指向单个文件的uri,我们的ACTION_OPEN_DOCUMENT,ACTION_CREATE_DOCUMENT返回的uri就是该类型，其对应的实现类为SingleDocumentFile，代表的是单个的文件。 fromTreeUri，该方法传入指向文件夹的uri,我们的ACTION_OPEN_TREE返回的就是该类型，其对应的实现类为TreeDocumentFile，代表的是一个文件夹。 fromFile，该方法传入普通的File类，是对file类的一个模拟，我们这里不讨论。  DocumentFile提供了一系列操作文件的便捷方法，主要部分下面表格\n创建文件夹和文件，并写入数据\n1，根据ACTION_OPEN_TREE返回的文档树uri,创建一个代表它的DocumentFile\n2，在该目录下，查找名为handleCreateDocument的子目录。\n3，如果未找到，则使用DocumentFile的createDirectory方法创建该子目录。\n4，在该目录下，使用createFile方法创建文件。注意，如果存在重名文件，则该方法会创建一个 原文件名(n)的文件。\n1private fun handleCreateDocument(data: Intent?) { 2 if (data == null) { 3 return 4 } 5 var os: OutputStream? = null 6 try { 7 val name: String = edtName.getText().toString().trim() 8 val text: String = edtText.getText().toString().trim() 9 val path: Uri = data.data 10 //根据SAF返回的文档树uri，创建根Document 11 val root = DocumentFile.fromTreeUri(this, path) 12 //在根目录下，查找名为handleCreateDocument的子目录 13 var dpath = root!!.findFile(\u0026#34;handleCreateDocument\u0026#34;) 14 //如果该子目录不存在，则创建 15 if (dpath == null) { 16 dpath = root.createDirectory(\u0026#34;handleCreateDocument\u0026#34;) 17 } 18 //在handleCreateDocument子目录下，创建一个text类型的Document文件 19 val dfile = dpath!!.createFile(\u0026#34;text/*\u0026#34;, name) 20 //获取该Document的输入流，并写入数据 21 os = getContentResolver().openOutputStream(dfile!!.uri) 22 os.write(text.toByteArray()) 23 showToast(\u0026#34; create document succeed \u0026#34; + dfile.uri) 24 } catch (e: Exception) { 25 showToast(\u0026#34; create document fail $e\u0026#34;) 26 } finally { 27 closeSafe(os) 28 } 29 } 删除文档或文件夹\n如果您获得了文档的 URI，并且文档的Document.COLUMN_FLAGS 包含SUPPORTS_DELETE ，则便可删除该文档。\n删除文件夹的操作如下，注意该操作会删除文件夹下所有的文件和文件夹本身，而不像java的File类删除文件夹一样，需要用户手动遍历删除。当然它的内部实现其实也是利用java的File类，遍历文件夹删除，最后删除自身，原理都是一样的，只是写法不同。\n1private fun handleDeletePath(data: Intent?) { 2 if (data == null) { 3 return 4 } 5 val uri: Uri = data.data 6 val root = DocumentFile.fromTreeUri(this, uri) 7 val res = root!!.delete() 8 val str = if (res) \u0026#34; delete succeed \u0026#34; else \u0026#34; delete fail \u0026#34; 9 showToast(str) 10 } 实际上也是调用的下面\nDocumentsContract.deleteDocument(contentResolver, uri)\n删除文件的操作，则只要uri来源于单个文件，并使用DocumentFile.fromTreeUri构造DocumentFile类，其他完成一样即可，这里就不多说了。\n重命名文件和文件夹\n该操作主要是使用了DocumentsContract类的rename方法来完成操作，因为DocumentFile类的delete方法不支持删除单个文件。需要注意的点如下：\n1，这里的uri需要是SAF返回给我们的单个文件的uri\n2，重命名的文件和原文件必须要在同一个文件夹下，重命名的文件名称指定路径是无效的。\n1private fun handleRenameFile(data: Intent?) { 2 if (data == null) { 3 return 4 } 5 val uri: Uri = data.data 6 try { 7 DocumentsContract.renameDocument(getContentResolver(), uri, \u0026#34;renamefile\u0026#34;) 8 showToast(\u0026#34; rename file succeed \u0026#34;) 9 } catch (e: FileNotFoundException) { 10 showToast(\u0026#34; can not rename file \u0026#34;) 11 } 12 } 重命名文件夹的操作，除了可以可以使用我们上面的重命名文件的DocumentsContract类外，还可以使用DocumentFile类的方法来完成。\n1private fun handleRenamePath(data: Intent?) { 2 if (data == null) { 3 return 4 } 5 val strPath: String = edtName.getText().toString().trim() 6 val path: Uri = data.data 7 //创建一个代表路径的DocumentFile，注意使用fromTreeUri创建，该uri必须是代表路径的Document uri 8 val dPath = DocumentFile.fromTreeUri(this, path) 9 val res = dPath!!.renameTo(strPath) 10 //根据bool结果，来显示重命名文件夹是否成功 11 val strRes = if (res) \u0026#34; rename path succeed \u0026#34; else \u0026#34; rename fail \u0026#34; 12 showToast(strRes) 13 } 遍历文件夹下所有文件\n1，根据ACTION_OPEN_TREE返回的文档树uri,创建一个代表它的DocumentFile。\n2，直接调用DocumentFile的listFiles方法，即可返回其包含的所有子文档，注意子文档即可以是文件，也可以是文件夹。\n1private fun handleListAllFile(data: Intent?) { 2 if (data == null) { 3 return 4 } 5 val uri: Uri = data.data 6 val root = DocumentFile.fromTreeUri(this, uri) 7 val files = root!!.listFiles() 8 val sb = StringBuilder(\u0026#34; list all files \\r\\n\u0026#34;) 9 if (files != null) { 10 for (file in files) { 11 sb.append(file.name).append(\u0026#34;\\r\\n\u0026#34;) 12 } 13 } 14 showToast(sb.toString()) 15 } 授予权限 1，通过之前的分析，我们已经知道，通过ACTION_OPEN_DOCUMENT以及ACTION_CREATE_DOCUMENT拿到的单个文件是有读写权限的；而通过ACTION_OPEN_TREE拿到的整个文件夹也是有读写权限的。\n2，现在假设我们有一个需求，要在外置sd卡/DCIM/Text目录下，创建一个1.txt的文件，并向其写入文本，那么我们应该怎么做呢？看了之前的创建文件夹和文件以及写入文件一章，你可能会觉得很简单。不就是先调用ACTION_OPEN_TREE打开sd卡根目录，等用户选择后，我们拿到它的Document uri，之后还不是就是套路了。\n3，但是且慢，ACTION_OPEN_TREE打开的DocumentUi界面，用户是可以选择目录的，用户要是没有选择sd卡根目录而是其他目录，甚至选择了内部存储，那我们的文件写的位置就完全不确定了，这不符合需求啊，那怎么办呢？\n4，办法当然也是有的，经过搜索源码，发现授权访问外置sd卡根目录的方法竟然不在SAF框架相关中，而是存在StorageManager相关中，可以说是很坑爹了。其实例代码如下：\n1private fun sdcardAuth() { //获取存储管理服务 2 val sm: StorageManager = getSystemService\u0026lt;Any\u0026gt;(Context.STORAGE_SERVICE) as StorageManager 3 //获取存储器 4 val list: List\u0026lt;StorageVolume\u0026gt; = sm.getStorageVolumes() 5 for (sv in list) { //遍历所有存储器，当它是Removable(包含外置sd卡，usb等)且已经装载时 6 if (sv.isRemovable \u0026amp;\u0026amp; TextUtils.equals(sv.state, Environment.MEDIA_MOUNTED)) { //调用StorageVolume的createAccessIntent方法 7 val i = sv.createAccessIntent(null) 8 startActivityForResult(i, SDCARD_AUTH_CODE) 9 return 10 } 11 } 12 showToast(\u0026#34; can not find sdcard \u0026#34;) 13 } 其实现过程分为以下几步：\n 1，获取存储管理服务。 2，获取并遍历所有存储器。 3，找到Removable（外置sd卡,usb存储等）类型的已经装载好的存储器。 4，调用StorageVolume的createAccessIntent方法产生一个inent，之后请求DocumentUi对其进行授权，注意该方法的参数为空表示对整个目录进行授权。  我们来看一些授权界面，看起来和普通的权限弹框类似，我们选择确定后，权限就被授予了。\n我们在来看一些后继的处理，可以看到，也是直接获取sd卡根目录的Uri,之后赋予它永久性的访问权限。然后我们就可以用之前介绍的文件操作来对它进行我们任意操作了，为了方便，我们获取可以把该uri保存下来。\n1private fun handleSdCardAuth(data: Intent?) { 2 if (data == null) { 3 return 4 } 5 //这里获取外置sd卡根目录的Uri,我们可以将它保存下来，方便以后使用 6 val treeUri: Uri = data.data 7 //赋予它永久性的读写权限 8 val takeFlags = (intent.flags 9 and (Intent.FLAG_GRANT_READ_URI_PERMISSION 10 or Intent.FLAG_GRANT_WRITE_URI_PERMISSION)) 11 contentResolver.takePersistableUriPermission(uri, takeFlags) 12 showToast(\u0026#34; sdcard auth succeed,uri $treeUri\u0026#34;) 13 } 所以不一定非要使用READ_EXTERNAL_STORAGE||WRITE_EXTERNAL_STORAGE这两个权限进行目录访问。\n 1，SAF框架不仅可以操作外置sd卡，也可以操作其他存储空间。 2，使用SAF框架操作时，不需要额外的权限，例如使用它操作external storage时，并不需要我们申请WRITE_EXTERNAL_STORAGE权限。  请注意，您不应在界面线程上执行此操作。请使用 AsyncTask 在后台执行此操作。打开位图后，您可以在 ImageView 中显示该位图。\nhttps://developer.android.com/guide/topics/providers/document-provider?hl=zh-cn#kotlin https://blog.csdn.net/hyc1988107/article/details/83825237 ","date":"2020-03-30","img":"","permalink":"https://helixs.github.io/posts/2020-03-30-android-saf%E5%82%A8%E5%AD%98%E8%AE%BF%E9%97%AE%E6%A1%86%E6%9E%B6/","series":null,"tags":null,"title":"Android SAF储存访问框架"},{"categories":["LeetCode"],"content":" 一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。给定一个预约请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。\n注意：本题相对原题稍作改动\n   示例 1：\n输入： [1,2,3,1]\n输出： 4\n解释： 选择 1 号预约和 3 号预约，总时长 = 1 + 3 = 4。\n  示例 2：\n输入： [2,7,9,3,1]\n输出： 12\n解释： 选择 1 号预约、 3 号预约和 5 号预约，总时长 = 2 + 9 + 1 = 12。\n  示例 3：\n输入： [2,1,4,5,3,1,1,3]\n输出： 12\n解释： 选择 1 号预约、 3 号预约、 5 号预约和 8 号预约，总时长 = 2 + 4 + 3 + 3 = 12。\n 来源：力扣（LeetCode）\n_链接：https://leetcode-cn.com/problems/the-masseuse-lcci 这辈子还没进过按摩房呢，真想去体验一次。\n这个题的要求是\n 1、在数组中只不能取出相邻的两个时长。 2、尽量求出最大值  技巧：我们不能按照暴力方法，毕竟太麻烦，不能取相邻两个就相当于中间隔了1个或者2个，当然不可能间隔3个，那就是亏了。\n1private fun message(nums:IntArray){ 2 var a = 0 3 var b = 0 4//递推的方式进行比较。上一个的结果跟下一个和下下一个相加比较最大值，并且储存。 5 for (element in nums) { 6 println(\u0026#34;a-b=$a,$b\u0026#34;) 7 val c = max(b, a + element) 8 a = b 9 b = c 10 } 11} 12fun main(args: Array\u0026lt;String\u0026gt;) { 13 message(intArrayOf(2, 1, 4, 5, 3, 1, 1, 3)) 14} ","date":"2020-03-24","img":"","permalink":"https://helixs.github.io/posts/2020-03-24-%E6%AF%8F%E6%97%A5%E4%B8%80%E7%AF%87leetcode%E4%B9%8B-%E6%8C%89%E6%91%A9%E5%B8%88/","series":null,"tags":null,"title":"每日一篇leetcode之-按摩师"},{"categories":["LeetCode"],"content":" 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。\n设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。\n注意：\n你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n 示例 1:\n输入:\n [7,1,5,3,6,4]\n输出: 7\n解释:\n1 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 2 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。 示例 2:\n输入:\n [1,2,3,4,5]\n输出:\n4\n解释:\n1 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 2 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 3 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例3:\n输入:\n [7,6,4,3,1]\n输出:\n0\n解释:\n在这种情况下, 没有交易完成, 所以最大利润为 0。\n来自leetcode https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/ 分析：\n 1、[p1\u0026hellip;.pn]为连续的交易日价格数组 2、必须买入在接下来的任意一天卖出，不可同时持有股票。 3、可以任意多次购买，但不能违背要求2 4、利润最大化  分析这张图\n可以看一下利润最大化只能是将所有的爬坡阶段加起来，中间下坡就是亏钱，所以不考虑。\n1fun maxProfit(prices: IntArray): Int { 2 var profit = 0 3 for (i in 1 until prices.size) { 4 val tmp = prices[i] - prices[i - 1] 5 if (tmp \u0026gt; 0) profit += tmp 6 } 7 return profit 8} ","date":"2020-03-19","img":"","permalink":"https://helixs.github.io/posts/2020-03-19-%E6%AF%8F%E6%97%A5%E4%B8%80%E7%AF%87leetcode%E4%B9%8B-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-ii/","series":null,"tags":null,"title":"每日一篇leetcode之-买卖股票的最佳时机 II"},{"categories":["LeetCode"],"content":" 给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。\n在构造过程中，请注意区分大小写。比如\u0026quot;Aa\u0026quot;不能当做一个回文字符串。 注意:_ 假设字符串的长度不会超过 1010。\n 示例 1:\n1输入: 2\u0026#34;abccccdd\u0026#34; 3 4输出: 57 6 7解释: 8我们可以构造的最长的回文串是\u0026#34;dccaccd\u0026#34;, 它的长度是 7。 题目来源https://leetcode-cn.com/problems/longest-palindrome/ 开始解题，以来就直接想到了Hash表，表节点直接表示字符数量，要求是英文字母大小写，就是26*2=52个空间节点。上代码：\n1fun longestPalindrome(s: String): Int { 2 val hash = IntArray(52) 3 for (c in s) { 4 //ascii中英文大小写之间有6个非字母符号 5 if (c \u0026gt;= \u0026#39;a\u0026#39;) { 6 hash[c - \u0026#39;A\u0026#39; - 6]++ 7 } else { 8 hash[c - \u0026#39;A\u0026#39;]++ 9 } 10 } 11 //把成对的偶数数量提出来 12 var even = 0 13 //是否有奇数 14 var hasOdd = 0 15 for (h in hash) { 16 if (h == 0) { 17 continue 18 } 19 //右移一次左移一次让最低位为0 20 even += h shr 1 shl 1 21 //判断奇偶性 其实后面hasOdd判断是多余的,写上是为了理解关系 22 if (h and 1 != 0 \u0026amp;\u0026amp; hasOdd == 0) { 23 hasOdd = 1 24 } 25 } 26 return even + hasOdd 27} 28 这个方法很像我前两天写的hash表拼接单词https://xmcf.me/?p=417 下面是官方的答案 感觉一般般\n1class Solution { 2 public int longestPalindrome(String s) { 3 int[] count = new int[128]; 4 for (char c: s.toCharArray()) 5 count[c]++; 6 int ans = 0; 7 for (int v: count) { 8 ans += v / 2 * 2; 9 if (v % 2 == 1 \u0026amp;\u0026amp; ans % 2 == 0) 10 ans++; 11 } 12 return ans; 13 } 14} 15 ","date":"2020-03-19","img":"","permalink":"https://helixs.github.io/posts/2020-03-19-%E6%AF%8F%E6%97%A5%E4%B8%80%E7%AF%87leetcode%E4%B9%8B-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2/","series":null,"tags":null,"title":"每日一篇leetcode之-最长回文串"},{"categories":["LeetCode"],"content":" 矩形以列表 [x1, y1, x2, y2] 的形式表示，其中 (x1, y1) 为左下角的坐标，(x2, y2) 是右上角的坐标。\n如果相交的面积为正，则称两矩形重叠。需要明确的是，只在角或边接触的两个矩形不构成重叠。\n给出两个矩形，判断它们是否重叠并返回结果。\n  示例 1：\n输入：rec1 = [0,0,2,2], rec2 = [1,1,3,3]\n输出：true\n示例 2：\n输入：rec1 = [0,0,1,1], rec2 = [1,0,2,1]\n输出：false\n 提示：\n两个矩形 rec1 和 rec2 都以含有四个整数的列表的形式给出。\n矩形中的所有坐标都处于 -10^9 和 10^9 之间。\nx 轴默认指向右，y 轴默认指向上。\n你可以仅考虑矩形是正放的情况。\n来源：力扣（LeetCode）\n_链接：https://leetcode-cn.com/problems/rectangle-overlap 未参考的解答思路 花了一个草图来想象两个矩形\n矩形A1 矩形A2，按照A2不动的标准来跟A1作比较，如果两个不想交就说明需要满足两个XY方向条件\n[A1(x1)≤A2(x0)||A1(x0)≥A2(x1)]\u0026amp;\u0026amp;[A1(y1)≤A2(y0)||A1(y0)≥A2(y1)]  计算了半天发现错了，因为不必满足所有条件，因为满足其中一个就行了，画蛇添足\n1A1(x1)≤A2(x0)|| 2 3A1(x0)≥A2(x1)|| 4 5A1(y1)≤A2(y0)|| 6 7A1(y0)≥A2(y1) 确定上下左右四个方向就行了，着实很简单\n1class Solution { 2 fun isRectangleOverlap(rec1: IntArray, rec2: IntArray): Boolean { 3 return !check(rec1,rec2) 4 } 5 private fun check(rect1:IntArray,rect2:IntArray):Boolean{ 6 return rect1[2]\u0026lt;=rect2[0]||rect1[0]\u0026gt;=rect2[2]||rect1[3]\u0026lt;=rect2[1]||rect1[1]\u0026gt;=rect2[3] 7 } 8} 官方还有一种解法，就是判断相交区域，A1跟A2如果相交就有min(A1(x1),A2(x1))\u0026gt;max(A1(x0),A2(x0))，Y方向同理，不过这次条件必须同时满足，理解起来还是要麻烦一些，可以看图理解\n1fun isRectangleOverlap(rec1: IntArray, rec2: IntArray): Boolean { 2 return check(rec1,rec2) 3 } 4 private fun check(rect1:IntArray,rect2:IntArray):Boolean{ 5 return Math.min(rect1[2], rect2[2]) \u0026gt; Math.max(rect1[0], rect2[0]) \u0026amp;\u0026amp; 6 Math.min(rect1[3], rect2[3]) \u0026gt; Math.max(rect1[1], rect2[1]) 7 } ","date":"2020-03-18","img":"","permalink":"https://helixs.github.io/posts/2020-03-18-%E6%AF%8F%E6%97%A5%E4%B8%80%E7%AF%87leetcode%E4%B9%8B/","series":null,"tags":null,"title":"每日一篇leetcode之-矩形重叠"},{"categories":["LeetCode"],"content":"给你一份『词汇表』（字符串数组） words 和一张『字母表』（字符串） chars。\n假如你可以用 chars 中的『字母』（字符）拼写出 words 中的某个『单词』（字符串），那么我们就认为你掌握了这个单词。\n注意：每次拼写时，chars 中的每个字母都只能用一次。\n返回词汇表 words 中你掌握的所有单词的 长度之和。\n 示例 1：\n输入：words = [“cat”,”bt”,”hat”,”tree”], chars = “atach”\n输出：6\n解释：\n可以形成字符串 “cat” 和 “hat”，所以答案是 3 + 3 = 6。\n示例 2：\n输入：words = [“hello”,”world”,”leetcode”], chars = “welldonehoneyr” 输出：10\n解释：\n可以形成字符串 “hello” 和 “world”，所以答案是 5 + 5 = 10。\n_ _\n提示：\n1 \u0026lt;= words.length \u0026lt;= 1000\n1 \u0026lt;= words[i].length, chars.length \u0026lt;= 100\n所有字符串中都仅包含小写英文字母\n通过次数21,660提交次数31,246\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/find-words-that-can-be-formed-by-characters \n解答\n1import java.util.* 2class Solution { 3 fun countCharacters(words: Array\u0026lt;String\u0026gt;, chars: String): Int { 4 //因为有26个英文字母，所以按照ascii字母表，将出现的chars中的字母次数进行数量统计 5 val hash = IntArray(26) 6 for (i in chars.indices) { 7 hash[chars[i] - \u0026#39;a\u0026#39;]++ 8 } 9 var res = 0 10 //创建一个临时的数组 用于统计单词中每个字母出现的次数 11 val tempMap = IntArray(26) 12 for (word in words) { 13 var flag = true 14 //初始值为0 15 Arrays.fill(tempMap, 0) 16 Tag@for (i in word.indices) { 17 tempMap[word[i] - \u0026#39;a\u0026#39;]++ 18 //如果当中某个字母数量超过了chars的中相同字母的数量那么就失败 19 if (tempMap[word[i] - \u0026#39;a\u0026#39;] \u0026gt; hash[word[i] - \u0026#39;a\u0026#39;]) { 20 flag = false 21 break@Tag 22 } 23 } 24 if (flag) res += word.length 25 } 26 return res 27 } 28} 29 ","date":"2020-03-17","img":"","permalink":"https://helixs.github.io/posts/2020-03-17-%E6%AF%8F%E6%97%A5%E4%B8%80%E7%AF%87leetcode%E4%B9%8B%E6%8B%BC%E5%86%99%E5%8D%95%E8%AF%8D/","series":null,"tags":null,"title":"每日一篇leetcode之-拼写单词"},{"categories":["数据结构和算法"],"content":"查找二叉树（Binary Sort Tree 二叉排序树）的基本定义   1、若查找树的左子树非空，则其左子树上的各个节点值均小于根节点的值 2、若查找树的右子树非空，则其右子树上的各个节点值均大于根节点的值 3、查找树的左右子树各是一棵查找树。   查找 查找就是比较大小 没啥好说的\n插入 1、如果相同键值的节点已在查找二叉树中，则不插入\n2、如果查找二叉树为空树，则以新节点为查找二叉树\n3、将要插入的节点与即将插入的父节点作比较，确定左右子节点插入\n删除 1、如果要删除的节点是叶子节点就直接删除\n2、如果删除的节点只有一个子节点，那么就直接连接子节点，然后删除\n3、若要删除的节点P有两个子节点，则在其左子树上，用中序遍历需找最大的节点S，用节点S的值代替节点P的值，然后删除节点S，节点S必属于上述1,2情况之1(\n 找出左子树中最大或者右子树中最小的值val 将当前节点的值替换为val 在左子树或者右子树中找到val删除  )\n","date":"2020-03-16","img":"","permalink":"https://helixs.github.io/posts/2020-03-16-%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A72/","series":null,"tags":null,"title":"树和二叉树基本特性(2)"},{"categories":["数据结构和算法"],"content":"树的基本概念就不介绍了，直接上干活\n概念： 1、树的总结点数为n，总度数为k，那么n=k+1\n因为度数就相当于子节点的个数，根节点就是那个+1\n节点的度：一个节点有几个子节点就是有几度。\n树的读：所有节点中，有几个节点有分叉，就相当于树的度。\n例题.在一棵度为3的树中，有2个度为3的节点，1个度为2的节点，则有_x_个度为0的节点。求x。_\n解：树的度为3，就相当于3个有分叉的节点，其他都是叶子节点，因为n=k+1。\n得到n=3*2+2*1+0*x =\u0026gt;n=9\n9-2-1=6 x = 6\n2、二叉树的重要特性\n1、在二叉树的第i层上，最多有2^(i-1)个节点（i≥1）；\n2、深度为k的二叉树最多有(2^k)-1个节点(i≥1)；\n3、对任何一颗二叉树，如果其叶子结点数为N0，度为2的节点数为N2，则N0=N2+1；\n4、具有n个结点的完全二叉树的深度为floor(log2n) + 1\n5、如果对一棵有n个结点的完全二叉树（其深度为floor(log2n) + 1 ）的结点按层序编号，则对任一结点i（1≤i≤n）有：\n（1） 如果i = 1，则结点i是二叉树的根，无双亲；如果i \u0026gt; 1，则其双亲PARENT(i)是结点 floor((i)/2)\n（2）如果2i \u0026gt; n，则结点i无左孩子；否则其左孩子LCHILD(i)是结点2i\n（3）如果2i + 1 \u0026gt; n，则结点i无右孩子；否则其右孩子RCHILD(i)是结点2i + 1\nfloor向下取整  Log2N是数学中的对数，是以2为底N的对数为多少，也就是2的多少次方是N\n 二叉树通常作为数据结构应用，典型用法是对节点定义一个标记函数，将一些值与每个节点相关系。这样标记的二叉树就可以实现二叉搜索树和二叉堆，并应用于高效率的搜索和排序。\n例题：一个具有767个节点的完全二叉树，其叶子结点个数为_X_个。 求X\n根据上面第三点 对任何一颗二叉树，如果其叶子结点数为N0，度为2的节点数为N2，则N0=N2+1；\n1_N = N0 + (N2 +1)=2N2+1_ 2 3_767 = 2N2+1_ 4 5_N2 = 383_ 6 7_X = N2+1 = 383+1 = 384_ 二叉树的遍历 前序1，2，4，5，7，8，3，6\n中序4，2，7，8，5，1，3，6\n后序4，8，7，5，2，6，3，1\n","date":"2020-03-16","img":"","permalink":"https://helixs.github.io/posts/2020-03-16-%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A71/","series":null,"tags":null,"title":"树和二叉树基本特性(1)"},{"categories":["数据库"],"content":"Navicat是比较好的数据库管理软件，可是真的好贵啊，公司企业那些一直在用付费很正常，普通用户也不是一直用，所以很划不来。不过还是要支持正版。\n下载Navicat https://www.navicat.com.cn/products  最新版本已经是15了，下载完成后安装，记得安装目录就行\n下载激活工具 Navicat Software – Patch/Keygen 原始链接(可能出现网站不稳定的情况) 根据浪儿 提供的地址 https://www.lanzous.com/b0bkap39e 5p9d\n如果下载不了请关闭杀毒软件，或者信任。当然我也不知道有没有毒。哈哈\n断网  1、 打开激活工具，默认选中了Backup和Host，然后选择Navicat的版本，之后点击patch。  弹窗选择框到Navicat安装目录选中navicat.exe完成\n  2、选中你的协议和products(mysql啊orancle等等)\n  3、点击Generate生成激活码，复制激活码\n  4、打开navicat，输入激活码，弹窗则手动，复制requestCode\n  5、打开激活工具粘贴到requestCode，点击Generate生成ActivationCode，复制\n  6、打开navicat粘上去，激活成功\n  可以看看下面这个教程\nhttps://juejin.im/post/5d8081b0e51d4561d54dea19 ","date":"2020-03-12","img":"","permalink":"https://helixs.github.io/posts/2020-03-12-navicat%E5%90%84%E7%89%88%E6%9C%AC%E5%8C%85%E6%8B%AC15%E9%80%9A%E7%94%A8%E6%BF%80%E6%B4%BB%E6%95%99%E7%A8%8B/","series":null,"tags":null,"title":"Navicat各版本(包括15)通用激活教程"},{"categories":["数据库"],"content":"初始密码的问题 安装MariaDb后按照网上说的什么mysql -u root -p 根本进不去啊，要输入密码，直接回车也不行。下面可以解决\n1#安装 2yum install mariadb-server 3#启动 4service mariadb start 5------无法登录 6# 先停止 mysql 服务 7mysql stop 8# 然后重新开启服务 但是用的安全模式（跳过权限验证的问题） 9mysqld_safe --skip-grant-tables 10这样我们就可以直接用root登录，无需密码： 11mysql -u root 12use mysql; 13update user set password=PASSWORD(\u0026#34;mynewpassword\u0026#34;) where User=\u0026#39;root\u0026#39;; 14flush privileges; 15#Ctrl + C ,使得 mysql 停止。 16mysql -u root -p root用户远程访问数据库 root用户默认值只允许localhost，所以需要修改root用户的访问权限，不然在会拒绝连接。\n默认是3306端口号，记得开启端口，如果是云服务器记得配置3306的安全组\n还有如果是本地的防火墙可以参考centos7 防火墙端口配置和SSH端口配置 做完之后登录mysql -u root -p\n1GRANT ALL PRIVILEGES ON *.* TO \u0026#39;root\u0026#39;@\u0026#39;%\u0026#39;IDENTIFIED BY \u0026#39;password\u0026#39; WITH GRANT OPTION; 2flush privileges; .表示所有ip可以进来，password表示root用户远程登录的密码，不是原来的密码，记得设置。然后就可以啦\n navicat安装教程 Navicat各版本(包括15)通用激活教程 ","date":"2020-03-11","img":"","permalink":"https://helixs.github.io/posts/2020-03-11-%E5%AE%89%E8%A3%85mariadb%E8%AE%BE%E7%BD%AE%E5%88%9D%E5%A7%8B%E5%AF%86%E7%A0%81/","series":null,"tags":null,"title":"安装mariadb设置初始密码及配置"},{"categories":["Android开发","kotlin"],"content":"我们的app经常有需求下载文件等，还有就是下载安装。\n1、下载文件的方式 1,很多三方框架都有文件上传下载功能，可以借助三方框架(比如Volley,OkHttp,或者还有个很不错的库OKdownload,不过这个库比较重量级，我们只做简单的下载就不太需要啦)\n2,也可以开启一个线程去下载,（可以用IntentService）\n3，最简单的一种方式：Android SDK 其实给我们提供了下载类DownloadManager,只需要简单的配置项设置，就能轻松实现下载功能。\nDownloadManager 是SDK 自带的，大概流程如下：\n（1）创建一个Request,进行简单的配置（下载地址，和文件保存地址等）\n（2）下载完成后，系统会发送一个下载完成的广播，我们需要监听广播。\n（3）监听到下载完成的广播后，根据id查找下载的apk文件\n（4）在代码中执行apk安装。\n1import android.app.DownloadManager 2import android.content.BroadcastReceiver 3import android.content.Context 4import android.content.Intent 5import android.content.IntentFilter 6import android.database.ContentObserver 7import android.database.Cursor 8import android.net.Uri 9import android.os.Build 10import android.os.Environment 11import android.os.Handler 12import android.text.TextUtils 13import androidx.core.content.FileProvider 14import java.io.File 15/** 16* @Author xmcf 17* @Time 2020/3/10 16:55 18* @Description: AppDownloadInstallManager 19*/ 20class AppDownloadInstallManager private constructor() { 21 interface DownloadListener { 22 fun onProgress(task: Task) 23 fun onComplete(task: Task) 24 fun fail(task: Task) 25 } 26 class Task(val taskId: Long, val apkUrl: String, val title: String, val desc: String,val path:String) { 27 var taskStatus = DownloadManager.STATUS_PENDING 28 var currentBytes: Int = 0 29 var totalBytes: Int = 0 30 } 31 private val mContext: Context = AppConfig.context//我这里是全局的appContext 32 private val mDownloadManager = mContext.getSystemService(Context.DOWNLOAD_SERVICE) as DownloadManager 33 private val mDownloadChangeObserver = DownloadProgressChangeObserver(Handler()) 34 private val mDownloadReceiver = DownloadedReceiver() 35 var currentTask: Task? = null 36 private var mDownloadListener: DownloadListener? = null 37 companion object { 38 private const val APK_NAME = \u0026#34;jianlanglianmeng.apk\u0026#34; 39 private const val APK_MIME_TYPE = \u0026#34;application/vnd.android.package-archive\u0026#34; 40 private var instance: AppDownloadInstallManager? = null 41 get() { 42 if (field == null) { 43 field = AppDownloadInstallManager() 44 } 45 return field 46 } 47 @Synchronized 48 fun get(): AppDownloadInstallManager { 49 return instance!! 50 } 51 } 52 fun setDownloaderListener(downloadListener: DownloadListener?): AppDownloadInstallManager { 53 mDownloadListener = downloadListener 54 return this 55 } 56 /** 57* 下载apk文件 58*/ 59 fun downloadApk(apkUrl: String, title: String, desc: String) { 60 // 在下载之前应该删除已有文件,如果需要检查自行操作 61 val apkFile = File(mContext.getExternalFilesDir(Environment.DIRECTORY_DOWNLOADS), APK_NAME) 62 if (apkFile.exists()) { 63 apkFile.delete() 64 } 65 val request = DownloadManager.Request(Uri.parse(apkUrl)).apply { 66 setTitle(title) 67 setDescription(desc) 68 // 完成后显示通知栏 69 setNotificationVisibility(DownloadManager.Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED) 70 //设置下载路径 71 setDestinationInExternalFilesDir(mContext, Environment.DIRECTORY_DOWNLOADS, APK_NAME) 72 setMimeType(APK_MIME_TYPE) 73 } 74 currentTask = Task(mDownloadManager.enqueue(request),apkUrl,title,desc,apkFile.path) 75 register() 76 } 77 public fun cancel() { 78 if (currentTask != null) { 79 unRegister() 80 currentTask = null 81 mDownloadManager.remove(currentTask!!.taskId) 82 } 83 } 84 /** 85* 注册监听 系统下载变化 其实也可以不需要 86* (可以启动一个线程不停的Query检查当前任务的状态，导致的开销很大，当然了可以延迟也行) 87*/ 88 private fun register() { 89 //Uri.parse(\u0026#34;content://downloads/my_downloads\u0026#34;) 来自android.provider.Downloads.IMPL 90 //通过contentResolver.registerContentObserver(ContentObserver)监听系统下载的ContentProvider my_downloads的Uri变化 91 mContext.contentResolver.registerContentObserver(Uri.parse(\u0026#34;content://downloads/my_downloads\u0026#34;), true, mDownloadChangeObserver) 92 //注册下载完成的广播 93 // 注册广播，监听APK是否下载完成 94 mContext.registerReceiver(mDownloadReceiver, IntentFilter(DownloadManager.ACTION_DOWNLOAD_COMPLETE)) 95 } 96 private fun unRegister() { 97 mContext.contentResolver.unregisterContentObserver(mDownloadChangeObserver) 98 mContext.unregisterReceiver(mDownloadReceiver) 99 } 100 /** 101* 文件下载进度变化监听 102*/ 103 inner class DownloadProgressChangeObserver(handler: Handler) : ContentObserver(handler) { 104 override fun onChange(selfChange: Boolean) { 105 super.onChange(selfChange) 106 //下载内容变化 107 updateView() 108 } 109 } 110 private fun updateView() { 111 if (currentTask != null) { 112 val bytesAndStatus = intArrayOf(0, 0, 0) 113 val query = DownloadManager.Query().setFilterById(currentTask!!.taskId) 114 var c: Cursor? = null 115 try { 116 c = mDownloadManager.query(query) 117 if (c != null \u0026amp;\u0026amp; c.moveToFirst()) { //已经下载的字节数 118 bytesAndStatus[0] = c.getInt(c.getColumnIndexOrThrow(DownloadManager.COLUMN_BYTES_DOWNLOADED_SO_FAR)) 119 //总需下载的字节数 120 bytesAndStatus[1] = c.getInt(c.getColumnIndexOrThrow(DownloadManager.COLUMN_TOTAL_SIZE_BYTES)) 121 //状态所在的列索引 122 bytesAndStatus[2] = c.getInt(c.getColumnIndex(DownloadManager.COLUMN_STATUS)) 123 currentTask!!.currentBytes=bytesAndStatus[0] 124 currentTask!!.totalBytes=bytesAndStatus[1] 125 currentTask!!.taskStatus=bytesAndStatus[1] 126 when(bytesAndStatus[2]){ 127// DownloadManager.STATUS_SUCCESSFUL-\u0026gt;{ 128// mDownloadListener?.onComplete(currentTask!!) 129// } 130 DownloadManager.STATUS_FAILED-\u0026gt;{ 131 mDownloadListener?.fail(currentTask!!) 132 } 133 else-\u0026gt;{ 134 mDownloadListener?.onProgress(currentTask!!) 135 } 136 } 137 } 138 } finally { 139 c?.close() 140 } 141 } 142 // Log.i(TAG, \u0026#34;下载进度：\u0026#34; + bytesAndStatus[0] + \u0026#34;/\u0026#34; + bytesAndStatus[1] + \u0026#34;\u0026#34;); 143 } 144 /** 145* 文件下载完成后的广播 146*/ 147 inner class DownloadedReceiver : BroadcastReceiver() { 148 override fun onReceive(context: Context, intent: Intent) { 149 val completeDownLoadId = intent.getLongExtra(DownloadManager.EXTRA_DOWNLOAD_ID, -1) 150 //一定要检查id是否一致，因为系统可能同时下载多个任务，可能导致安装其他apk或者文件打开失败 151 if (currentTask != null \u0026amp;\u0026amp; completeDownLoadId == currentTask!!.taskId) { 152 mDownloadListener?.onComplete(currentTask!!) 153 unRegister() 154 } 155 } 156 } 157 /** 158* 安装Apk 根据下载id 系统版本 进行区分 159* （如果是固定的名称是不需要进行 getUriForDownloadedFile和queryDownloadedApk筛选的） 160* 161* @param downloadId downloadManager任务id 162* @param context 163*/ 164 fun installApk(context: Context, downloadId: Long) { // Logger.e(TAG, \u0026#34;收到广播\u0026#34;); 165 val uri: Uri? 166 val intentInstall = Intent() 167 intentInstall.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK) 168 intentInstall.action = Intent.ACTION_VIEW 169 val downloader = context.getSystemService(Context.DOWNLOAD_SERVICE) as DownloadManager 170 if (Build.VERSION.SDK_INT \u0026lt; Build.VERSION_CODES.M) { // 6.0以下 171 uri = downloader.getUriForDownloadedFile(downloadId) 172 if (uri == null) { 173 Logz.d(\u0026#34;installApk\u0026#34;, \u0026#34;未查询到任务\u0026#34;) 174 return 175 } 176 } else if (Build.VERSION.SDK_INT \u0026lt; Build.VERSION_CODES.N) { // 6.0 - 7.0 177 val apkFile = queryDownloadedApk(downloadId, downloader) 178 uri = if (apkFile != null \u0026amp;\u0026amp; apkFile.exists()) { 179 Uri.fromFile(apkFile) 180 } else { 181 Logz.d(\u0026#34;installApk\u0026#34;, \u0026#34;未查询到任务\u0026#34;) 182 return 183 } 184 } else { // Android 7.0 以上 185 val file = File(context.getExternalFilesDir(Environment.DIRECTORY_DOWNLOADS), \u0026#34;app_name.apk\u0026#34;) 186 if (file.exists()) { 187 uri = FileProvider.getUriForFile(context, 188 \u0026#34;${context.packageName}.fileProvider\u0026#34;, 189 file) 190 intentInstall.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION or Intent.FLAG_GRANT_WRITE_URI_PERMISSION) 191 } else { 192 Logz.d(\u0026#34;installApk\u0026#34;, \u0026#34;未查询到任务\u0026#34;) 193 return 194 } 195 } 196 // 安装应用 197// Logger.e(\u0026#34;zhouwei\u0026#34;, \u0026#34;下载完成了\u0026#34;); 198 intentInstall.setDataAndType(uri, APK_MIME_TYPE) 199 context.startActivity(intentInstall) 200 } 201 //通过downLoadId查询下载的apk，解决6.0 DownloadManager.getUriForDownloadedFile返回的是content://不是file://的问题 202 private fun queryDownloadedApk(downloadId: Long, downloader: DownloadManager): File? { 203 var targetApkFile: File? = null 204 if (downloadId != -1L) { 205 val query = DownloadManager.Query() 206 query.setFilterById(downloadId) 207 query.setFilterByStatus(DownloadManager.STATUS_SUCCESSFUL) 208 val cur = downloader.query(query) 209 if (cur != null) { 210 if (cur.moveToFirst()) { 211 val uriString = cur.getString(cur.getColumnIndex(DownloadManager.COLUMN_LOCAL_URI)) 212 if (!TextUtils.isEmpty(uriString)) { 213 targetApkFile = File(Uri.parse(uriString).path) 214 } 215 } 216 cur.close() 217 } 218 } 219 return targetApkFile 220 } 221} Activity中使用\n1import android.app.Activity 2import android.app.DownloadManager 3import android.content.Intent 4import android.net.Uri 5import android.os.Build 6import android.os.Bundle 7import android.provider.Settings 8import androidx.appcompat.app.AppCompatActivity 9import kotlinx.android.synthetic.main.activity_version_upgrade.* 10/** 11* 版本升级 12* 2020-3-10 15:11:59 13*/ 14class VersionUpgradeActivity : AppCompatActivity(), AppDownloadInstallManager.DownloadListener { 15 companion object { 16 const val START_SETTING_INSTALL = 1001 17 } 18 override fun onCreate(savedInstanceState: Bundle?) { 19 super.onCreate(savedInstanceState) 20 setContentView(R.layout.activity_version_upgrade) 21 btn_start.setOnClickListener { 22 AppDownloadInstallManager.get().setDownloaderListener(this).downloadApk(\u0026#34;https://github.com/shadowsocks/shadowsocks-android/releases/download/v5.0.5/shadowsocks-arm64-v8a-5.0.5.apk\u0026#34;, \u0026#34;title\u0026#34;, \u0026#34;1111\u0026#34;) 23 } 24 } 25 /** 26* Android 8.0 未知来源权限检查 27*/ 28 private fun isInstallPermission(): Boolean { 29 return if (Build.VERSION.SDK_INT \u0026gt;= Build.VERSION_CODES.O) { //先获取是否有安装未知来源应用的权限 30 val haveInstallPermission = packageManager.canRequestPackageInstalls() 31 if (!haveInstallPermission) { //没有权限 32 val intent = Intent(Settings.ACTION_MANAGE_UNKNOWN_APP_SOURCES, Uri.parse(\u0026#34;package:$packageName\u0026#34;)) 33 startActivityForResult(intent, START_SETTING_INSTALL) 34 false 35 } else { 36 true 37 } 38 } else { 39 true 40 } 41 } 42 override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) { 43 super.onActivityResult(requestCode, resultCode, data) 44 if (requestCode == START_SETTING_INSTALL \u0026amp;\u0026amp; resultCode == Activity.RESULT_OK) { 45 AppDownloadInstallManager.get().installApk(this, AppDownloadInstallManager.get().currentTask!!.taskId) 46 } 47 } 48 override fun onResume() { 49 super.onResume() 50 if (AppDownloadInstallManager.get().currentTask != null) { 51 if (AppDownloadInstallManager.get().currentTask!!.taskStatus == DownloadManager.STATUS_SUCCESSFUL) { 52 AppDownloadInstallManager.get().installApk(this, AppDownloadInstallManager.get().currentTask!!.taskId) 53 } 54 } 55 AppDownloadInstallManager.get().setDownloaderListener(this) 56 } 57 override fun onPause() { 58 super.onPause() 59 AppDownloadInstallManager.get().setDownloaderListener(null) 60 } 61 override fun onProgress(task: AppDownloadInstallManager.Task) { 62 tv_data.text = \u0026#34;${task.taskStatus}\\n${task.currentBytes}\\n${task.totalBytes}\u0026#34; 63 } 64 override fun onComplete(task: AppDownloadInstallManager.Task) { 65 tv_data.text = task.taskStatus.toString() 66 if (isInstallPermission()) { 67 AppDownloadInstallManager.get().installApk(this@VersionUpgradeActivity, task.taskId) 68 } 69 } 70 override fun fail(task: AppDownloadInstallManager.Task) { 71 tv_data.text = task.taskStatus.toString() 72 } 73} 简单的使用就是这些.\n","date":"2020-03-11","img":"","permalink":"https://helixs.github.io/posts/2020-03-11-android%E8%B0%83%E7%94%A8downloadmanager%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%E5%8F%8A%E5%AE%89%E8%A3%85apk%E5%85%BC%E5%AE%B9678/","series":null,"tags":["DownloadManager"],"title":"Android调用DownloadManager下载文件及安装apk，兼容6、7、8+"},{"categories":["linux常用配置"],"content":"更新系统软件后，非正常关机，出现了\n1couldn\u0026#39;t find an input interrupt 2dev/sda1 contains a file system with errors, check forced. 3Inodes that were part of a corrupted orphan linked list found. 4 5/dev/sda1: UNEXPECTED INCONSISTENCY: RUN fsck MANUALLY. 6 (i.e., without -a or -p options) 7fsck exited with status code 4 8The root filesystem on /dev/sda1 requires a manual fsck 9 10BusyBox v1.22.1 (Ubuntu 1:1.22.0-19ubuntuu2) built-in shell (ash) 11Enter \u0026#39;help\u0026#39; for a list of built-in commands. 12 13(initramfs)_ 14 1#键入 #以检查/修复您的文件系统。 2fsck -f /dev/sda1 ","date":"2020-02-29","img":"","permalink":"https://helixs.github.io/posts/2020-02-29-ubuntu%E5%BC%80%E6%9C%BA%E9%94%99%E8%AF%AF-couldnt-find-an-input-interrupt-dev-sda1-contains-a-file-system-with-errors/","series":null,"tags":null,"title":"Ubuntu开机错误 Couldn’t Find an Input Interrupt /Dev/Sda1 Contains a File System With Errors"},{"categories":["Android开发"],"content":"大多数简单的Android应用我们都是直接startActivity启动和finish完成销毁。慢慢我们根据应用的各个场景及跳转复杂度开始使用了lanchMode诸如singleTask singleTop，NewTask等等。用是用了，但是用的是不清不楚不明不白，倘若面试疑问就是一脸懵逼。今天着重看看Task栈和finishAffinity的用法，不过在这之前还是找找启动模式的一些资料，先到网上翻阅，看看人们是怎么说的。\n Activity 启动模式和任务栈https://github.com/TomeOkin/Learning-Notes/wiki/1.2-Activity-%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F%E5%92%8C%E4%BB%BB%E5%8A%A1%E6%A0%88  任务栈（tasks-and-back-stack） 创建任务栈 在两种情况下，有可能会创建一个新的任务栈：\n（1）以FLAG_ACTIVITY_NEW_TASK方式启动一个 activity；\n（2）在AndroidManifest.xml中配置了android:taskAffinity。\n如果我们使用startActivity启动一个 Activity，没有添加任何 flag 时，新启动的 Activity 会与调用startActivity的 Activity 位于同一个任务栈中；在默认情况下，应用内的所有 Activity 都会被存放在以包名命名的任务栈中。\n当我们以FLAG_ACTIVITY_NEW_TASK方式启动一个 Activity 时，如果某个任务栈里已经有该 Activity 了，那么会将该任务栈从后台切换到前台，也即从停止状态切换到活跃状态，否则先创建一个新的任务栈，将创建一个 Activity 实例，将该实例作为 Root Activity（任务栈最底部的 Activity）。\n如果在当前的任务栈中，按照FLAG_ACTIVITY_NEW_TASK 启动当前根Activity是无法启动的。如果同样方式启动android:taskAffinity 一致但是Activity不一样也不会启动新的任务栈，而是在当前任务栈启动一个新的Activity。\n笔者试了一下，在默认的lanchMode下，如果要使用FLAG_ACTIVITY_NEW_TASK切换任务栈或者创建新的任务栈要同时满足两个需求，\n  1、当且仅当当前任务栈的RootActivityandroid:taskAffinity和被启动的Activity的android:taskAffinity不一致\n  2、如果要切换在后台的任务栈，需要满足被启动的Acitivity在其他某个任务栈的作为Root节点，\n  相应的，你看看在没有魔改的android系统的多任务栏切换是不是多了那么多个taskAffinity窗口呢，哈哈~~~所以看看微信小程序是不是也是动态生成的小程序的任务栈。 不过，如果同时也添加了 Intent.FLAG_ACTIVITY_MULTIPLE_TASK 属性，那么系统会无条件创建一个新的任务栈。\n如果要启动的 Activity 配置了 android:taskAffinity，那么系统会将该 Activity 放到对应的任务栈中。\n销毁任务栈  当我们从最近任务中移除对应的任务时，该任务栈也会被移除。从 Android 5.x 起，重启后任务栈可以被恢复。（see[持久化的任务栈][持久化的任务栈]） 当任务栈中已经没有 Activity 时，该任务栈会被自动销毁。 当系统内存较少时，任务栈也有可能被移除，只保留重建该任务栈需要的信息。  当任务栈被销毁时，之前在任务栈中的 Activity 关联的服务会触发 onTaskStopped() 回调，可以决定是否要结束服务；如果在 AndroidManifest.xml 设置 android:stopWithTask=\u0026quot;true\u0026quot;（默认 false），则不会接收到该回调，同时服务会自动被销毁。不过在 Android 4.4 上，由于存在 bug（参 Issue 104308和 Issue 63618），即使没有设置 android:stopWithTask=\u0026quot;true\u0026quot;，当任务栈被销毁时，对应的服务也会被销毁。\n当任务栈是正常销毁的（比如通过最近历史销毁），Activity 的 onDestroy 会被调用，然而如果是被异常结束（如通过第三方应用结束），则 onDestroy 不会被调用。\n恢复任务栈 有四种情况下会恢复一个任务栈，\n 通过最近运行历史启动一个任务栈； 以 FLAG_ACTIVITY_NEW_TASK 且非 FLAG_ACTIVITY_MULTIPLE_TASK 方式运行一个已经运行过的 Activity； if the taskAffinity for the activity being started ties it to another task if the launch mode for the activity being started ties it to another task  使用 flag 实现 Activity 实例的复用 默认情况下，启动一个 Activity 时，会创建一个新的实例，要改变这种行为，可以使用 flag 或者启动模式。\n FLAG_ACTIVITY_REORDER_TO_FRONT：如果某任务栈中存在要启动的 Activity 的实例，则将其调整到栈顶。调整到栈顶的过程中不会清除其上的实例。**（其实就是调换启动的acitivity顺序，ABCD-\u0026gt;FLAG_ACTIVITY_REORDER_TO_FRONT-\u0026gt;B=ACDB）当然，启动这个activity没有此实例创建时，就会正常启动onCreate 。**如果已经添加了 FLAG_ACTIVITY_CLEAR_TOP，则该 flag 会被忽略。 FLAG_ACTIVITY_CLEAR_TASK：如果某任务栈中存在要启动的 Activity，则将该 Activity 之外的其他 Activity 清除，将其作为 Root Activity。一般与 FLAG_ACTIVITY_NEW_TASK 组合使用（单独使用没啥效果。在一起使用的时候，如果当前只有一个任务栈，那么就会清除当前的任务栈所有的Activity，就算被启动的Activity在当前其中已经有了也会清除，然后启动新的Activity作为Root节点，栈本身没有被清理。如果其他任务栈当中含有要启动的Activity，就会清理其它任务栈，创建新的Activity，但是不会清除当前的任务栈。清空当前task栈，然后在一个新的task栈中启动activity，但是并不是一定会在一个新的task栈中启动activity。如果系统为该activity找到一个极具亲和力（taskAffinity的值相等）的task栈，就不会在新的task栈中启动Activity。———-换而言之，如果taskAffinity是一样的，那么就可能清空与被启动的taskAffinity一样的Root栈所在的task们）。如果想要每次启动该 Activity 时都具有该行为，可以设置 android:clearTaskOnLaunch=\u0026ldquo;true\u0026rdquo;。 FLAG_ACTIVITY_RESET_TASK_IF_NEEDED：如果某任务栈中已经存在该 Activity 了，则启动该 Activity 或者位于其上方合适的 Activity（触发[Reparenting Tasks] [Reparenting Tasks]）。比如存在 A 启动 B，此时以 FLAG_ACTIVITY_RESET_TASK_IF_NEEDED 方式启动 A，则会显示 B；如果使用的是 FLAG_ACTIVITY_CLEAR_TASK，则显示的是 A。一般，桌面启动器启动一个 Activity 时，使用的就是 FLAG_ACTIVITY_NEW_TASK 和 FLAG_ACTIVITY_RESET_TASK_IF_NEEDED。(比如我们在应用主界面要选择一个图片，然后我们启动了图片浏览界面，但是把这个应用从后台恢复到前台时，为了避免让用户感到困惑，我们希望用户仍然看到主界面，而不是图片浏览界面，这个时候我们就要在转到图片浏览界面时的Intent中加入此标记)   对于合适的 Activity，有如下要求：\n（1）该 Activity 不是以 FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET 方式启动。\n（2）该 Activity 不是位于某个以 FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET 方式启动的 Activity 之上。\n比如：存在任务栈中存在 A - B - C - D，C 是以 FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET 方式启动的，此时如果我们以 FLAG_ACTIVITY_RESET_TASK_IF_NEEDED 方式启动 A 或 B，都会显示的是 B。\nReparenting Tasks 一个 Activity 实例所属的任务栈可以被改变。\n通过配置 android:allowTaskReparenting=\u0026quot;true\u0026quot;，我们可以实现一个特殊的效果。例如，如果应用 B 启动了 A 的一个 Activity，接着回到桌面，如果这时我们访问 A 的默认 Activity，会出现被调用的 Activity。也即该 Activity 实例从 B 的某个任务栈中转移到 A 的某个任务栈（包括新建的）中，并作为要显示的 Activity。默认情况下（没有特别指定所属的任务栈）， 启动一个 Activity 时，如果存在设置了 android:allowTaskReparenting=\u0026quot;true\u0026quot; 的 Activity，并且其他任务栈中找到了对应的实例，就将其挪到应用默认的任务栈中。\n自动销毁的 Activity 在某些情况下，我们想要在离开某些 Activity 时，将其销毁。除了可以使用 finish 来完成，还可以使用 android:noHistory 或 FLAG_ACTIVITY_NO_HISTORY 来实现。对于这类 Activity，是不能使用 startActivityForResult() 来启动的。\nandroid:finishOnTaskLaunch 也会自动销毁 Activity，不过是在重新会到该 Activity 的时候才销毁旧的 Activity。\nalwaysRetainTaskState 默认情况下，如果一个任务栈超过一定的时间没有访问（30分钟以上），那么下次访问就会回到 Root Activity。如果不希望出现这种情况，可以给 Root Activity 设置 android:alwaysRetainTaskState=\u0026quot;true\u0026quot;。\n不显示最近历史记录的 Activity 同样的，可以通过 android:excludeFromRecents=\u0026quot;true\u0026quot; 或者 FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS 来设置，不过只适用于 Root Activity。\n持久化的任务栈 默认情况下，当任务栈被销毁后，如果从最近任务中访问该任务栈，则只会显示任务栈里的 Root Activity。5.x 起，应用可以为 Activity 配置独立的持久化数据，用于在重建任务栈时恢复原来的执行状态。在进行任务栈重建时，会先执行以下方法对应的单参数版本，然后执行该方法：\n1 public void onCreate(Bundle savedInstanceState, PersistableBundle persistentState); 2 public void onRestoreInstanceState(Bundle savedInstanceState, PersistableBundle persistentState); 3 public void onSaveInstanceState(Bundle outState, PersistableBundle outPersistentState); 需要注意的是 PersistableBundle 中 不能存放Parcelable 或 Serializable 类型的数据。\n而至于恢复到哪个 Activity，则取决与 Root Activity 的 persistableMode:\n persistNever：重启不持久化。 persistRootOnly：默认，只持久化 Root Activity。 persistAcrossReboots：持久化所有设置了 persistAcrossReboots 并且不是以 FLAG_CLEAR_TASK_WHEN_RESET 启动的 Activity。  Document 5.x 起，Android 还支持一种称为 Document 的启动模式。这种模式有点类似浏览器的多标签页，比如用户打开了多个文档，每个文档都有独立的上下文，反映在最近运行任务列表里，每一个文档都有一个独立的项。\n使用方法有两种： （1）设置 android:documentLaunchMode：\n always：总是在新 document 中启动； intoExisting：由同一个类、启动意图的 Uri 相同的，都放到同一个 document 中。 never：该 Activity 不以新 document 的形式启动。 none：默认，只有当使用 flags 声明要以新 document 方式启动才会以新 document 方式启动。  （2）设置 flags：\n FLAG_ACTIVITY_NEW_DOCUMENT：效果与 intoExisting相似，如果要效果类似 always，则还应该设置 Intent.FLAG_ACTIVITY_MULTIPLE_TASK。  默认情况下，系统不会自动去除 document，如果需要自动去除 document，可以在 Root Activity 上使用 android:maxRecents 设置最多要保留的 document 数量，系统会自动应用 LRU 算法来确定要保留哪些 document。默认情况下，android:maxRecents 的值为 16。另外，还可以设置 android:autoRemoveFromRecents=\u0026quot;true\u0026quot;，这样当 Root Activity 退出时，document 就会被清除。如果要手动清除，也可以使用 finishAndRemoveTask()（see [与任务栈操作有关的其他方法][与任务栈操作有关的其他方法]）。\n启动模式与返回值的情况  与任务栈操作有关的其他方法\n finishAffinity()：清除当前任务栈中自身以及所有与当前 Activity 具有相同 taskAffinity 的 Activity，如果当前任务栈中存在多种的 taskAffinity，只会清除那些相同的。 finishAndRemoveTask()：立刻清除当前任务栈中的所有 Activity 和任务栈。比如在退出登录时，就可以执行 finishAndRemoveTask()，接着启动登录页面。 getTaskId()：获得当前 Activity 所在的任务栈 Id。（测试时，可以用 android.os.Process.myPid() 获得进程 Id） isTaskRoot()：判断是否是 Root Activity。 moveTaskToBack()：将任务栈切换到后台中，类似与点击 Home 键的效果。(据说退出微信的时候就是这样的) setTaskDescription()：Android 5.0 起，可以使用该方法修改 ActivityManager.TaskDescription，以更改历史任务窗口中当前任务栈的图标、标题、标题背景颜色、缩略图等。   下文感谢https://www.jianshu.com/p/0d08f7f98666  常用Intent Flags\n Intent.FLAG_ACTIVITY_NEW_TASK 这个是最常用的，但是往往会被误解，在程序根Activity的Task栈里加此标识开启新Activity都不会创建新的Task，只有当另一程序（进程）启动带有改标识的Activity时，才会创建新的Task。如果配合FLAG_ACTIVITY_NEW_MULTI_TASK，则无论什么情况都会创建新的Task，就成了类似 singleInstance 的情况了（singleInstance中的Activity独占一个栈）。如果配合 FLAG_ACTIVITY_CLEAR_TASK，则会先清空该栈，然后向栈中添加目标Activity，栈ID不变。     Intent.FLAG_ACTIVITY_CLEAR_TOP 有些文章中直接把该Flag说成作用和singleTask 相同，这是大错特错的。 如果在ABCD的堆栈状态下，以该标识启动B，则会销毁CD，且B也是重新创建的（与singleTask有区别），如果配合FLAG_ACTIVITY_SINGLE_TOP，则就会成为 singleTask 的模式.     Intent.FLAG_ACTIVITY_SINGLE_TOP 同singleTop启动模式.     Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT 这个Flag主要用来改变Task堆栈顺序，如果在ABCD的状态下，以该标识启动B，则会成为ACDB，且B不会重新创建     Intent.FLAG_ACTIVITY_REORDER_TO_FRONT 这个Flag主要用来改变Task堆栈顺序，如果在ABCD的状态下，以该标识启动B，则会成为ACDB，且B不会重新创建     Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED 这个标识主要用于创建一个还原点，再次启动该Task时会将还原点之上包括其本身都销毁掉，如果在一个程序中以该标识启动了另外一个程序的功能，如一个用于看图的软件，当退出桌面，再点击这个程序，看图软件会消失。     Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS 有此标识的 Activity 不会出现在历时列表里.     Intent.FLAG_ACTIVITY_FORWARD_RESULT 如果设置，并且该intent会启动一个新的Activity，则返回消息的目标会从当前Activity转移到新的Activity中。（在这个案例中，返回消息的目标最开始为B）   ","date":"2019-12-16","img":"","permalink":"https://helixs.github.io/posts/2019-12-16-android%E5%AF%B9finishaffinity%E7%9A%84%E7%AE%80%E5%8D%95%E8%AE%A4%E8%AF%86/","series":null,"tags":["启动模式"],"title":"Android对finishAffinity的简单认识"},{"categories":["Android开发","编程生活"],"content":"MaterialButton和MaterialCardView的都新增了边框属性，我们没必要为了一个边框写那么多shape，一旦多了谁着得住。\n1、在使用MaterialButton注意一点是它必须设置android:textAppearance属性，不然会崩溃 This component requires that you specify a valid TextAppearance attribute. Update your app theme to inherit from Theme.MaterialComponents (or a descendant)\r\n1public MaterialButton(Context context, AttributeSet attrs, int defStyleAttr) { 2 super(context, attrs, defStyleAttr); 3 TypedArray attributes = ThemeEnforcement.obtainStyledAttributes(context, attrs, styleable.MaterialButton, defStyleAttr, style.Widget_MaterialComponents_Button, new int[0]); 4 this.iconPadding = attributes.getDimensionPixelSize(styleable.MaterialButton_iconPadding, 0); 5 this.iconTintMode = ViewUtils.parseTintMode(attributes.getInt(styleable.MaterialButton_iconTintMode, -1), Mode.SRC_IN); 6 this.iconTint = MaterialResources.getColorStateList(this.getContext(), attributes, styleable.MaterialButton_iconTint); 7 this.icon = MaterialResources.getDrawable(this.getContext(), attributes, styleable.MaterialButton_icon); 8 this.iconGravity = attributes.getInteger(styleable.MaterialButton_iconGravity, 1); 9 this.iconSize = attributes.getDimensionPixelSize(styleable.MaterialButton_iconSize, 0); 10 this.materialButtonHelper = new MaterialButtonHelper(this); 11 this.materialButtonHelper.loadFromAttributes(attributes); 12 attributes.recycle(); 13 this.setCompoundDrawablePadding(this.iconPadding); 14 this.updateIcon(); 15 } 1private static void checkTextAppearance(Context context, AttributeSet set, @StyleableRes int[] attrs, @AttrRes int defStyleAttr, @StyleRes int defStyleRes, @StyleableRes int... textAppearanceResIndices) { 2 TypedArray themeEnforcementAttrs = context.obtainStyledAttributes(set, styleable.ThemeEnforcement, defStyleAttr, defStyleRes); 3 boolean enforceTextAppearance = themeEnforcementAttrs.getBoolean(styleable.ThemeEnforcement_enforceTextAppearance, false); 4 if (!enforceTextAppearance) { 5 themeEnforcementAttrs.recycle(); 6 } else { 7 boolean validTextAppearance; 8 if (textAppearanceResIndices != null \u0026amp;\u0026amp; textAppearanceResIndices.length != 0) { 9 validTextAppearance = isCustomTextAppearanceValid(context, set, attrs, defStyleAttr, defStyleRes, textAppearanceResIndices); 10 } else { 11 validTextAppearance = themeEnforcementAttrs.getResourceId(styleable.ThemeEnforcement_android_textAppearance, -1) != -1; 12 } 13 themeEnforcementAttrs.recycle(); 14 if (!validTextAppearance) { 15 throw new IllegalArgumentException(\u0026#34;This component requires that you specify a valid TextAppearance attribute. Update your app theme to inherit from Theme.MaterialComponents (or a descendant).\u0026#34;); 16 } 17 } 18 } 它会检查textApearance属性，解决方式有两种如下:\n1、添加它就好\n1android:textAppearance=\u0026#34;?android:attr/textAppearanceButton\u0026#34; 2、application或activity或控件的theme继承自Theme.MaterialComponents.xxxx,使type能够找到这个属性，如\n1\u0026lt;com.google.android.material.button.MaterialButton 2 android:id=\u0026#34;@+id/btn_ok\u0026#34; 3 android:layout_width=\u0026#34;0dp\u0026#34; 4 android:layout_height=\u0026#34;wrap_content\u0026#34; 5 android:layout_marginTop=\u0026#34;18dp\u0026#34; 6 android:gravity=\u0026#34;center\u0026#34; 7 android:text=\u0026#34;确认办理\u0026#34; 8 android:textColor=\u0026#34;#ffffffff\u0026#34; 9 android:textSize=\u0026#34;24sp\u0026#34; 10 android:visibility=\u0026#34;visible\u0026#34; 11 app:backgroundTint=\u0026#34;#FFA54C\u0026#34; 12 android:theme=\u0026#34;@style/Theme.MaterialComponents.Light.DarkActionBar\u0026#34; 13 app:layout_constraintBottom_toBottomOf=\u0026#34;parent\u0026#34; 14 app:layout_constraintEnd_toEndOf=\u0026#34;parent\u0026#34; 15 app:layout_constraintStart_toStartOf=\u0026#34;parent\u0026#34; /\u0026gt; 其实想了想，也许以后MaterialComponents的text相关组件都会进行这种操作吧。\n2、在使用MaterialButton时候可能遇到背景颜色不能充满控件的问题。 如果按照以前默认的方式添加背景颜色，我们发现背景颜色不能充满上下编剧，我们对比使用appcompatButton\n1\u0026lt;androidx.appcompat.widget.AppCompatButton 2 android:id=\u0026#34;@+id/btn_cancel\u0026#34; 3 android:layout_width=\u0026#34;0dp\u0026#34; 4 android:layout_height=\u0026#34;wrap_content\u0026#34; 5 android:layout_marginTop=\u0026#34;18dp\u0026#34; 6 android:gravity=\u0026#34;center\u0026#34; 7 android:text=\u0026#34;确认办理\u0026#34; 8 android:textColor=\u0026#34;#ffffffff\u0026#34; 9 android:textSize=\u0026#34;24sp\u0026#34; 10 android:theme=\u0026#34;@style/Theme.MaterialComponents.Light\u0026#34; 11 android:visibility=\u0026#34;visible\u0026#34; 12 android:background=\u0026#34;#FFA54C\u0026#34; 13 14 app:layout_constraintBottom_toTopOf=\u0026#34;@id/btn_ok\u0026#34; 15 app:layout_constraintEnd_toEndOf=\u0026#34;parent\u0026#34; 16 app:layout_constraintStart_toStartOf=\u0026#34;parent\u0026#34; /\u0026gt; 17 \u0026lt;com.google.android.material.button.MaterialButton 18 android:id=\u0026#34;@+id/btn_ok\u0026#34; 19 android:layout_width=\u0026#34;0dp\u0026#34; 20 android:layout_height=\u0026#34;wrap_content\u0026#34; 21 android:layout_marginTop=\u0026#34;18dp\u0026#34; 22 android:gravity=\u0026#34;center\u0026#34; 23 android:text=\u0026#34;确认办理\u0026#34; 24 android:textColor=\u0026#34;#ffffffff\u0026#34; 25 android:textSize=\u0026#34;24sp\u0026#34; 26 android:theme=\u0026#34;@style/Theme.MaterialComponents.Light\u0026#34; 27 android:visibility=\u0026#34;visible\u0026#34; 28 android:background=\u0026#34;#FFA54C\u0026#34; 29 app:layout_constraintBottom_toBottomOf=\u0026#34;parent\u0026#34; 30 app:layout_constraintEnd_toEndOf=\u0026#34;parent\u0026#34; 31 app:layout_constraintStart_toStartOf=\u0026#34;parent\u0026#34; /\u0026gt; 1、从上面的图片可以看出它们的背景颜色不一样。MaterialButton是不受android:background控制的，官方建议我们设置app:backgroundHint来进行背景的更改。\n2、AppCompatButton如果设置了android:background会覆盖上下左右的间距，MaterialButton则不会\n3、MaterialButton设置了app:backgroundHint左右是没有间距的，而上下有。AppCompatButton设置了app:backgroundHint是上下左右都有间距\n找到原因https://github.com/material-components/material-components-android/blob/master/docs/components/MaterialButton.md#attributes Note:MaterialButtonis visually different fromButtonandAppCompatButton. One of the main differences is thatAppCompatButtonhas a4dpinset on the left and right sides, whereasMaterialButtondoes not. To add an inset to matchAppCompatButton, setandroid:insetLeftandandroid:insetRighton the button to4dp, or change the spacing on the button\u0026rsquo;s parent layout.\n反正AppCompatButton左右留了4个dp的占位，而MaterialButton没有。\n试验\n1\u0026lt;com.google.android.material.button.MaterialButton 2 android:id=\u0026#34;@+id/btn_ok\u0026#34; 3 android:layout_width=\u0026#34;0dp\u0026#34; 4 android:layout_height=\u0026#34;wrap_content\u0026#34; 5 android:layout_marginTop=\u0026#34;18dp\u0026#34; 6 android:gravity=\u0026#34;center\u0026#34; 7 android:padding=\u0026#34;5dp\u0026#34; 8 app:cornerRadius=\u0026#34;0dp\u0026#34; 9 android:insetLeft=\u0026#34;50dp\u0026#34; 10 android:insetTop=\u0026#34;0dp\u0026#34; 11 android:insetBottom=\u0026#34;0dp\u0026#34; 12 android:insetRight=\u0026#34;50dp\u0026#34; 13 android:textAppearance=\u0026#34;@style/Widget.MaterialComponents.Button\u0026#34; 14 android:text=\u0026#34;确认办理\u0026#34; 15 android:textColor=\u0026#34;#ffffffff\u0026#34; 16 android:textSize=\u0026#34;24sp\u0026#34; 17 android:visibility=\u0026#34;visible\u0026#34; 18 app:backgroundTint=\u0026#34;#FFA54C\u0026#34; 19 app:layout_constraintBottom_toBottomOf=\u0026#34;parent\u0026#34; 20 app:layout_constraintEnd_toEndOf=\u0026#34;parent\u0026#34; 21 app:layout_constraintStart_toStartOf=\u0026#34;parent\u0026#34;/\u0026gt; 通过设置上下左右inset控制button绘制的范围，背景颜色也能控制。那么我们就解决了这个问题了\n方案：\n设置insetTop和insetBottom为0dp\n","date":"2019-11-28","img":"","permalink":"https://helixs.github.io/posts/2019-11-28-android-materialbutton%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/","series":null,"tags":["matrialButton"],"title":"Android MaterialButton的一些问题"},{"categories":["未分类"],"content":"KMP算法 Knuth-Morris-Pratt(克努斯-莫里斯-普拉特)字符串查找算法。\n可在一个主文本字符串S内查找一个词W的出现位置。此算法通过运用对这个词在不匹配时本身就包含足够的信息来确定下一个匹配将在哪里开始的发现，从而避免重新检查先前匹配的字符。这个算法是由高德纳和沃恩·普拉特在1974年构思，同年詹姆斯·H·莫里斯也独立地设计出该算法，最终由三人于1977年联合发表。\n朴素模式匹配算法 了解KMP之前我们先来想想用最简单的方式匹配字符串\n有很长一段字符串S，我们想要从S中匹配字符串P，得到匹配到P后分别在S(p)出的position的位置，也可以是指针位置。\n我们用最简单的朴素模式匹配算法来匹配(该算法也称布鲁特-福斯算法，其基本思想是从主串S的第一个字符起与模式串P的第一个字符比较，若相等，则继续逐一对字符进行后续的比较，否则从主串S第二个字符起与模式串P的第一个字符重新比较，知道模式串中每个字符依次和主串中第一个连续的字符序列相等时位置，此时成为匹配成功)\n 1  首先，字符串”BBC ABCDAB ABCDABCDABDE”的第一个字符与搜索词”ABCDABD”的第一个字符，进行比较。因为B与A不匹配，所以搜索词后移一位。\n 2  因为B与A不匹配，搜索词再往后移。\n3、\n就这样，直到字符串有一个字符，与搜索词的第一个字符相同为止。\n4、\n接着比较字符串和搜索词的下一个字符，还是相同。\n5、\n直到字符串有一个字符，与搜索词对应的字符不相同为止。\n6、\n这时，最自然的反应是，将搜索词整个后移一位，再从头逐个比较。这样做虽然可行，但是效率很差，因为你要把”搜索位置”移到已经比较过的位置，重比一遍。\n1#include\u0026lt;stdio.h\u0026gt;2#include\u0026lt;stdlib.h\u0026gt;3#include\u0026lt;string.h\u0026gt;4int ViolentMatch(char* s, char* p) { 5 int sLen = strlen(s); 6 int pLen = strlen(p); 7 int i = 0; 8 int j = 0; 9 while (i \u0026lt; sLen \u0026amp;\u0026amp; j \u0026lt; pLen) { 10 if (s[i] == p[j]) { 11 //①如果当前字符匹配成功（即S[i] == P[j]），则i++，j++ 12 i++; 13 j++; 14 } else { 15 //②如果失配（即S[i]! = P[j]），令i = i - (j - 1)，j = 0 16 i = i - j + 1; 17 j = 0; 18 } 19 } 20 //匹配成功，返回模式串p在文本串s中的位置，否则返回-1 21 if (j == pLen) 22 return i - j; 23 else 24 return -1; 25} 这种方法最然最易看懂，不过时间复杂度那是相当的高呀。\n使用KMP算法 ","date":"2019-10-18","img":"","permalink":"https://helixs.github.io/posts/2019-10-18-%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%E4%B9%8Bkmp%E5%8F%8Anext%E6%95%B0%E7%BB%84/","series":null,"tags":null,"title":"匹配算法之KMP及Next数组"},{"categories":["Android开发","java"],"content":"作为一个普通的Android开发者来说，平常布布控件和各种框架的情况下，接触线程的地方少之又少，更别提线程池了。以前基础差，做项目的时候牵扯到异步操作的时候呢都是直接Thread+handler根本没考虑后果，做完事就行。面试的时候就是被按在地上一顿摩擦。\n在alibaba开发手册上，这样写到：\n 【强制】新建线程时，必须通过线程池提供（AsyncTask 或者ThreadPoolExecutor或者其他形式自定义的线程池），不允许在应用中自行显式创建线程。 说明：使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。另外创建匿名线程不便于后续的资源使用分析，对性能分析等会造成困扰。\n 所以我们在进阶开发的时候特别涉及到大量数据操作的时候很有必要使用线程池来管理我们的线程任务。\n线程池创建 Android中常用的线程池都是通过对ThreadPoolExecutor进行不同配置来实现的，下面是它的构造方法\n1/** 2* Creates a new {@code ThreadPoolExecutor} with the given initial 3* parameters. 4* 5* @param corePoolSize the number of threads to keep in the pool, even 6* if they are idle, unless {@code allowCoreThreadTimeOut} is set 7* @param maximumPoolSize the maximum number of threads to allow in the 8* pool 9* @param keepAliveTime when the number of threads is greater than 10* the core, this is the maximum time that excess idle threads 11* will wait for new tasks before terminating. 12* @param unit the time unit for the {@code keepAliveTime} argument 13* @param workQueue the queue to use for holding tasks before they are 14* executed. This queue will hold only the {@code Runnable} 15* tasks submitted by the {@code execute} method. 16* @param threadFactory the factory to use when the executor 17* creates a new thread 18* @param handler the handler to use when execution is blocked 19* because the thread bounds and queue capacities are reached 20* @throws IllegalArgumentException if one of the following holds:\u0026lt;br\u0026gt; 21* {@code corePoolSize \u0026lt; 0}\u0026lt;br\u0026gt; 22* {@code keepAliveTime \u0026lt; 0}\u0026lt;br\u0026gt; 23* {@code maximumPoolSize \u0026lt;= 0}\u0026lt;br\u0026gt; 24* {@code maximumPoolSize \u0026lt; corePoolSize} 25* @throws NullPointerException if {@code workQueue} 26* or {@code threadFactory} or {@code handler} is null 27*/ 28 public ThreadPoolExecutor(int corePoolSize, 29 int maximumPoolSize, 30 long keepAliveTime, 31 TimeUnit unit, 32 BlockingQueue\u0026lt;Runnable\u0026gt; workQueue, 33 ThreadFactory threadFactory, 34 RejectedExecutionHandler handler)  corePoolSize 线程池中核心线程的数量 maximumPoolSize 线程池中最大线程数量（其中包括了核心线程） keepAliveTime 当线程数大于核心时，这是多余的空闲线程在终止之前等待新任务的最长时间，也就是非核心线程的超时时长，当系统中非核心线程闲置时间超过keepAliveTime之后，则会被回收。如果ThreadPoolExecutor的allowCoreThreadTimeOut属性设置为true，则该参数也表示核心线程的超时时长 unit keepAliveTime 的时间单位多数情况下按照秒和毫秒来做 workQueue BlockingQueue的实现类 在执行任务之前用于保留任务的队列。该队列将仅保存由ThreadPoolExecutor.execute方法提交的 Runnable任务。这也是我们这片文章的重点内容 threadFactory 线程池在创建线程的工厂类，如果不传入默认会有一个Executors.defaultThreadFactory() handler 拒绝策略，当线程无法执行新任务时（一般是由于线程池中的线程数量已经达到最大数或者线程池关闭导致的），默认情况下，当线程池无法处理新线程时，会抛出一个RejectedExecutionException。  了解到了它的构造方法后我们来捋一捋，看一下ThreadPoolExecutor.execute方法\n1/** 2* Executes the given task sometime in the future. The task 3* may execute in a new thread or in an existing pooled thread. 4* 5* If the task cannot be submitted for execution, either because this 6* executor has been shutdown or because its capacity has been reached, 7* the task is handled by the current {@code RejectedExecutionHandler}. 8* 9* @param command the task to execute 10* @throws RejectedExecutionException at discretion of 11* {@code RejectedExecutionHandler}, if the task 12* cannot be accepted for execution 13* @throws NullPointerException if {@code command} is null 14*/ 15 public void execute(Runnable command) { 16 if (command == null) 17 throw new NullPointerException(); 18 /* 19* Proceed in 3 steps: 20* 21* 1. If fewer than corePoolSize threads are running, try to 22* start a new thread with the given command as its first 23* task. The call to addWorker atomically checks runState and 24* workerCount, and so prevents false alarms that would add 25* threads when it shouldn\u0026#39;t, by returning false. 26* 27* 2. If a task can be successfully queued, then we still need 28* to double-check whether we should have added a thread 29* (because existing ones died since last checking) or that 30* the pool shut down since entry into this method. So we 31* recheck state and if necessary roll back the enqueuing if 32* stopped, or start a new thread if there are none. 33* 34* 3. If we cannot queue task, then we try to add a new 35* thread. If it fails, we know we are shut down or saturated 36* and so reject the task. 37*/ 38 int c = ctl.get(); 39 if (workerCountOf(c) \u0026lt; corePoolSize) { 40 if (addWorker(command, true)) 41 return; 42 c = ctl.get(); 43 } 44 if (isRunning(c) \u0026amp;\u0026amp; workQueue.offer(command)) { 45 int recheck = ctl.get(); 46 if (! isRunning(recheck) \u0026amp;\u0026amp; remove(command)) 47 reject(command); 48 else if (workerCountOf(recheck) == 0) 49 addWorker(null, false); 50 } 51 else if (!addWorker(command, false)) 52 reject(command); 53 } ctl是AtomicInteger类型，(里面保存了当前线程池中有效线程数量count和当前线程池运行的状态runState，count的增减同步，保证每次get的时候数量是最新的，所谓的原子性。每次我们都只用get的值，里面是用位运算符关联两个值的。位运算我一脸懵逼反正它保存了两个值了)。如果当前运行的线程的数量小于核心线程数量(就是我们在构造方法传入的corePoolSize)，那么就正常添加并执行任务。如果没有添加成功，就继续检查当前线程池的运行状态，如果还是在运行中，那么尝试通过blockingQueue的offer方法(记住只有offer方法，后面讲的那么这个线程池没用上)把Runnable放到任务队列中（后续核心线程如果有任务完成，那么就从这个队列中使用take方法取出Runnable放入到核心线程去执行任务）。如果加入成功到队列中，检查线程池状态，如果线程池在运行，那么就删除添加的Runnable，如果一切成功就抛出RejectedExecutionException。后面都看得懂就不解释了。\n过程如下\n   execute一个线程之后，如果线程池中的线程数未达到核心线程数，则会立马启用一个核心线程去执行。    execute一个线程之后，如果线程池中的线程数已经达到核心线程数，且workQueue未满，则将新线程放入workQueue中等待执行。    execute一个线程之后，如果线程池中的线程数已经达到核心线程数但未超过非核心线程数，且workQueue已满，则开启一个非核心线程来执行任务。    execute一个线程之后，如果线程池中的线程数已经超过非核心线程数，则拒绝执行该任务。    BlockingQueue 下面引入网上对BlockingQueue的主要方法的解释\n    抛出异常 特殊值 阻塞 超时     插入 add(e) offer(e) put(e) offer(e,time,unit)   移除 remove() poll() take() poll(time, unit)   检查 element() peek() 不可用 不可用     add(anObject): 把anObject加到BlockingQueue里,即如果BlockingQueue可以容纳,则返回true,否则IllegalStateException(“Deque full”); offer(anObject): 表示如果可能的话,将anObject加到BlockingQueue里,即如果BlockingQueue可以容纳,则返回true,否则返回false.  put(anObject):把anObject加到BlockingQueue里,如果BlockQueue没有空间,则调用此方法的线程被阻断直到BlockingQueue里面有空间再继续. poll(time):取走BlockingQueue里排在首位的对象,若不能立即取出,则可以等time参数规定的时间,取不到时返回null take():取走BlockingQueue里排在首位的对象,若BlockingQueue为空,阻断进入等待状态直到Blocking有新的对象被加入为止  其中：BlockingQueue 不接受 null 元素。试图add、put或offer一个null元素时，某些实现会抛出NullPointerException。null 被用作指示poll操作失败的警戒值。\n它是一个特殊的队列，当我们从BlockingQueue中取数据时，如果BlockingQueue是空的，则取数据的操作会进入到阻塞状态，当BlockingQueue中有了新数据时，这个取数据的操作又会被重新唤醒。同理，如果BlockingQueue中的数据已经满了，往BlockingQueue中存数据的操作又会进入阻塞状态，直到BlockingQueue中又有新的空间，存数据的操作又会被冲洗唤醒。BlockingQueue有多种不同的实现类，下面我举几个例子来说一下：\n  ArrayBlockingQueue：这个表示一个规定了大小的BlockingQueue，ArrayBlockingQueue的构造函数接受一个int类型的数据，该数据表示BlockingQueue的大小，存储在ArrayBlockingQueue中的元素按照FIFO（先进先出）的方式来进行存取。一个由数组支持的有界阻塞队列。在读写操作上都需要锁住整个容器，内部还保存着两个整形变量，分别标识着队列的头部和尾部在数组中的位置。\n  LinkedBlockingQueue：这个表示一个大小不确定的BlockingQueue，在LinkedBlockingQueue的构造方法中可以传一个int类型的数据，这样创建出来的LinkedBlockingQueue是有大小的，也可以不传，不传的话，LinkedBlockingQueue的大小就为Integer.MAX_VALUE。数据的队列是按照链表的形式排列的，一个node指定下一个node。\n  PriorityBlockingQueue：这个队列和LinkedBlockingQueue类似，不同的是PriorityBlockingQueue中的元素不是按照FIFO来排序的，而是按照元素的Comparator来决定存取顺序的（这个功能也反映了存入PriorityBlockingQueue中的数据必须实现了Comparator接口）。\n  SynchronousQueue：这个是同步Queue，属于线程安全的BlockingQueue的一种，在SynchronousQueue中，生产者线程的插入操作必须要等待消费者线程的移除操作，Synchronous内部没有数据缓存空间，因此我们无法对SynchronousQueue进行读取或者遍历其中的数据，元素只有在你试图取走的时候才有可能存在。我们可以理解为生产者和消费者互相等待，等到对方之后然后再一起离开。所以无论怎么样，队列里面只能最多有一个短暂的元素。\n     queue 阻塞与否 是否有界 线程安全保障 适用场景 注意事项     ArrayBlockingQueue 阻塞 有界 一把全局锁 生产消费模型，平衡两边处理速度 用于存储队列元素的存储空间是预先分配的，使用过程中内存开销较小（无须动态申请存储空间）   LinkedBlockingQueue 阻塞 可配置 存取采用2把锁 生产消费模型，平衡两边处理速度 无界的时候注意内存溢出问题，用于存储队列元素的存储空间是在其使用过程中动态分配的，因此它可能会增加JVM垃圾回收的负担。    内存方面  ArrayBlockingQueue\n用于存储队列元素的存储空间是预先分配的，使用过程中内存开销较小（无须动态申请存储空间） LinkedBlockingQueue\n用于存储队列元素的存储空间是在其使用过程中动态分配的，因此它可能会增加JVM垃圾回收的负担。  有界无界  ArrayBlockingQueue\n有界，适合已知最大存储容量的场景 LinkedBlockingQueue\n可有界可以无界  Executors 我们找到Executors的创建线程池的默认工具类\n1//创建固定线程数量，并且如果线程池一直存在，核心线程会一直保持，后面的任务可以无限添加到队列中 2public static ExecutorService newFixedThreadPool(int nThreads) { 3 return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue\u0026lt;Runnable\u0026gt;()); 4} 5//创建单个固定线层数量，和上面的一样 6public static ExecutorService newSingleThreadExecutor() { 7 return new FinalizableDelegatedExecutorService(new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue\u0026lt;Runnable\u0026gt;())); 8} 9//尽可能多的创建新的线程来创建任务，队列中不存放任务，消费者和生产者互相等待。线程消费完成后会等待60秒，如果有新的任务加入就启用，如果1分钟内没有用就 10//去掉。 11public static ExecutorService newCachedThreadPool() { 12 return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue\u0026lt;Runnable\u0026gt;()); 13} 14//分别使用schedule延迟启动任务、scheduleAtFixedRate延迟定时执行任务、scheduleWithFixedDelay第一次延迟initialDelay秒，以后每次延迟delay秒执行一个任务。 15public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) { 16 return new ScheduledThreadPoolExecutor(corePoolSize); 17} 其中这4个静态方法是用的最多的，在Alibaba开发手册上讲到\n【强制】线程池不允许使用Executors 去创建，而是通过ThreadPoolExecutor 的方\n式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。\n说明：\nExecutors 返回的线程池对象的弊端如下：\n FixedThreadPool 和SingleThreadPool ： 允许的请求队列长度为\nInteger.MAX_VALUE，可能会堆积大量的请求，从而导致OOM； CachedThreadPool 和ScheduledThreadPool ： 允许的创建线程数量为\nInteger.MAX_VALUE，可能会创建大量的线程，从而导致OOM。  你厉害听你的就行了。\nCp一段线程池相关方法：\n  1.shutDown() 关闭线程池，不影响已经提交的任务\n  2.shutDownNow() 关闭线程池，并尝试去终止正在执行的线程\n  3.allowCoreThreadTimeOut(boolean value) 允许核心线程闲置超时时被回收\n  4.submit() 一般情况下我们使用execute来提交任务，但是有时候可能也会用到submit，使用submit的好处是submit有返回值。使用submit时我们可以通过实现Callable接口来实现异步任务。在call方法中执行异步任务，返回值即为该任务的返回值。Future是返回结果，返回它的isDone属性表示异步任务执行成功！future的get方法是阻塞的，如果已经执行完毕则不会。\n  ","date":"2019-09-27","img":"","permalink":"https://helixs.github.io/posts/2019-09-27-java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%ADsynchronousqueuelinkedblockingqueue%E5%92%8Carrayblockingqueue/","series":null,"tags":null,"title":"Java线程池中SynchronousQueue、LinkedBlockingQueue和ArrayBlockingQueue"},{"categories":["kotlin"],"content":"inline内联函数可以说是kotlin的一个高级特性了，不过在C++其实早就实现了，而java不支持内联函数，不过在jvm运行的时候会有一定的内联优化。\n为什么需要内联 处理器调用一个函数的步骤如下：\n  保留当前执行栈的信息\n  为被调用的函数分配栈区\n  初始化被调用函数中的参数、内部变量\n  执行被调用函数并返回\n  销毁被调用函数的执行栈\n  取出第一步保存的信息并恢复，然后继续执行\n  从这个流程中可以看到，所谓函数调用的开销主要是当前执行栈的保存与恢复、被调用函数栈区的分配与销毁两部分的开销。\n调用函数是一个入栈出栈的过程，意味着需要内存的开销和释放。增加了机器运行的负担，而使用内联函数就在编译器级别，将函数中的代码，直接放入调用函数的地方。这样就减少了一个入栈和出栈的过程，还是很不错的吧。不过相应的，编译后所生成的字节码的长度肯定是要变大的。我们可以根据一定的场景进行内联。\ninline 先来看看kotlin自带的inline函数\n1public inline fun \u0026lt;T\u0026gt; T.apply(block: T.() -\u0026gt; Unit): T { 2 contract { 3 callsInPlace(block, InvocationKind.EXACTLY_ONCE) 4 } 5 block() 6 return this 7} 然后我们试试\n1fun main(args: Array\u0026lt;String\u0026gt;) { 2 3 printText(\u0026#34;123\u0026#34;) 4 printTexts(\u0026#34;321\u0026#34;) 5 6} 7fun printText(text:String){ 8 println(text) 9} 10inline fun printTexts(text:String){ 11 println(text) 12} 然后我们Decompile转为java代码\n1public final class MainKt { 2 public static final void main(@NotNull String[] args) { 3 Intrinsics.checkParameterIsNotNull(args, \u0026#34;args\u0026#34;); 4 printText(\u0026#34;123\u0026#34;); 5 String text$iv = \u0026#34;321\u0026#34;; 6 System.out.println(text$iv); 7 } 8 9 public static final void printText(@NotNull String text) { 10 Intrinsics.checkParameterIsNotNull(text, \u0026#34;text\u0026#34;); 11 System.out.println(text); 12 } 13 14 public static final void printTexts(@NotNull String text) { 15 Intrinsics.checkParameterIsNotNull(text, \u0026#34;text\u0026#34;); 16 System.out.println(text); 17 } 18} 我们可以看到main方法中调用printTexts方法已经直接将函数代码放入到了main方法里。\n不过在定义printTexts方法的时候编译器提示了\nexpected performance impact of inlining is insignificant. Inlining works best for functions with parameters of functional types\r 刻意将普通方法加入inline并不会给性能带来多少的优化，反而会带来更多的字节码。建议将参数为函数形式的方法使用inline可以提高性能。\n1fun main(args: Array\u0026lt;String\u0026gt;) { 2 printText(\u0026#34;123\u0026#34;) 3 \u0026#34;321\u0026#34;.printTexts { 4 println(this) 5 } 6 7} 8fun printText(text:String){ 9 println(text) 10} 11fun \u0026lt;T\u0026gt; T.printTexts(block: T.() -\u0026gt; Unit):Unit{ 12 block() 13} 转为java\n1public final class MainKt { 2 public static final void main(@NotNull String[] args) { 3 Intrinsics.checkParameterIsNotNull(args, \u0026#34;args\u0026#34;); 4 printText(\u0026#34;123\u0026#34;); 5 printTexts(\u0026#34;321\u0026#34;, (Function1)null.INSTANCE); 6 } 7 8 public static final void printText(@NotNull String text) { 9 Intrinsics.checkParameterIsNotNull(text, \u0026#34;text\u0026#34;); 10 System.out.println(text); 11 } 12 13 public static final void printTexts(Object $receiver, @NotNull Function1 block) { 14 Intrinsics.checkParameterIsNotNull(block, \u0026#34;block\u0026#34;); 15 block.invoke($receiver); 16 } 17} 我们不加入inline内联实际上调用了printTexts方法中的Function1的回调函数。\n然后在printTexts方法前面加入inline后再看看\n1public final class MainKt { 2 public static final void main(@NotNull String[] args) { 3 Intrinsics.checkParameterIsNotNull(args, \u0026#34;args\u0026#34;); 4 printText(\u0026#34;123\u0026#34;); 5 Object $receiver$iv = \u0026#34;321\u0026#34;; 6 System.out.println($receiver$iv); 7 } 8 9 public static final void printText(@NotNull String text) { 10 Intrinsics.checkParameterIsNotNull(text, \u0026#34;text\u0026#34;); 11 System.out.println(text); 12 } 13 14 public static final void printTexts(Object $receiver, @NotNull Function1 block) { 15 Intrinsics.checkParameterIsNotNull(block, \u0026#34;block\u0026#34;); 16 block.invoke($receiver); 17 } 18} 参数为函数类型的函数使用inline的确可以提高性能，避免进入callback回调地狱。其实普通的方法不使用inline的情况下jvm也会帮我们实现部分的，如果需要的话那么你也可以强制使用Inline也没关系。\nnoinline 通过上面的代码我们看到，默认情况下内联函数的的参数如果是函数的话，那么参数函数也是被内联的\n1fun main(args: Array\u0026lt;String\u0026gt;) { 2 \u0026#34;321\u0026#34;.printTexts { 3 println(this) 4 } 5inline fun \u0026lt;T\u0026gt; T.printTexts(block: T.() -\u0026gt; Unit):Unit{ 6 block() 7 printSencond(block) 8} 9fun \u0026lt;T\u0026gt; printSencond(block: T.() -\u0026gt; Unit){ 10 11} 如果函数参数在内联函数的方法体内被其他非内联函数调用,就会报错.\n我们可以加入noinline\n1fun main(args: Array\u0026lt;String\u0026gt;) { 2 \u0026#34;321\u0026#34;.printTexts { 3 println(this) 4} 5inline fun \u0026lt;T\u0026gt; T.printTexts(noinline block: T.() -\u0026gt; Unit):Unit{ 6 block() 7 printSencond(block) 8} 9fun \u0026lt;T\u0026gt; printSencond(block: T.() -\u0026gt; Unit){ 10 11} 正常，转java\n1public final class MainKt { 2 public static final void main(@NotNull String[] args) { 3 Intrinsics.checkParameterIsNotNull(args, \u0026#34;args\u0026#34;); 4 String $receiver$iv = \u0026#34;321\u0026#34;; 5 Function1 block$iv = (Function1)null.INSTANCE; 6 block$iv.invoke($receiver$iv); 7 printSencond(block$iv); 8 } 9 10 public static final void printTexts(Object $receiver, @NotNull Function1 block) { 11 Intrinsics.checkParameterIsNotNull(block, \u0026#34;block\u0026#34;); 12 block.invoke($receiver); 13 printSencond(block); 14 } 15 16 public static final void printSencond(@NotNull Function1 block) { 17 Intrinsics.checkParameterIsNotNull(block, \u0026#34;block\u0026#34;); 18 } 19} 我们可以看到参数函数不会被内联，而是转为callback了，那么就能正常调用非inline的函数了。\ncrossinline 我们来看一看下面的代码\n1fun main(args: Array\u0026lt;String\u0026gt;) { 2 \u0026#34;321\u0026#34;.printTexts { 3 println(this) 4 return 5 } 6 7 println(\u0026#34;end\u0026#34;)//它会执行吗 8 9} 10inline fun \u0026lt;T\u0026gt; T.printTexts( block: T.() -\u0026gt; Unit){ 11 block() 12 13} 答案是不会执行，除非使用的是return@printTexts 。默认内联函数lambda参数中return是可以进行调用函数处return的，因为已经和调用处函数融为一体了。\n1inline fun \u0026lt;T\u0026gt; T.printTexts(crossinline block: T.() -\u0026gt; Unit){ 2 block() 3} 我们可以在block参数前加入crossinline来防止printTexts局部return\nreified 其实我个人认为这个reified才是内联函数中最牛逼的玩意儿。在java中我们的泛型在运行时都是一堆object，被擦除了没啥卵用。\n我们来试试哈\n1public static void main(String[] args) { 2 toPrintClassData(); 3 } 4 private static \u0026lt;T\u0026gt; void toPrintClassData (){ 5 System.out.println(T.class); 6 } 这个操作在java中可能实现吗，答案是不可能的。但是在kotlin中通过inline和reified就可以实现\n1fun main(args: Array\u0026lt;String\u0026gt;) { 2 toPrintClassInfo\u0026lt;String\u0026gt;() 3} 4inline fun \u0026lt; reified T\u0026gt; toPrintClassInfo(){ 5 println( T::class.java) 6} 这样我们就可以获取到泛型信息了，运行时的哦，困扰我多年的问题终于有办法了。比如我现在直接传入泛型而不用传入class就可以知道T是什么类型了。在java时候还要使用一堆头疼的反射等。其实inline的时候相当于就是吧T类型的class作为一个参数传进来了，还是蛮强大的。看看java代码\n1public final class MainKt { 2 public static final void main(@NotNull String[] args) { 3 Intrinsics.checkParameterIsNotNull(args, \u0026#34;args\u0026#34;); 4 Class var5 = String.class; 5 System.out.println(var5); 6 } 7 8 private static final void toPrintClassInfo() { 9 Intrinsics.reifiedOperationMarker(4, \u0026#34;T\u0026#34;); 10 Class var1 = Object.class; 11 System.out.println(var1); 12 } 13} 我们可以用来干嘛？\n1 inline fun \u0026lt;reified T : Activity\u0026gt; Activity.startActivity() { 2 startActivity(Intent(this, T::class.java)) 3} 4 5fun to(){ 6startActivity\u0026lt;MainActivity\u0026gt;() 7} 是不是很强大？也可以通过is和as的方式强转T。so fun。\n","date":"2019-09-11","img":"","permalink":"https://helixs.github.io/posts/2019-09-11-kotlin%E7%89%B9%E6%80%A7%E4%B9%8Binline%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/","series":null,"tags":null,"title":"Kotlin特性之inline内联函数"},{"categories":["数据结构和算法"],"content":"冒泡排序为什么叫冒泡排序 -_- 我们都是宅农，应该都用锅烧过开水，或用来做饭或用来烧汤，不过我在小时候还烧过猪食。等水温达到一定程度，水就开始出了一点泡泡。\n气泡有两个来源：\n1、在水沸腾之前出现的气泡，主要是水中溶解的气体（氮气、氧气等），随着温度升高，它们在水中的溶解度下降，于是析出了气泡\n2、等水沸腾之后大部分气泡就是沸腾产生的水蒸汽了气泡越来越大。\n上浮的过程中气泡会变大主要原因是：pV=nRT，于是气体的体积和压强成反比。水面以下越深，压强就越大，所以上浮的过程是压强减小的过程，也就是体积增大的过程。\n冒泡排序就是差不多这样解释啦。不过这里面还差了一个循环的意思。\n最简单的实现方式 1fun main(args: Array\u0026lt;String\u0026gt;) { 2 val a = intArrayOf( 3 56, 4 78, 5 65, 6 52, 7 76, 8 13, 9 27, 10 49, 11 78, 12 34, 13 12, 14 64, 15 5, 16 4, 17 62, 18 99, 19 98, 20 54, 21 56, 22 17, 23 18, 24 23, 25 34, 26 15, 27 35, 28 25, 29 53, 30 51 31 ) 32 var temp = 0 33 for (i in 0 until a.size - 1) { 34 for (j in 0 until a.size - 1 - i) { 35 println(\u0026#34;i=$ij=$j\u0026#34;) 36 if (a[j] \u0026gt; a[j + 1]) { 37 temp = a[j] 38 a[j] = a[j + 1] 39 a[j + 1] = temp 40 } 41 } 42 } 43 for (i in a.indices) 44 println(a[i]) 45} 在要排序的一组数中，对当前还未排好序的范围内的全部数，自上而下对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。即：每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。\n这个就是最简单冒泡排序实现办法。时间复杂度=O（n^2）也就是n*n。\n优化 如果对于一个本身有序的序列，或则序列后面一大部分都是有序的序列，上面的算法就会浪费很多的时间开销，这里设置一个标志flag，如果这一趟发生了交换，则为true，否则为false。明显如果有一趟没有发生交换，说明排序已经完成。最好时间复杂度O(n) 最坏O(n^2)\n1fun main(args: Array\u0026lt;String\u0026gt;) { 2 3 val a = intArrayOf( 4 49, 5 38, 6 65, 7 97, 8 76, 9 13, 10 27, 11 49, 12 78, 13 34, 14 12, 15 64, 16 5, 17 4, 18 62, 19 99, 20 98, 21 54, 22 56, 23 17, 24 18, 25 23, 26 34, 27 15, 28 35, 29 25, 30 53, 31 51 32 ) 33 var flag = true 34 var key = a.size-1 35 while (flag){ 36 flag=false//每次开始排序前，都设置flag为未排序过 37 var temp = 0 38 for (j in 0 until key) { 39 if (a[j] \u0026gt; a[j + 1]) { 40 temp = a[j] 41 a[j] = a[j + 1] 42 a[j + 1] = temp 43 flag = true //交换过数据 44 } 45 } 46 key--//因为最后1个需要交换的数据已经交换完毕，后序遍历不需要再往后检查，必定顺序正确。 47 } 48 49 for (i in a.indices) 50 println(a[i]) 51} 进一步优化 比如，现在有一个包含1000个数的数组，仅前面100个无序，后面900个都已排好序且都大于前面100个数字，那么在第一趟遍历后，最后发生交换的位置必定小于100，且这个位置之后的数据必定已经有序了，也就是这个位置以后的数据不需要再排序了，于是记录下这位置，第二次只要从数组头部遍历到这个位置就可以了。如果是对于上面的冒泡排序算法2来说，虽然也只排序100次，但是前面的100次排序每次都要对后面的900个数据进行比较，而对于现在的排序算法3，只需要有一次比较后面的900个数据，之后就会设置尾边界，保证后面的900个数据不再被排序。\n1fun main(args: Array\u0026lt;String\u0026gt;) { 2 3 val a = intArrayOf( 4 49, 5 38, 6 65, 7 97, 8 76, 9 13, 10 27, 11 49, 12 78, 13 34, 14 12, 15 64, 16 5, 17 4, 18 62, 19 99, 20 98, 21 54, 22 56, 23 17, 24 18, 25 23, 26 34, 27 15, 28 35, 29 25, 30 53, 31 51 32 ) 33 var flag = a.size 34 var key =1 35 while (flag\u0026gt;0){ 36 key = flag 37 flag=0//每次开始排序前，都设置flag为未排序过 38 var temp = 0 39 for (j in 0 until key) { 40 if (a[j] \u0026gt; a[j + 1]) { 41 temp = a[j] 42 a[j] = a[j + 1] 43 a[j + 1] = temp 44 flag = j //记录最新的尾边界. 下次边界直接到这里 45 } 46 } 47 } 48 49 for (i in a.indices) 50 println(a[i]) 51} 那么第三种其实就是最优解啦。\n","date":"2019-09-02","img":"","permalink":"https://helixs.github.io/posts/2019-09-02-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E4%BC%98%E5%8C%96/","series":null,"tags":null,"title":"冒泡排序的概念和优化"},{"categories":["flutter"],"content":"1const SliverAppBar({ 2 Key key, 3 this.leading, //在标题左侧显示的一个控件，在首页通常显示应用的 logo；在其他界面通常显示为返回按钮 4 this.automaticallyImplyLeading = true,//? 控制是否应该尝试暗示前导小部件为null 5 this.title, //当前界面的标题文字 6 this.actions, //一个 Widget 列表，代表 Toolbar 中所显示的菜单，对于常用的菜单，通常使用 IconButton 来表示；对于不常用的菜单通常使用 PopupMenuButton 来显示为三个点，点击后弹出二级菜单 7 this.flexibleSpace, //一个显示在 AppBar 下方的控件，高度和 AppBar 高度一样， // 可以实现一些特殊的效果，该属性通常在 SliverAppBar 中使用 8 this.bottom, //一个 AppBarBottomWidget 对象，通常是 TabBar。用来在 Toolbar 标题下面显示一个 Tab 导航栏 9 this.elevation, //阴影 10 this.forceElevated = false, 11 this.backgroundColor, //APP bar 的颜色，默认值为 ThemeData.primaryColor。改值通常和下面的三个属性一起使用 12 this.brightness, //App bar 的亮度，有白色和黑色两种主题，默认值为 ThemeData.primaryColorBrightness 13 this.iconTheme, //App bar 上图标的颜色、透明度、和尺寸信息。默认值为 ThemeData().primaryIconTheme 14 this.textTheme, //App bar 上的文字主题。默认值为 ThemeData（）.primaryTextTheme 15 this.primary = true, //此应用栏是否显示在屏幕顶部 16 this.centerTitle, //标题是否居中显示，默认值根据不同的操作系统，显示方式不一样,true居中 false居左 17 this.titleSpacing = NavigationToolbar.kMiddleSpacing,//横轴上标题内容 周围的间距 18 this.expandedHeight, //展开高度 19 this.floating = false, //是否随着滑动隐藏标题 20 this.pinned = false, //是否固定在顶部 21 this.snap = false, //与floating结合使用 22 }) ","date":"2019-08-20","img":"","permalink":"https://helixs.github.io/posts/2019-08-20-flutter-sliverappbar/","series":null,"tags":null,"title":"Flutter SliverAppBar"},{"categories":["Android开发","编程生活"],"content":"哪些对象会被回收？ 对于寄存器、栈和本地方法区，他们都是跟随着当前线程走的，线程走完也就消亡了，所以不许要GC去触碰它。\n而GC的主要对象是Java堆，这个地方跟线程的生命周期没有直接关联，就算你方法走完，new的对象也不会马上消失，直到GC的时候才有可能回收它。次要对象就是方法区的常量或者类等，毕竟这个一般也不会大到哪里去。\n对象存活的依据 1、引用计数法  原理：给对象添加一个引用计数器，每当有地方引用时计数器加 1，引用失效时减 1。当该对象引用为 0 时，判定对象失效 优点：实现简单，判定效率高 缺点：很难解决对象之间循环引用的问题  如果 class A,classB都持有对方的引用那么就不可能回收了！。\n1.2 可达性分析法  原理：和 GC Roots 直接或间接关联的对象是有效对象，反之则是无效对象。 Java 中可作为 GC Roots 的对象：  栈（栈帧中的本地变量表）中引用的对象； 方法区中类静态属性引用的对象； 方法区中常量引用的对象； 本地方法栈中 JNI（Native 方法）引用的对象。    java对象的引用  1.强引用（Strong Reference）：如“Object obj = new Object（）”，这类引用是Java程序中最普遍的。只要强引用还存在，垃圾收集器就永远不会回收掉被引用的对象。 2.软引用（Soft Reference）：它用来描述一些可能还有用，但并非必须的对象。在系统内存不够用时，这类引用关联的对象将被垃圾收集器回收。JDK1.2之后提供了SoftReference类来实现软引用。 3.弱引用（Weak Reference）：它也是用来描述非须对象的，但它的强度比软引用更弱些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK1.2之后，提供了WeakReference类来实现弱引用。 4.虚引用（Phantom Reference）：最弱的一种引用关系，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的是希望能在这个对象被收集器回收时收到一个系统通知。JDK1.2之后提供了PhantomReference类来实现虚引用。  判断是否可以被回收 当 JVM 经过可达性分析法筛选出实效对象时，并不是马上清除，而是进行标记并判断是否回收：\n 判断对象是否覆盖了 finalize() 方法 :如果覆盖了 finalize() 方法，那么将 finalize() 放到 F-Queue 队列中,如果未覆盖该方法，则直接回收 执行 F-Queue 队列中的 finalize() 方法:由虚拟机自动建立一个优先级较低的线程去执行 F-Queue 中的 finalize() 方法，这里的执行只是触发这些方法并不保证会等待它执行完毕。如果 finalize() 方法作了耗时操作，虚拟机会停止执行并将该对象清除。 对象销毁或重生:在 finalize() 方法中，将 this 赋值给某一个引用，那么该对象就重生了。如果没有引用，该对象会被回收。  方法区的内存回收  废弃的常量：  当前系统中没有任何对象引用常量池中的该常量，则是废弃常量   废弃的类判断规则：  该类所有实例都被回收； 加载该类的 ClassLoader 已经被回收； 该类对应的 Class 对象没有引用，也无法通过反射访问该类的方法。    算法 最基础的收集算法是”标记 – 清除”算法，之所以说它是最基础的是因为它逻辑简单、使用简便，而且后续的收集算法大多基于这种算法的不足而优化的。\n1. 标记-清除算法 标记-清除算法分为两个阶段：\n 1.标记阶段：标记的过程就是前面的可达性分析法执行的过程。首先遍历所有 GC Roots 对象，对从 GC Roots 对象可达的对象都打上一个可达标识。这个可达标识一般记录在对象 header 中（一个对象一般包括对象头、实例数据、对齐填充三个部分），表示该对象可以被 GC Roots 访问。  可以看到，上图 B、E、F、G、J、K 对象是可达对象，所以这些对象的对象头中就会记录可达信息。\n  清除阶段：清除阶段是对堆内存进行遍历，通过读取这些对象的 header 信息来获取对象是否标记可达。如果未标记则表示这些对象没有引用，就可以进行回收。    标记-清除算法主要不足有两个：\n 效率问题：标记和清除都需要遍历，效率不高； 空间问题：标记清除后会产生大量不连续的内存水平，空间碎片太多会导致大内存对象无法生成而频繁进行 GC。  2. 复制算法 为了解决效率问题，复制算法出现了。\n 原理：将可用内存按容量大小分为大小相等的两块，每次只使用其中一块。当这一块内存使用完毕，就将存活的对象复制到另一块上，然后再把这一块所有的对象一次性清理掉。 图解：  先将内存区域分为大小相等的两块，只使用其中一块，并标记可达对象。\n当一块内存使用完毕以后，将其中的可达对象复制到另一块，然后再一次性清除原理的内存空间。\n 优点：简答高效，内存相对整齐 缺点：\n1.将内存分为一半，代价略高。\n2.如果对象存活率高，需要复制的对象比较多，产生效率问题。 优化：\n在新生代中，由于大量的对象都是”朝生夕死”，也就是说一次垃圾收集后存活对象较少，因此我们可以把内存划分为三块：Eden、Survior1、Survior2，大小比例为 8:1:1。分配内存时只使用 Eden + Survior1，当这里的内存将满时，JVM 会出发一次 MinorGC，清除掉废弃对象，并将存活对象复制到另一块 Survior2 中。那么接下来就使用 Eden + Survior2 进行内存分配。通过这种方式只需浪费 10% 的内存空间即可实现复制清除算法，同时避免了内存碎片的问题。  3. 标记-整理算法  原理：标记过程与 “标记 – 清除” 算法相同，但后续不是直接对可回收对象进行清理，而是让所有存活对象都向一端移动，然后直接清理掉一端边界外的内存。   优点：无需复制，保证效率。内存规整。 缺点：效率不如复制算法。  三种算法排行 当前商业虚拟机的垃圾收集都采用 “分代收集” 算法，这种相当于结合以上几种算法进行结合。\n原理：把 Java 堆分为新生代和老年代，根据各个对象的年代采用最合适的收集算法。 针对新生代的对象，采取灵活比例的复制算法，只需要复制少量存活对象就可以完成收集。 针对老年代的对象，因为这些对象存活率高，没有额外空间进行分配担保，必须使用 标记 – 清除 或 标记 – 整理 算法。\n 新生代:Young Generation  几乎所有新生成的对象首先都是放在年轻代的。新生代内存按照8:1:1的比例分为一个Eden区和两个Survivor(Survivor0,Survivor1)区。大部分对象在Eden区中生成。当新对象生成，Eden Space申请失败（因为空间不足等），则会发起一次GC(Scavenge GC)。回收时先将Eden区存活对象复制到一个Survivor0区，然后清空Eden区，当这个Survivor0区也存放满了时，则将Eden区和Survivor0区存活对象复制到另一个Survivor1区，然后清空Eden和这个Survivor0区，此时Survivor0区是空的，然后将Survivor0区和Survivor1区交换，即保持Survivor1区为空， 如此往复。当Survivor1区不足以存放 Eden和Survivor0的存活对象时，就将存活对象直接存放到老年代。当对象在Survivor区躲过一次GC的话，其对象年龄便会加1，默认情况下，如果对象年龄达到15岁，就会移动到老年代中。若是老年代也满了就会触发一次Full GC，也就是新生代、老年代都进行回收。新生代大小可以由-Xmn来控制，也可以用-XX:SurvivorRatio来控制Eden和Survivor的比例。\n 老年代:Old Generation  在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。内存比新生代也大很多(大概比例是1:2)，当老年代内存满时触发Major GC即Full GC，Full GC发生频率比较低，老年代对象存活时间比较长，存活率标记高。一般来说，大对象会被直接分配到老年代。所谓的大对象是指需要大量连续存储空间的对象，最常见的一种大对象就是大数组。比如： byte[] data = new byte[410241024] 这种一般会直接在老年代分配存储空间。 当然分配的规则并不是百分之百固定的，这要取决于当前使用的是哪种垃圾收集器组合和JVM的相关参数。\n 永久代 or 元空间  用于存放静态文件（class类、方法）和常量等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如Hibernate 等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。对永久代的回收主要回收两部分内容：废弃常量和无用的类。\n","date":"2019-07-30","img":"","permalink":"https://helixs.github.io/posts/2019-07-30-java-gc%E7%AE%80%E5%8D%95%E8%AE%A4%E8%AF%86/","series":null,"tags":null,"title":"Java GC简单认识"},{"categories":["Android开发","编程生活"],"content":" 前几日，我去外面试了试面试。找找新工作看看有没有合适的。前面基本上很顺利，没有什么特别的难度和问题，本以为可以满怀信心的入职，结果被泼了一盆冷水。被问到关于GC机制的问题，GC算法有哪些，规则如何等等，我懵逼了，我只知道GC是垃圾回收，在内存不够的时候会触发它，然后回收没有引用的内存。然后它是如何实现的可真没有仔细研究过。书到用时方恨少，事非经过不知难。\n 在很多年前我们在运行android程序的时候，时不时的会卡顿，我当时不以为然。排除线程和代码相关的情况下多半都与触发了GC有关西。了解才知道，在触发GC线程的时候，其它线程会进行等待，包括UI线程，UI线程卡顿了，那么我们肯定就会卡了。\njvm运行时内存分配 1、栈 英文Stack，运行于RAM之上。stack最主要的特征即是先进后出。栈内存上面有一个指针，和C语言的指针差不多，指针的加减直接影响栈内存的创建和释放。当载入一个新方法的时候，指针+，方法执行完毕，指针-。这是一种特别快、特别有效的数据保存方式，仅次于寄存器。创建程序时，Java编译器必须准确地知道堆栈内保存的所有数据的“长度”以及“存在时间”。这是由于它必须生成相应的代码，以便移动指针。\n   每个线程包含一个栈区，栈中只保存基本数据类型的数据和自定义对象的引用(不是对象)，对象都存放在堆区中。    每个栈中的数据(原始类型和对象引用)都是私有的，其他栈不能访问。    栈分为3个部分：基本数据类型的变量区、执行环境上下文、操作指令区(存放操作指令)。    栈是存放线程调用方法时存储局部变量表，操作，方法出口等与方法执行相关的信息，Java栈所占内存的大小由Xss来调节，方法调用层次太多会撑爆这个区域即_StackOverflowError。_\nps:这让我想起了递归，如果递归层级过多，不进行尾递归优化那么方法一直在载入没有执行完毕，那么一记StackOverflowError送给你\n程序计数器（ProgramCounter）寄存器 是cpu的一部分，离cpu最近，速度也最快。每个线程启动的时候，都会创建一个寄存器，保存正在执行jvm指令的地址和下一步指令的地址。寄存器的内容总是指向下一条将被执行指令的地址，这里的地址可以是一个本地指针，也可以是在方法区中相对应于该方法起始指令的偏移量。\nps:想想为什么需要保存啊，不是直接执行就行了么。NONONO，现在程序都是多线程运行的，cpu要同时执行多条命令呀！这句话说的也不对，多线程是个假象，就算是32核64线程也是假象，cpu短时间内会在不同线程之间切换运行指令，造成一种同时运行多任务的假象，不过假象很有效，足以骗过我们愚蠢的人类。所以任务切来切去不找个地方保存下一步需要执行的地方，我回过神来就会迷失方向了。\n本地方法栈(也叫本地方法区) Nativemethodstack(本地方法栈)：保存native方法进入区域的地址。\n方法区 method（方法区）又叫静态区，存放所有的①类（class），②静态变量（static变量），③静态方法，④常量和⑤成员方法。\n  1.又叫静态区，跟堆一样，被所有的线程共享。\n  2.方法区中存放的都是在整个程序中永远唯一的元素。这也是方法区被所有的线程共享的原因。\n  （顺便展开静态变量和常量的区别： 静态变量本质是变量，是整个类所有对象共享的一个变量，其值一旦改变对这个类的所有对象都有影响；常量一旦赋值后不能修改其引用，其中基本数据类型的常量不能修改其值。）\nJava里面是没有静态变量这个概念的，不信你自己在某个成员方法里面定义一个static int i = 0；Java里只有静态成员变量。它属于类的属性。至于他放哪里？楼上说的是静态区。我不知道到底有没有这个翻译。但是深入JVM里是翻译为方法区的。虚拟机的体系结构：①Java栈，② 堆，③PC寄存器，④方法区，⑤本地方法栈，⑥运行常量池。而方法区保存的就是一个类的模板，堆是放类的实例（即对象）的。栈是一般来用来函数计算的。随便找本计算机底层的书都知道了。栈里的数据，函数执行完就不会存储了。这就是为什么局部变量每一次都是一样的。就算给他加一后，下次执行函数的时候还是原来的样子。\n方法区的大小由-XX:PermSize和-XX:MaxPermSize来调节，类太多有可能撑爆永久代。静态变量或常量也有可能撑爆方法区。\n    方法区的位置有三种情况：java7之前，方法区位于永久代(PermGen)，永久代和堆相互隔离，永久代的大小在启动JVM时可以设置一个固定值，不可变；    java7中，存储在永久代的部分数据就已经转移到Java Heap或者Native memory。但永久代仍存在于JDK 1.7中，并没有完全移除，譬如符号引用(Symbols)转移到了native memory；字符串常量池(interned strings)转移到了Java heap；类的静态变量(class statics)转移到了Java heap。    java8中，取消永久代，方法存放于元空间(Metaspace)，元空间仍然与堆不相连，但与堆共享物理内存，逻辑上可认为在堆中     Native memory：本地内存，也称为C-Heap，是供JVM自身进程使用的。当Java Heap空间不足时会触发GC，但Native memory空间不够却不会触发GC。\n为什么移除永久代？\n 1、字符串存在永久代中，容易出现性能问题和内存溢出。 2、永久代大小不容易确定，PermSize指定太小容易造成永久代OOM 3、永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。 4、Oracle 可能会将HotSpot 与 JRockit 合二为一。  堆 类的对象放在heap（堆）中，所有的类对象都是通过new方法创建，创建后，在stack（栈）会创建类对象的引用（内存地址）。\n一种常规用途的内存池（也在RAM（随机存取存储器 ）区域），其中保存了Java对象。和栈不同：“内存堆”或“堆”最吸引人的地方在于编译器不必知道要从堆里分配多少存储空间，也不必知道存储的数据要在堆里停留多长的时间。因此，用堆保存数据时会得到更大的灵活性。要求创建一个对象时，只需用new命令编辑相应的代码即可。执行这些代码时，会在堆里自动进行数据的保存。当然，为达到这种灵活性，必然会付出一定的代价：在堆里分配存储空间时会花掉更长的时间。\nJVM将所有对象的实例（即用new创建的对象）（对应于对象的引用（引用就是内存地址））的内存都分配在堆上，堆所占内存的大小由-Xmx指令和-Xms指令来调节。\n运行常量池 这儿的“静态”是指“位于固定位置”。程序运行期间，静态存储的数据将随时等候调用。可用static关键字指出一个对象的特定元素是静态的。但Java对象本身永远都不会置入静态存储空间。\n这个区域属于方法区。该区域存放类和接口的常量，除此之外，它还存放成员变量和成员方法的所有引用。当一个成员变量或者成员方法被引用的时候，JVM就通过运行常量池中的这些引用来查找成员变量和成员方法在内存中的的实际地址。\n举个例子 1// AppMain.java 2public class AppMain { //运行时，JVM把AppMain的信息都放入方法区 3 4 public static void main(String[] args) { //main成员方法本身放入方法区。 5 Sample test1 = new Sample( \u0026#34; 测试1 \u0026#34; ); //test1是引用，所以放到栈区里，Sample是自定义对象应该放到堆里面 6 Sample test2 = new Sample( \u0026#34; 测试2 \u0026#34; ); 7 test1.printName(); 8 test2.printName(); 9 } 10 11} 12 13// Sample.java 14public class Sample { //运行时，JVM把appmain的信息都放入方法区。 15 16 private name; //new Sample实例后，name引用放入栈区里，name对象放入堆里。 17 18 public Sample(String name) { 19 this.name = name; 20 } 21 22 public void printName() {// printName()成员方法本身放入方法区里。 23 System.out.println(name); 24 } 25 26} 命令 java AppMain\n系统收到了我们发出的指令，启动了一个Java虚拟机进程，这个进程首先从classpath中找到AppMain.class文件，读取这个文件中的二进制数据，然后把Appmain类的类信息存放到运行时数据区的方法区中。这一过程称为AppMain类的加载过程。\n接着，JVM定位到方法区中AppMain类的Main()方法的字节码，开始执行它的指令。这个main()方法的第一条语句就是：\nSample test1 = new Sample(“测试1”);\n语句很简单啦，就是让JVM创建一个Sample实例，并且呢，使引用变量test1引用这个实例。貌似小case一桩哦，就让我们来跟踪一下JVM，看看它究竟是怎么来执行这个任务的：\n  1、Java虚拟机一看，不就是建立一个Sample类的实例吗，简单，于是就直奔方法区（方法区存放已经加载的类的相关信息，如类、静态变量和常量）而去，先找到Sample类的类型信息再说。结果呢，嘿嘿，没找到@@，这会儿的方法区里还没有Sample类呢（即Sample类的类信息还没有进入方法区中）。可JVM也不是一根筋的笨蛋，于是，它发扬“自己动手，丰衣足食”的作风，立马加载了Sample类， 把Sample类的相关信息存放在了方法区中。\n  2、Sample类的相关信息加载完成后。Java虚拟机做的第一件事情就是在堆中为一个新的Sample类的实例分配内存，这个Sample类的实例持有着指向方法区的Sample类的类型信息的引用（Java中引用就是内存地址）。这里所说的引用，实际上指的是Sample类的类型信息在方法区中的内存地址，其实，就是有点类似于C语言里的指针啦~~，而这个地址呢，就存放了在Sample类的实例的数据区中。\n  3、在JVM中的一个进程中，每个线程都会拥有一个方法调用栈，用来跟踪线程运行中一系列的方法调用过程，栈中的每一个元素被称为栈帧，每当线程调用一个方法的时候就会向方法栈中压入一个新栈帧。这里的帧用来存储方法的参数、局部变量和运算过程中的临时数据。OK，原理讲完了，就让我们来继续我们的跟踪行动！位于“=”前的test1是一个在main()方法中定义的变量，可见，它是一个局部变量，因此，test1这个局部变量会被JVM添加到执行main()方法的主线程的Java方法调用栈中。而“=”将把这个test1变量指向堆区中的Sample实例，也就是说，test1这个局部变量持有指向Sample类的实例的引用（即内存地址）。\n  接下来，JVM将继续执行后续指令，在堆区里继续创建另一个Sample类的实例，然后依次执行它们的printName()方法。当JVM执行test1.printName()方法时，JVM根据局部变量test1持有的引用，定位到堆中的Sample类的实例，再根据Sample类的实例持有的引用，定位到方法区中Sample类的类型信息（包括①类，②静态变量，③静态方法，④常量和⑤成员方法），从而获取printName()成员方法的字节码，接着执行printName()成员方法包含的指令。\n","date":"2019-07-29","img":"","permalink":"https://helixs.github.io/posts/2019-07-29-java-gc%E7%9A%84%E7%AE%80%E5%8D%95%E8%AE%A4%E8%AF%86/","series":null,"tags":null,"title":"Jvm运行时内存分配"},{"categories":["Android开发","linux常用配置"],"content":" 转载请注明出处\n我们做app开发的时候，往往需要对应用信息安全做考虑。通过charles fiddler抓取http包是很随意的事情，https中间人也是很容易。所以做一个信任所有证书的商业应用来说是很low。\n拿android开发为例，如果考虑安全，必须进行证书锁定。如，通过network_security_config.xml文件进行锁定。通过digest摘要来验证证书，而不用将证书放入到apk中，具体的不多说。\n下面是X509公钥证书的格式标准，另外还有中间机构和根证书就不说明了\n1证书: 2 版本: 3 (0x2) 3 序列号: 10:e6:fc:62:b7:41:8a:d5:00:5e:45:b6 4 签名算法: sha256WithRSAEncryption 5 颁发者: C=BE, O=GlobalSign nv-sa, CN=GlobalSign Organization Validation CA - SHA256 - G2 6 此前无效: Nov 21 08:00:00 2016 GMT 7 此后无效: Nov 22 07:59:59 2017 GMT 8 主题: C=US, ST=California, L=San Francisco, O=Wikimedia Foundation, Inc., CN=*.wikipedia.org 9 主题公钥信息: 10 公钥算法: id-ecPublicKey 11 256位的公钥: 12 04:c9:22:69:31:8a:d6:6c:ea:da:c3:7f:2c:ac:a5: 13 af:c0:02:ea:81:cb:65:b9:fd:0c:6d:46:5b:c9:1e: 14 ed:b2:ac:2a:1b:4a:ec:80:7b:e7:1a:51:e0:df:f7: 15 c7:4a:20:7b:91:4b:20:07:21:ce:cf:68:65:8c:c6: 16 9d:3b:ef:d5:c1 17 ASN1 OID: prime256v1 18 NIST CURVE: P-256 19 扩展: 20 密钥使用: 21 关键:是 22 使用:数字签名，密钥协商Key Agreement 23 授权相关信息: 24 关键:否 25 颁发者URI:http://secure.globalsign.com/cacert/gsorganizationvalsha2g2r1.crt 26 在线证书状态协议(OCSP)URI:http://ocsp2.globalsign.com/gsorganizationvalsha2g2 27 28 证书策略: 29 关键:否 30 策略 ID#1: 1.3.6.1.4.1.4146.1.20 31 CPS URI: https://www.globalsign.com/repository/ 32 策略 ID#2: 2.23.140.1.2.2 33 34 基本限制: 35 CA:FALSE 36 CRL 分发点: 37 关键:否 38 URI:http://crl.globalsign.com/gs/gsorganizationvalsha2g2.crl 39 40 主题备用名称: 41 关键:否 42 DNS:*.wikipedia.org, DNS:*.m.mediawiki.org, DNS:*.m.wikibooks.org, DNS:*.m.wikidata.org, DNS:*.m.wikimedia.org, DNS:*.m.wikimediafoundation.org, DNS:*.m.wikinews.org, DNS:*.m.wikipedia.org, DNS:*.m.wikiquote.org, DNS:*.m.wikisource.org, DNS:*.m.wikiversity.org, DNS:*.m.wikivoyage.org, DNS:*.m.wiktionary.org, DNS:*.mediawiki.org, DNS:*.planet.wikimedia.org, DNS:*.wikibooks.org, DNS:*.wikidata.org, DNS:*.wikimedia.org, DNS:*.wikimediafoundation.org, DNS:*.wikinews.org, DNS:*.wikiquote.org, DNS:*.wikisource.org, DNS:*.wikiversity.org, DNS:*.wikivoyage.org, DNS:*.wiktionary.org, DNS:*.wmfusercontent.org, DNS:*.zero.wikipedia.org, DNS:mediawiki.org, DNS:w.wiki, DNS:wikibooks.org, DNS:wikidata.org, DNS:wikimedia.org, DNS:wikimediafoundation.org, DNS:wikinews.org, DNS:wikiquote.org, DNS:wikisource.org, DNS:wikiversity.org, DNS:wikivoyage.org, DNS:wiktionary.org, DNS:wmfusercontent.org, DNS:wikipedia.org 43 扩展的密钥使用目的: 44 关键:否 45 目的1:TLS Web服务器鉴定 46 目的1:TLS Web客房端鉴定 47 主题密钥标识符: 48 关键:否 49 密钥: 28:2A:26:2A:57:8B:3B:CE:B4:D6:AB:54:EF:D7:38:21:2C:49:5C:36 50 授权密钥标识符: 51 关键:否 52 密钥:96:DE:61:F1:BD:1C:16:29:53:1C:C0:CC:7D:3B:83:00:40:E6:1A:7C 53 54 签名算法: sha256WithRSAEncryption 55 数字签名: 8b:c3:ed:d1:9d:39:6f:af:40:72:bd:1e:18:5e:30:54:23:35: 56 ... 公钥证书的信息大概就是这些，在window的chrome我们可以随时到处证书就像这样\n两个格式的主要区别：\n 虽然他们保存文件的的后缀都是cer区别就是der是保存的二进制文件，看不到里面的内容。\n而base64编码实际上是pem格式的证书。开头—–BEGIN CERTIFICATE—– 结尾 —–END CERTIFICATE—–\n 他们最终包含的信息都是一样的，注意的是base64可以用文本编辑内容，不过不要随意修改多一个少一个空格也是不好的。\n保存完后我们就要通过openssl进行获取证书公钥的摘要了\nopenssl登场\n因为我用的win10系统装了个linux内核还是蛮舒服的\n1#安装 2apt-get install openssl 3#读取pem格式 4openssl x509 -in google.cer -pubkey -noout | openssl pkey -pubin -outform der | openssl dgst -sha256 -binary | openssl enc -base64 5#读取der格式 6openssl x509 -in google.cer -inform der -pubkey -noout | openssl pkey -pubin -outform der | openssl dgst -sha256 -binary | openssl enc -base64 其大概过程是:\n 1、让openssl安装x509公钥的标准读取证书信息 ，-pubkey 读取公钥  2、通过pkey -pukey 读取密钥信息通过-outform 按照der格式保存密钥信息 3、dgst按照sha256 进行hash计算得到了2进制数据  4、将二进制信息通过base64编码。最终就是我们所需要的信息了，我们得到的信息是通过hash计算不可逆的，所以保证了一定的安全性。  android项目通过\n1\u0026lt;network-security-config\u0026gt; 2 3 \u0026lt;domain-config\u0026gt; 4 \u0026lt;domain includeSubdomains=\u0026#34;true\u0026#34;\u0026gt;league.round-table-union.com\u0026lt;/domain\u0026gt; 5 \u0026lt;pin-set expiration=\u0026#34;2020-04-02\u0026#34;\u0026gt; 6 \u0026lt;pin digest=\u0026#34;SHA-256\u0026#34;\u0026gt;URncS5oN4LUeFGaD33rKVDb+H3gxJ6QXL/Nyk+moaT2=\u0026lt;/pin\u0026gt; 7 \u0026lt;!-- backup pin 多个证书下使用--\u0026gt; 8 \u0026lt;pin digest=\u0026#34;SHA-256\u0026#34;\u0026gt;fwza1LRMXouZHRC8Ei+4PyuldPDcf3UKgO/04cDM2oE=\u0026lt;/pin\u0026gt; 9 \u0026lt;/pin-set\u0026gt; 10 \u0026lt;/domain-config\u0026gt; 11 12\u0026lt;/network-security-config\u0026gt; ","date":"2019-07-23","img":"","permalink":"https://helixs.github.io/posts/2019-07-23-%E9%80%9A%E8%BF%87openssl%E8%8E%B7%E5%8F%96%E8%AF%81%E4%B9%A6%E6%91%98%E8%A6%81%E4%BF%A1%E6%81%AF/","series":null,"tags":null,"title":"通过openssl获取证书摘要信息"},{"categories":["flutter"],"content":"转载请注明出处\n前些天使用Flutter的dio库进行post请求。说来也怪。服务器只允许使用application/x-www-form-urlencoded方式接收数据，data数据格式大概是这样: dataArr=[{“type”:”file”,”path”:”xxxx/wsdsd.txt”}]\n想了想用json不就行了么。form好麻烦。奈何你只是服务者。直接用dio库进行请求，contentType设置为application/x-www-form-urlencoded。就像这样\n1//sample 2//https://xxx.com/xxx 3//contentType=application/x-www-form-urlencoded 4//dataArr: [{\u0026#34;type\u0026#34;:\u0026#34;file\u0026#34;,\u0026#34;path\u0026#34;:\u0026#34;home/wsdsd.txt\u0026#34;}] 5//按照key-value发送数据。服务器解析出错。同一请求用postman就成功了。代码如下 6 7var fileMap = Map\u0026lt;String, String\u0026gt;(); 8fileMap[\u0026#34;type\u0026#34;] = \u0026#34;file\u0026#34;; 9fileMap[\u0026#34;path\u0026#34;] = ”home/wsdsd.txt“; 10var dataArr = [fileMap]; 11var map = Map\u0026lt;String, List\u0026lt;Map\u0026lt;String, String\u0026gt;\u0026gt;\u0026gt;(); 12map[\u0026#34;dataArr\u0026#34;] = dataArr; 13options.contentType = ContentType.parse(\u0026#34;application/x-www-form-urlencoded\u0026#34;); 14dio.post(https://xxx.com/xxx, data: map , options: option); 请求失败了，服务器接收数据格式错误。怎么查文档也不行，只能看dio源代码入手。找到RequestOptions看看他是如何做data编码的，找到DefaultTransformer.transformRequest(RequestOptions options)\n1 Future\u0026lt;String\u0026gt; transformRequest(RequestOptions options) async { 2 var data = options.data ?? \u0026#34;\u0026#34;; 3 if (data is! String) { 4 if (options.contentType.mimeType == ContentType.json.mimeType) { 5 return json.encode(options.data); 6 } else if (data is Map) { 7 return Transformer.urlEncodeMap(data); 8 } 9 } 10 return data.toString(); 11 } 再找到 Transformer.urlEncodeMap(data)\n1static String urlEncodeMap(data) { 2 StringBuffer urlData = new StringBuffer(\u0026#34;\u0026#34;); 3 bool first = true; 4 void urlEncode(dynamic sub, String path) { 5 if (sub is List) { 6 for (int i = 0; i \u0026lt; sub.length; i++) { 7 urlEncode(sub[i], 8 \u0026#34;$path%5B${(sub[i] is Map || sub[i] is List) ? i : \u0026#39;\u0026#39;}%5D\u0026#34;); 9 } 10 } else if (sub is Map) { 11 sub.forEach((k, v) { 12 if (path == \u0026#34;\u0026#34;) { 13 urlEncode(v, \u0026#34;${Uri.encodeQueryComponent(k)}\u0026#34;); 14 } else { 15 urlEncode(v, \u0026#34;$path%5B${Uri.encodeQueryComponent(k)}%5D\u0026#34;); 16 } 17 }); 18 } else { 19 if (!first) { 20 urlData.write(\u0026#34;\u0026amp;\u0026#34;); 21 } 22 first = false; 23 urlData.write(\u0026#34;$path=${Uri.encodeQueryComponent(sub.toString())}\u0026#34;); 24 } 25 } 26 27 urlEncode(data, \u0026#34;\u0026#34;); 28 return urlData.toString(); 29 } 30} 31 得到的结果是\n1dataArr%5B0%5D%5Btype%5D=file\u0026amp;dataArr%5B0%5D%5Bpath%5D=home%2Fwsdsd.tx 2decoded=\u0026gt; 3dataArr[0][type]=file\u0026amp;dataArr[0][path]=home/wsdsd.tx 晕，我也没时间看它错在哪里了，看来做好的办法就是自己进行encode编码了，也就是除了key=value之间的=号其他都要进行url编码，毕竟=才是唯一标准，看来dio库也是有bug的。顺便提一下，flutter的log居然从来不打双引号或者单引号，String看起来真麻烦。\n按照刚才的例子直接改成\n1String encodeQuery = \u0026#34;dataArr=${Uri.encodeQueryComponent(json.encode(dataArr))}\u0026#34;; 2data=encodeQuery 这样就可以了。\n","date":"2019-07-22","img":"","permalink":"https://helixs.github.io/posts/2019-07-22-flutter-dio%E8%BF%9B%E8%A1%8Capplication-x-www-form-urlencoded%E8%AF%B7%E6%B1%82%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/","series":null,"tags":null,"title":"Flutter.dio进行application/X-Www-Form-Urlencoded请求注意事项"},{"categories":["Android开发"],"content":"转载请注明出处\n 今天测试提示了bug，在文件上传的时候会有进度显示，可是每次都会显示200%。找了半天也没有找到具体的问题所在。所以，我就从上传触发点入手了。\n 原代码如下1////创建文件上传的RequestBody,通过实现writeTo方法，监听文件上传的过程。 2 3private fun createProgressRequestBody(contentType: MediaType, file: File, progressCallBack: ProgressCallBack): RequestBody { 4 return object : RequestBody() { 5 override fun contentType(): MediaType? { 6 return contentType 7 } 8 9 override fun contentLength(): Long { 10 return file.length() 11 } 12 13 override fun writeTo(sink: BufferedSink) { 14 15 var source: Source? = null 16 val buf = Buffer() 17 try { 18 source = Okio.source(file) 19 20 var current: Long = 0 21 //每20KB向外Call一次 22 val percentage = 20 * 1024L 23 24 do { 25 val readCount = source.read(buf, 1024L * 8) 26 27 if (readCount \u0026lt; 0) { 28 break 29 } 30 sink.write(buf, readCount) 31 current += readCount 32 33 if (current \u0026gt;= percentage) { 34 progressCallBack.progress(current) 35 current = 0 36 } 37 38 } while (true) 39 40 41 } catch (e: Exception) { 42 e.printStackTrace() 43 } finally { 44 Util.closeQuietly(source) 45 buf.clear() 46 } 47 48 49 50 } 51 } 52} 按道理来说这样执行都没啥问题的，不过它居然执行了两次。没办法了，去看Okhttp的源码，还是被我找到了\n1//HttpLoggingInterceptor的拦截器中执行了此方法 2 if (!logBody || !hasRequestBody) { 3 logger.log(\u0026#34;--\u0026gt; END \u0026#34; + request.method()); 4 } else if (bodyEncoded(request.headers())) { 5 logger.log(\u0026#34;--\u0026gt; END \u0026#34; + request.method() + \u0026#34; (encoded body omitted)\u0026#34;); 6 } else { 7 Buffer buffer = new Buffer(); 8 requestBody.writeTo(buffer); 9 10 Charset charset = UTF8; 11 MediaType contentType = requestBody.contentType(); 12 if (contentType != null) { 13 charset = contentType.charset(UTF8); 14 } 上面是第一次，下面是第二次\n1//这是CallServerInterceptor也就是最后一个任务链的末端拦截器即真实网络调用 2HttpCodec httpCodec = realChain.httpStream(); 3StreamAllocation streamAllocation = realChain.streamAllocation(); 4RealConnection connection = (RealConnection) realChain.connection(); 5Request request = realChain.request(); 6 7long sentRequestMillis = System.currentTimeMillis(); 8 9realChain.eventListener().requestHeadersStart(realChain.call()); 10httpCodec.writeRequestHeaders(request); 11realChain.eventListener().requestHeadersEnd(realChain.call(), request); 12 13Response.Builder responseBuilder = null; 14if (HttpMethod.permitsRequestBody(request.method()) \u0026amp;\u0026amp; request.body() != null) { 15 // If there\u0026#39;s a \u0026#34;Expect: 100-continue\u0026#34; header on the request, wait for a \u0026#34;HTTP/1.1 100 16 // Continue\u0026#34; response before transmitting the request body. If we don\u0026#39;t get that, return 17 // what we did get (such as a 4xx response) without ever transmitting the request body. 18 if (\u0026#34;100-continue\u0026#34;.equalsIgnoreCase(request.header(\u0026#34;Expect\u0026#34;))) { 19 httpCodec.flushRequest(); 20 realChain.eventListener().responseHeadersStart(realChain.call()); 21 responseBuilder = httpCodec.readResponseHeaders(true); 22 } 23 24 if (responseBuilder == null) { 25 // Write the request body if the \u0026#34;Expect: 100-continue\u0026#34; expectation was met. 26 realChain.eventListener().requestBodyStart(realChain.call()); 27 long contentLength = request.body().contentLength(); 28 CountingSink requestBodyOut = 29 new CountingSink(httpCodec.createRequestBody(request, contentLength)); 30 BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut); 31 32 request.body().writeTo(bufferedRequestBody); 33 bufferedRequestBody.close(); 34 realChain.eventListener() 35 .requestBodyEnd(realChain.call(), requestBodyOut.successfulCount); 36 } else if (!connection.isMultiplexed()) { 37 // If the \u0026#34;Expect: 100-continue\u0026#34; expectation wasn\u0026#39;t met, prevent the HTTP/1 connection 38 // from being reused. Otherwise we\u0026#39;re still obligated to transmit the request body to 39 // leave the connection in a consistent state. 40 streamAllocation.noNewStreams(); 41 } 42} 看看Okio.buffer中是什么\n1public static BufferedSink buffer(Sink sink) { 2 return new RealBufferedSink(sink); 3 } 执行顺序大概是\n第一次\u0026gt;HttpLoggingInterceptor.intercept:\n MultipartBody.writeTo(BufferedSink)=\u0026gt; writeOrCountBytes(BufferedSink)=\u0026gt; PartBody.writeTo(BufferedSink)=\u0026gt; 我们实现的writeTo(BufferedSink)\n 第二次\u0026gt;CallServerInterceptor.intercept:\n MultipartBody.writeTo(BufferedSink)=\u0026gt; writeOrCountBytes(BufferedSink)=\u0026gt; PartBody.writeTo(BufferedSink)=\u0026gt;  我们实现的writeTo(BufferedSink)\n 除了调用的地方，其他后续操作都一样，不一样的主要就是一个是writeTo(Buffer)一个是writeTo(RealBufferedSink)\nBufferedSink｛\n子类为Buffer和RealBufferedSink\n｝\nRealBufferedSink\n1public final Buffer buffer = new Buffer(); 2 public final Sink sink; 3 boolean closed; 4 5 RealBufferedSink(Sink sink) { 6 if (sink == null) throw new NullPointerException(\u0026#34;sink == null\u0026#34;); 7 this.sink = sink; 8 } 9 10 @Override public Buffer buffer() { 11 return buffer; 12 } 13 14 @Override public void write(Buffer source, long byteCount) 15 throws IOException { 16 if (closed) throw new IllegalStateException(\u0026#34;closed\u0026#34;); 17 buffer.write(source, byteCount); 18 emitCompleteSegments(); 19 } 由此可知，Buffer和RealBufferedSink都是BufferedSink的实现类，RealBufferedSink中拥有Buffer成员,write的时候真正也是调用的Buffer.write。\n所以我们可以通过判断BufferedSink的两个子类型来判断进行过滤。修改后的代码为\n1 private fun createProgressRequestBody(contentType: MediaType, file: File, progressCallBack: ProgressCallBack): RequestBody { 2 return object : RequestBody() { 3 override fun contentType(): MediaType? { 4 return contentType 5 } 6 7 override fun contentLength(): Long { 8 return file.length() 9 } 10 11 override fun writeTo(sink: BufferedSink) { 12 Logz.d(\u0026#34;paths1\u0026#34;, \u0026#34;${file.length()},${sink.javaClass.simpleName}\u0026#34;) 13 if (sink is Buffer) { 14 var source: Source? = null 15 try { 16 source = Okio.source(file) 17 sink.writeAll(source!!) 18 } finally { 19 Util.closeQuietly(source) 20 } 21 22 } else { 23 var source: Source? = null 24 val buf = Buffer() 25 try { 26 source = Okio.source(file) 27 28 var current: Long = 0 29 30 val percentage = 20 * 1024L 31 32 do { 33 val readCount = source.read(buf, 1024L * 8) 34 35 if (readCount \u0026lt; 0) { 36 break 37 } 38 sink.write(buf, readCount) 39 current += readCount 40 41 if (current \u0026gt;= percentage) { 42 progressCallBack.progress(current) 43 current = 0 44 } 45 46 } while (true) 47 48 49 } catch (e: Exception) { 50 e.printStackTrace() 51 } finally { 52 Util.closeQuietly(source) 53 buf.clear() 54 } 55 56 } 57 58 } 59 } 60 } 测试一下好了。数据的Request和Response都会进入Okhttp的拦截器过滤和观察我们的数据，执行读取操作。除了我们自己添加的log拦截，默认还有自带的拦截器，他们会形成一个任务链模式。有人说直接把Httplog的等级改成Head那是很蠢的做法，那你还观察什么数据呢。或者自定义Log拦截器，把MultipartBody类型的日志过滤掉，这才是正确的做法，毕竟logcat里面弹出一堆乱码也是很烦的一件事。\n转载请注明出处 西门吹风\n","date":"2019-07-19","img":"","permalink":"https://helixs.github.io/posts/2019-07-19-okhttp%E5%8D%95%E4%B8%80%E8%AF%B7%E6%B1%82requestbody%E6%89%A7%E8%A1%8C%E4%B8%A4%E6%AC%A1writeto%E7%9A%84%E9%97%AE%E9%A2%98/","series":null,"tags":null,"title":"OkHttp单一请求RequestBody执行两次writeTo的问题"},{"categories":["linux常用配置"],"content":"编辑命令  Ctrl + a ：移到命令行首 Ctrl + e ：移到命令行尾 Ctrl + f ：按字符前移（右向） Ctrl + b ：按字符后移（左向） Alt + f ：按单词前移（右向） Alt + b ：按单词后移（左向） Ctrl + xx：在命令行首和光标之间移动 Ctrl + u ：从光标处删除至命令行首 Ctrl + k ：从光标处删除至命令行尾 Ctrl + w ：从光标处删除至字首 Alt + d ：从光标处删除至字尾 Ctrl + d ：删除光标处的字符 Ctrl + h ：删除光标前的字符 Ctrl + y ：粘贴至光标后 Alt + c ：从光标处更改为首字母大写的单词 Alt + u ：从光标处更改为全部大写的单词 Alt + l ：从光标处更改为全部小写的单词 Ctrl + t ：交换光标处和之前的字符 Alt + t ：交换光标处和之前的单词 Alt + Backspace：与 Ctrl + w 相同类似，分隔符有些差别  重新执行命令  Ctrl + r：逆向搜索命令历史 Ctrl + g：从历史搜索模式退出 Ctrl + p：历史中的上一条命令 Ctrl + n：历史中的下一条命令 Alt + .：使用上一条命令的最后一个参数  控制命令  Ctrl + l：清屏 Ctrl + o：执行当前命令，并选择上一条命令 Ctrl + s：阻止屏幕输出 Ctrl + q：允许屏幕输出 Ctrl + c：终止命令 Ctrl + z：挂起命令  Bang (!) 命令  !!：执行上一条命令 !blah：执行最近的以 blah 开头的命令，如 !ls !blah:p：仅打印输出，而不执行 !$：上一条命令的最后一个参数，与 Alt + . 相同 !$:p：打印输出 !$ 的内容 !*：上一条命令的所有参数 !*:p：打印输出 !* 的内容 ^blah：删除上一条命令中的 blah ^blah^foo：将上一条命令中的 blah 替换为 foo ^blah^foo^：将上一条命令中所有的 blah 都替换为 foo  vi/vim常用快捷键","date":"2019-06-11","img":"","permalink":"https://helixs.github.io/posts/2019-06-11-bash-shell%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/","series":null,"tags":null,"title":"Bash Shell常用快捷键"},{"categories":["C"],"content":" 1char *__cdecl fgets(char * __restrict__ _Buf,int _MaxCount,FILE * __restrict__ _File); 1char *__cdecl gets(char *_Buffer) __MINGW_ATTRIB_DEPRECATED_SEC_WARN;//编译时会弹出警告 1#include \u0026lt;stdio.h\u0026gt;2#include \u0026lt;string.h\u0026gt;3 4int main() { 5 char inputs[10] = \u0026#34;yes !\u0026#34;; 6 printf(\u0026#34;%s\u0026#34;,inputs); 7 puts(inputs); 8 gets(inputs); 9 printf(\u0026#34;%s\\n\u0026#34;,inputs); 10 fgets(inputs,30,stdin);//stdin标准输入缓冲区 11 printf(\u0026#34;%s\u0026#34;,inputs); 12 return 0; 13} 结果：\n1yes !yes ! 2I have been very bad today, I am mad at me! ! ! Especially my green hat 3I have been very bad today, I am mad at me! ! ! Especially my green hat 4I have been very bad today, I am mad at me! ! ! Especially my green hat 5I have been very bad today, I 红色是输入部分，printf默认不会加回车，puts会在后面加入回车。 定义的inputs数组的最大只有10，我所输入的所有字符都打印出来了，所以gets函数并没有检查也无法检查inputs所占用的空间和范围，毕竟读取字符串也只能按照\\0结尾。\n然后再来看看fgets()多了最大值和字符从那个地方获取。地方我们用默认就行了，毕竟不太懂。仔细数一数打印出来了多少个，其实是29个,看来第30个添加结束标志\\0。末尾的样子就是I\\0了\n所以我们以后输入字符串最好用fgets不要用gets。\n==看看输入字符后完整内存看看\n1char inputs[10] = \u0026#34;yes !\u0026#34;; 2 printf(\u0026#34;%s\u0026#34;,inputs); 3 puts(inputs); 4 gets(inputs); 5 printf(\u0026#34;%s\\n\u0026#34;,inputs); 6 fgets(inputs,10,stdin); 7 printf(\u0026#34;%s\\n\u0026#34;,inputs); 8 for (int i = 0; i \u0026lt; 11; ++i) { 9 //我们故意多一位来验证fgets最后除了\\0是否会多出一个换行符10，实际开发过程最好不要越界内存。 10 printf(\u0026#34;%d\\n\u0026#34;,inputs[i]); 11 } 12 printf(\u0026#34;----end------\u0026#34;); 13 return 0; 结果\n1yes !yes ! 2123456789 3123456789 4123456789 5123456789 649 750 851 952 1053 1154 1255 1356 1457 150 1610 17----end------ 就算少输几位后面也就是0 10 0 0 0，fgets无论你怎么输入都会在\\0后面加入\\n ascii为10，所以我们以后最好在判断\\0的\\n情况咯。\n ","date":"2019-05-30","img":"","permalink":"https://helixs.github.io/posts/2019-05-30-c%E8%AF%AD%E8%A8%80stdio%E4%B8%ADfgets%E5%92%8Cgetsputs%E7%9A%84%E5%8C%BA%E5%88%AB/","series":null,"tags":null,"title":"C语言stdio中fgets和gets、puts的区别"},{"categories":["电影生活"],"content":"如果你想无拘无束，天天看自己喜欢的美剧，请耐心看完这篇文章。因为如果你不学会这个技能，总有一天你只能看删减版。\n先介绍一下你看的美剧从哪里来。\n从美国电视，流媒体Hulu , Netflix ,亚马逊 来，国外有专门的兴趣小组从电视及流媒体录制片源然后在国外各大资源站传播，传播方式以BT为主。\n顶级渠道是0 day次级是PT，再次是BT。但是因为网络的发展，这三个渠道的传播速度已经基本相同，普通人也能第一时间获取美剧片源。\n那么重点来了在海盗湾淡出历史舞台后，哪个是最大的BT资源站？\n请百度rarbg 浏览这个网站务必安装广告拦截插件,哈哈顺便一句google是不会让你搜到它的，度娘可以搜到，纯国外网友建立，你想要的游戏，电影，美剧，XXX，基本都能找到。不过都是无字幕纯英文版，即生肉。\nrarbg是一个大型综合BT交流网站，没想到互联网发展这么多年还是原始的最好用吧？\n你想用迅雷是可以的，但是如果迅雷因为XXX原因不能下载，请换其他软件，比如qbittorrent ，utorrent (下面classic版本才是客户端,web版本是在线观看)，比特彗星 等等。\n因为rarbg里基本都是老外，所以你连接的BT链也是跨国传播，速度比较随缘。其实一般来说开始会慢，等等会快。如果等了很久也很慢，那只能是无缘了。\n这时候可以试试把磁力链接放进度盘离线，相信我以后没有好心人再给你传度盘了。\n好了生肉你会下了，字幕怎么办。\n第一，各大字幕组微博，欢迎关注。\n第二，字幕网站，比如字幕库 ，subhd 等等。\n如果你连外挂字幕都不会….百度一下很简单的。\n生肉加外挂字幕，感觉又回到十几年前了不是？\n切记，盗版始终有盗版的风险，追求正版是对视频的支持。我们只是需要未删减版对不？\n源自–ttmeiju微信公众号-酸梅电影\n","date":"2019-05-28","img":"","permalink":"https://helixs.github.io/posts/2019-05-28-%E8%88%92%E8%88%92%E6%9C%8D%E6%9C%8D%E7%9C%8B%E5%92%8Cbt%E6%9C%AA%E5%88%A0%E5%87%8F%E7%9A%84%E7%BE%8E%E5%89%A7/","series":null,"tags":null,"title":"舒舒服服看和bt未删减的美剧"},{"categories":["Android开发"],"content":"一、回顾一下以前的做法 以前我们在处理后台任务时，一般都是使用Service(含IntentService)或者线程/线程池，而Service不受页面生命周期影响，可以常驻后台，所以很适合做一些定时、延时任务，或者其他一些肉眼不可见的神秘勾当。 在处理一些复杂需求时，比如监听网络环境自动暂停重启后台上传下载这类变态任务，我们需要用Service结合Broadcast一起来做,非常的麻烦，再加上传输进度的回调，让人想疯！\n当然大量的后台任务过度消耗了设备的电量，比如多种第三方推送的service都在后台常驻，不良App后台自动上传用户隐私也带来了隐私安全问题。\n二、谷歌开始专项整顿  6.0 (API 级 23) 引入了Doze机制和应用程序待机 。当屏幕关闭且设备静止时, 打盹模式会限制应用程序的行为。应用程序待机将未使用的应用程序置于限制其网络访问、作业和同步的特殊状态。 Android 7.0 (API 级 24) 有限的隐性广播和Doze-on-the-go . Android 8.0 (API 级 26) 进一步限制了后台行为 , 例如在后台获取位置并释放缓存的 wakelocks。  尤其在Android O（8.0）中，谷歌对于后台的限制几乎可以称之为变态：\n Android 8.0 有一项复杂功能；系统不允许后台应用创建后台服务。 因此，Android 8.0 引入了一种全新的方法，即 Context.startForegroundService()，以在前台启动新服务。 在系统创建服务后，应用有五秒的时间来调用该服务的 startForeground() 方法以显示新服务的用户可见通知。 如果应用在此时间限制内未调用 startForeground()，则系统将停止服务并声明此应用为 ANR。\n 而且加入了对静态广播的限制：\n Android 8.0 让这些限制更为严格。 针对 Android 8.0 的应用无法继续在其清单中为隐式广播注册广播接收器。 隐式广播是一种不专门针对该应用的广播。 例如，ACTION_PACKAGE_REPLACED 就是一种隐式广播，因为它将发送到注册的所有侦听器，让后者知道设备上的某些软件包已被替换。 不过，ACTION_MY_PACKAGE_REPLACED 不是隐式广播，因为不管已为该广播注册侦听器的其他应用有多少，它都会只发送到软件包已被替换的应用。 应用可以继续在它们的清单中注册显式广播。 应用可以在运行时使用 Context.registerReceiver() 为任意广播（不管是隐式还是显式）注册接收器。 需要签名权限的广播不受此限制所限，因为这些广播只会发送到使用相同证书签名的应用，而不是发送到设备上的所有应用。 在许多情况下，之前注册隐式广播的应用使用 JobScheduler 作业可以获得类似的功能。\n 于此同时，官方推荐用5.0推出的JobScheduler替换Service + Broadcast的方案。\n并且在Android O，后台Service启动后的5秒内，如果不转为前台Service就会ANR!\n三、官方的推荐（qiang zhi）做法    场景 推荐     需系统触发，不必完成 ThreadPool + Broadcast   需系统触发，必须完成，可推迟 WorkManager   需系统触发，必须完成，立即 ForegroundService + Broadcast   不需系统触发，不必完成 ThreadPool   不需系统触发，必须完成，可推迟 WorkManager   不需系统触发，必须完成，立即 ForegroundService    四、WorkManager的推出  WorkManager 是一个 Android 库, 它在工作的触发器 (如适当的网络状态和电池条件) 满足时, 优雅地运行可推迟的后台工作。WorkManager 尽可能使用框架 JobScheduler , 以帮助优化电池寿命和批处理作业。在 Android 6.0 (API 级 23) 下面的设备上, 如果 WorkManager 已经包含了应用程序的依赖项, 则尝试使用Firebase JobDispatcher 。否则, WorkManager 返回到自定义 AlarmManager 实现, 以优雅地处理您的后台工作。\n 也就是说，WorkManager可以自动维护后台任务，同时可适应不同的条件，同时满足后台Service和静态广播，内部维护着JobScheduler，而在6.0以下系统版本则可自动切换为AlarmManager，好神奇！\n五、WorkManager详解 1.引入 1implementation \u0026#34;android.arch.work:work-runtime:1.0.0-alpha06\u0026#34; // use -ktx for Kotlin 2.重要的类解析 2.1 Worker  Worker是一个抽象类，用来指定需要执行的具体任务。我们需要继承Worker类，并实现它的doWork方法：\n1class MyWorker:Worker() { 2 3 val tag = javaClass.simpleName 4 5 override fun getExtras(): Extras { 6 return Extras(...) //也可以把参数写死在这里 7 } 8 9 override fun onStopped(cancelled: Boolean) { 10 super.onStopped(cancelled) 11 //当任务结束时会回调这里 12 ... 13 } 14 15 override fun doWork(): Result { 16 17 Log.d(tag,\u0026#34;任务执行完毕！\u0026#34;) 18 return Worker.Result.SUCCESS 19 } 20} 向任务添加参数    在Request中传参：    1val data=Data.Builder() 2 .putInt(\u0026#34;A\u0026#34;,1) 3 .putString(\u0026#34;B\u0026#34;,\u0026#34;2\u0026#34;) 4 .build() 5val request2 = PeriodicWorkRequestBuilder\u0026lt;MyWorker\u0026gt;(24,TimeUnit.SECONDS) 6 .setInputData(data) 7 .build()   在Worker中使用：    1class MyWorker:Worker() { 2 3 val tag = javaClass.simpleName 4 5 override fun doWork(): Result { 6 7 val A = inputData.getInt(\u0026#34;A\u0026#34;,0) 8 val B = inputData.getString(\u0026#34;B\u0026#34;) 9 return Worker.Result.SUCCESS 10 } 11} 当然除了上述代码中的方法之外，我们也可以重写父级的getExtras()，并在此方法中把参数写死再返回也是可以的。\n这里WorkManager就有一个不是很人性的地方了，那就是WorkManager不支持序列化传值！这一点让我怎么说啊，intent和Bundle都支持序列化传值，为什么偏偏这货就不行？那么如果传一个复杂对象还要先拆解吗?\n任务的返回值 很类似很类似的，任务的返回值也很简单：\n1override fun doWork(): Result { 2 3 val A = inputData.getInt(\u0026#34;A\u0026#34;,0) 4 val B = inputData.getString(\u0026#34;B\u0026#34;) 5 6 val data = Data.Builder() 7 .putBoolean(\u0026#34;C\u0026#34;,true) 8 .putFloat(\u0026#34;D\u0026#34;,0f) 9 .build() 10 outputData = data//返回值 11 return Worker.Result.SUCCESS 12} doWork要求最后返回一个Result，这个Result是一个枚举，它有几个固定的值：\n FAILURE 任务失败。 RETRY 遇到暂时性失败，此时可使用WorkRequest.Builder.setBackoffCriteria(BackoffPolicy, long, TimeUnit)来重试。 SUCCESS 任务成功。  看到这里我就很奇怪，官方不推荐我们使用枚举，但是自己却一直在用，什么意思？\n2.2 WorkRequest  也是一个抽象类，可以对Work进行包装，同时装裱上一系列的约束（Constraints），这些Constraints用来向系统指明什么条件下，或者什么时候开始执行任务。\nWorkManager向我们提供了WorkRequest的两个子类：\n OneTimeWorkRequest 单次任务。 PeriodicWorkRequest 周期任务。  1val request1 = PeriodicWorkRequestBuilder\u0026lt;MyWorker\u0026gt;(60,TimeUnit.SECONDS).build() 2val request2 = OneTimeWorkRequestBuilder\u0026lt;MyWorker\u0026gt;().build() 从代码中可以看到，我们应该使用不同的构造器来创建对应的WorkRequest。\n接下来我们看看都有哪些约束：\n public boolean requiresBatteryNotLow ()：执行任务时电池电量不能偏低。 public boolean requiresCharging ()：在设备充电时才能执行任务。 public boolean requiresDeviceIdle ()：设备空闲时才能执行。 public boolean requiresStorageNotLow ()：设备储存空间足够时才能执行。  addContentUriTrigger 1@RequiresApi(24) 2public @NonNull Builder addContentUriTrigger(Uri uri, boolean triggerForDescendants) 指定是否在(Uri指定的)内容更新时执行本次任务（只能用于Api24及以上版本）。瞄了一眼源码发现了一个ContentUriTriggers，这什么东东？\n1public final class ContentUriTriggers implements Iterable\u0026lt;ContentUriTriggers.Trigger\u0026gt; { 2 3 private final Set\u0026lt;Trigger\u0026gt; mTriggers = new HashSet\u0026lt;\u0026gt;(); 4 5 6 public static final class Trigger { 7 private final @NonNull Uri mUri; 8 private final boolean mTriggerForDescendants; 9 10 Trigger(@NonNull Uri uri, boolean triggerForDescendants) { 11 mUri = uri; 12 mTriggerForDescendants = triggerForDescendants; 13 } 14} 特么惊呆了，居然是个HashSet，而HashSet的核心是个HashMap啊，谷歌声明不建议用HashMap，当然也就不建议用HashSet，可是官方自己在背地里面干的这些勾当啊…\nsetRequiredNetworkType 1public void setRequiredNetworkType (NetworkType requiredNetworkType) 指定任务执行时的网络状态。其中状态见下表：\n   枚举 状态     NOT_REQUIRED 不需要网络   CONNECTED 任何可用网络   UNMETERED 需要不计量网络，如WiFi   NOT_ROAMING 需要非漫游网络   METERED 需要计量网络，如4G    setRequiresBatteryNotLow 1public void setRequiresBatteryNotLow (boolean requiresBatteryNotLow) 指定设备电池电量低于阀值时是否启动任务，默认false。\nsetRequiresCharging 1public void setRequiresCharging (boolean requiresCharging) 指定设备在充电时是否启动任务。\nsetRequiresDeviceIdle 1public void setRequiresDeviceIdle (boolean requiresDeviceIdle) 指明设备是否为空闲时是否启动任务。\nsetRequiresStorageNotLow 1public void setRequiresStorageNotLow (boolean requiresStorageNotLow) 指明设备储存空间低于阀值时是否启动任务。\n给任务加约束： 1val myConstraints = Constraints.Builder() 2 .setRequiresDeviceIdle(true)//指定{@link WorkRequest}运行时设备是否为空闲 3 .setRequiresCharging(true)//指定要运行的{@link WorkRequest}是否应该插入设备 4 .setRequiredNetworkType(NetworkType.NOT_ROAMING) 5 .setRequiresBatteryNotLow(true)//指定设备电池是否不应低于临界阈值 6 .setRequiresCharging(true)//网络状态 7 .setRequiresDeviceIdle(true)//指定{@link WorkRequest}运行时设备是否为空闲 8 .setRequiresStorageNotLow(true)//指定设备可用存储是否不应低于临界阈值 9 .addContentUriTrigger(myUri,false)//指定内容{@link android.net.Uri}时是否应该运行{@link WorkRequest}更新 10 .build() 11val request = PeriodicWorkRequestBuilder\u0026lt;MyWorker\u0026gt;(24,TimeUnit.SECONDS) 12 .setConstraints(myConstraints)//注意看这里！！！ 13 .build() 给任务加标签分组 1val request1 = OneTimeWorkRequestBuilder\u0026lt;MyWorker\u0026gt;() 2 .addTag(\u0026#34;A\u0026#34;)//标签 3 .build() 4val request2 = OneTimeWorkRequestBuilder\u0026lt;MyWorker\u0026gt;() 5 .addTag(\u0026#34;A\u0026#34;)//标签 6 .build() 上述代码我给两个相同任务的request都加上了标签，使他们成为了一个组：A组。这样的好处是以后可以直接控制整个组就行了，组内的每个成员都会受到影响。\n2.3 WorkManager  经过上面的操作，相信我们已经能够成功创建request了，接下来我们就需要把任务放进任务队列，我们使用WorkManager。\nWorkManager是个单例，它负责调度任务并且监听任务状态。\n1WorkManager.getInstance().enqueue(request) 当我们的request入列后，WorkManager会给它分配一个work ID，之后我们可以使用这个work id来取消或者停止任务：\n1WorkManager.getInstance().cancelWorkById(request.id) 注意：WorkManager并不一定能结束任务，因为任务有可能已经执行完毕了。\n同时，WorkManager还提供了其他结束任务的方法：\n cancelAllWork():取消所有任务。 cancelAllWorkByTag(tag:String):取消一组带有相同标签的任务。 cancelUniqueWork(uniqueWorkName:String):取消唯一任务。  2.4WorkStatus  当WorkManager把任务加入队列后，会为每个WorkRequest对象提供一个LiveData（如果这个东东不了解的话赶紧去学）。 LiveData持有WorkStatus;通过观察该 LiveData, 我们可以确定任务的当前状态, 并在任务完成后获取所有返回的值。\n1val liveData: LiveData\u0026lt;WorkStatus\u0026gt; = WorkManager.getInstance().getStatusById(request.id) 我们来看这个WorkStatus到底都包涵什么，我们点进去看它的源码：\n1public final class WorkStatus { 2 3 private @NonNull UUID mId; 4 private @NonNull State mState; 5 private @NonNull Data mOutputData; 6 private @NonNull Set\u0026lt;String\u0026gt; mTags; 7 8 public WorkStatus( 9 @NonNull UUID id, 10 @NonNull State state, 11 @NonNull Data outputData, 12 @NonNull List\u0026lt;String\u0026gt; tags) { 13 mId = id; 14 mState = state; 15 mOutputData = outputData; 16 mTags = new HashSet\u0026lt;\u0026gt;(tags); 17 } 我们需要关注的只有State和Data这两个属性，首先看State:\n1public enum State { 2 3 ENQUEUED,//已加入队列 4 RUNNING,//运行中 5 SUCCEEDED,//已成功 6 FAILED,//已失败 7 BLOCKED,//已刮起 8 CANCELLED;//已取消 9 10 public boolean isFinished() { 11 return (this == SUCCEEDED || this == FAILED || this == CANCELLED); 12 } 13} 这特么又一个枚举。看过代码之后，State枚举其实就是用来给我们做最后的结果判断的。但是要注意其中有个已挂起BLOCKED，这是啥子情况？通过看它的注释，我们得知，如果WorkRequest的约束没有通过，那么这个任务就会处于挂起状态。\n接下来，Data当然就是我们在任务中doWork的返回值了\n看到这里，我感觉谷歌大佬的设计思维还是非常之强的，把状态和返回值同时输出，非常方便我们做判断的同时来取值，并且这样的设计就可以达到‘多次返回’的效果，有时间一定要去看一下源码，先立个flag！\n3. 任务链 在很多场景中，我们需要把不同的任务弄成一个队列，比如在用户注册的时候，我们要先验证手机短信验证码，验证成功后再注册，注册成功后再调登陆接口实现自动登陆。类似这样相似的逻辑比比皆是，实话说笔者以前都是在service里面用rxjava来实现的。但是现在service在Android8.0版本以上系统不能用了怎么办？当然还是用我们今天学到的WorkManager来实现，接下来我们就一起看一下WorkManager的任务链。\n3.1链式启动-并发 1val request1 = OneTimeWorkRequestBuilder\u0026lt;MyWorker1\u0026gt;().build() 2val request2 = OneTimeWorkRequestBuilder\u0026lt;MyWorker2\u0026gt;().build() 3val request3 = OneTimeWorkRequestBuilder\u0026lt;MyWorker3\u0026gt;().build() 4 5WorkManager.getInstance().beginWith(request1,request2,request3) 6.enqueue() 这样等同于WorkManager把一个个的WorkRequest enqueue进队列，但是这样写明显更整齐！同时队列中的任务是并行的。\n3.2 then操作符-串发 1val request1 = OneTimeWorkRequestBuilder\u0026lt;MyWorker\u0026gt;().build() 2val request2 = OneTimeWorkRequestBuilder\u0026lt;MyWorker\u0026gt;().build() 3val request3 = OneTimeWorkRequestBuilder\u0026lt;MyWorker\u0026gt;().build() 4 5WorkManager.getInstance().beginWith(request1) 6 .then(request2) 7 .then(request3) 8 .enqueue() 上述代码的意思就是先1，1成功后再2，2成功后再3，这期间如果有任何一个任务失败（返回Worker.WorkerResult.FAILURE),则整个队列就会被中断。\n在任务链的串行中，也就是两个任务使用了then操作符连接，那么上一个任务的返回值就会自动转为下一个任务的参数！\n3.3 combine操作符-组合 现在我们有个复杂的需求：共有A、B、C、D、E这五个任务，要求AB串行，CD串行，但两个串之间要并发，并且最后要把两个串的结果汇总到E。\n我们看到这种复杂的业务逻辑，往往都会吓一跳，但是牛X的谷歌提供了combine操作符专门应对这种奇葩逻辑，不得不说：谷歌是我亲哥！\n1val chuan1 = WorkManager.getInstance() 2 .beginWith(A) 3 .then(B) 4val chuan2 = WorkManager.getInstance() 5 .beginWith(C) 6 .then(D) 7WorkContinuation 8 .combine(chuan1, chuan2) 9 .then(E) 10 .enqueue() 4. 唯一链 什么是唯一链，就是同一时间内队列里不能存在相同名称的任务。\n1val request = OneTimeWorkRequestBuilder\u0026lt;MyWorker\u0026gt;().build() 2WorkManager.getInstance().beginUniqueWork(\u0026#34;tag\u0026#34;，ExistingWorkPolicy.REPLACE,request,request,request) 从上面代码我们可以看到，首先与之前不同的是，这次我们用的是beginUniqueWork方法，这个方法的最后一个参数是一个可变长度的数组，那就证明这一定是一根链条。\n然后我们看这个方法的第一个参数，要求输入一个名称，这个名称就是用来标识任务的唯一性。那如果两个不同的任务我们给了相同的名称也是可以的，但是这两个任务在队列中只能存活一个。\n最后我们再来看第二个参数ExistingWorkPolicy,点进去果然又双叒是枚举：\n1public enum ExistingWorkPolicy { 2 3 REPLACE, 4 KEEP, 5 APPEND 6}  REPLACE：如果队列里面已经存在相同名称的任务，并且该任务处于挂起状态则替换之。 KEEP：如果队列里面已经存在相同名称的任务，并且该任务处于挂起状态，则什么也不做。 APPEND：如果队列里面已经存在相同名称的任务，并且该任务处于挂起状态，则会缓存新任务。当队列中所有任务执行完毕后，以这个新任务做为序列的第一个任务。  原文出处 ","date":"2019-05-27","img":"","permalink":"https://helixs.github.io/posts/2019-05-27-workmanager%E8%AF%A6%E8%A7%A3/","series":null,"tags":null,"title":"WorkManager详解"},{"categories":["python"],"content":"刚刚学习python又找不到练手的地方，所以闲来无事写了一个腾讯云活动查询的小爬虫，比较简单，也算是练手的\n当前时段正在进行的活动\n1# coding:utf-8 2from urllib.request import urlopen 3from bs4 import Tag 4from bs4 import BeautifulSoup 5 6html = urlopen(\u0026#34;https://cloud.tencent.com/act/mid-year?from=10682\u0026#34;).read().decode(\u0026#39;utf-8\u0026#39;) 7 8soup = BeautifulSoup(html, features=\u0026#39;lxml\u0026#39;) 9 10startTag = soup.find(\u0026#39;div\u0026#39;, {\u0026#34;class\u0026#34;: \u0026#39;c-mod e-s-slot-list list-5 seckill-mod\u0026#39;}) 11 12publish = startTag.find_all(\u0026#39;div\u0026#39;, {\u0026#34;class\u0026#34;: \u0026#39;e-s-slot-item\u0026#39;}) 13 14all_list = [] 15 16for s in publish: 17 tags = [child for child in s.descendants if (type(child) is Tag) and child.has_attr(\u0026#39;class\u0026#39;)] 18 if len(tags) == 0: 19 continue 20 currentDic = {} 21 for tag in tags: 22 classes = tag[\u0026#39;class\u0026#39;] 23 for class_name in classes: 24 25 if class_name == \u0026#39;e-s-card-tit\u0026#39;: 26 # 产品名称 27 currentDic[\u0026#39;name\u0026#39;] = tag.get_text() 28 elif class_name == \u0026#39;e-s-card-param\u0026#39;: 29 # 产品标签 30 labels = [] 31 for label_child in tag.children: 32 label = {label_child.contents[1].get_text(): label_child.contents[0].get_text()} 33 labels.append(label) 34 currentDic[\u0026#39;labels\u0026#39;] = labels 35 elif class_name == \u0026#39;e-venue-discount-desc\u0026#39;: 36 currentDic[\u0026#39;month_price\u0026#39;] = tag.get_text() 37 elif class_name == \u0026#39;user-tag\u0026#39;: 38 currentDic[\u0026#39;user-tag\u0026#39;] = tag.get_text() 39 elif class_name == \u0026#39;e-venue-price\u0026#39;: 40 currentDic[\u0026#39;price\u0026#39;] = tag.get_text() 41 elif class_name == \u0026#39;e-s-card-seckill-progress-txt\u0026#39;: 42 currentDic[\u0026#39;remaining\u0026#39;] = tag.get_text() 43 all_list.append(currentDic) 44 45print(all_list) 46... 47{\u0026#39;name\u0026#39;: \u0026#39;AMD云服务器1C1G\u0026#39;, \u0026#39;labels\u0026#39;: [{\u0026#39;实例\u0026#39;: \u0026#39;SA1\u0026#39;}, {\u0026#39;带宽\u0026#39;: \u0026#39;1M\u0026#39;}, {\u0026#39;高性能盘\u0026#39;: \u0026#39;50G\u0026#39;}], \u0026#39;month_price\u0026#39;: \u0026#39;约8.31元/月\u0026#39;, \u0026#39;user-tag\u0026#39;: \u0026#39;新用户专享\u0026#39;, \u0026#39;price\u0026#39;: \u0026#39;299元/3年\u0026#39;, \u0026#39;remaining\u0026#39;: \u0026#39;已抢34%\u0026#39;} 48{\u0026#39;name\u0026#39;: \u0026#39;云服务器2C4G\u0026#39;, \u0026#39;labels\u0026#39;: [{\u0026#39;实例\u0026#39;: \u0026#39;S2\u0026#39;}, {\u0026#39;带宽\u0026#39;: \u0026#39;5M\u0026#39;}, {\u0026#39;高性能盘\u0026#39;: \u0026#39;50G\u0026#39;}], \u0026#39;month_price\u0026#39;: \u0026#39;约33.33元/月\u0026#39;, \u0026#39;user-tag\u0026#39;: \u0026#39;新用户专享\u0026#39;, \u0026#39;price\u0026#39;: \u0026#39;1200元/3年\u0026#39;, \u0026#39;remaining\u0026#39;: \u0026#39;已抢43.3%\u0026#39;} 49{\u0026#39;name\u0026#39;: \u0026#39;云服务器8C16G\u0026#39;, \u0026#39;labels\u0026#39;: [{\u0026#39;实例\u0026#39;: \u0026#39;S2\u0026#39;}, {\u0026#39;带宽\u0026#39;: \u0026#39;5M\u0026#39;}, {\u0026#39;高性能盘\u0026#39;: \u0026#39;50G\u0026#39;}], \u0026#39;month_price\u0026#39;: \u0026#39;约166.64元/月\u0026#39;, \u0026#39;user-tag\u0026#39;: \u0026#39;企业用户专享\u0026#39;, \u0026#39;price\u0026#39;: \u0026#39;5999元/3年\u0026#39;, \u0026#39;remaining\u0026#39;: \u0026#39;已抢22.2%\u0026#39;} 50{\u0026#39;name\u0026#39;: \u0026#39;AMD云服务器1C1G\u0026#39;, \u0026#39;labels\u0026#39;: [{\u0026#39;实例\u0026#39;: \u0026#39;SA1\u0026#39;}, {\u0026#39;带宽\u0026#39;: \u0026#39;5M\u0026#39;}, {\u0026#39;高性能盘\u0026#39;: \u0026#39;50G\u0026#39;}], \u0026#39;month_price\u0026#39;: \u0026#39;约16.64元/月\u0026#39;, \u0026#39;user-tag\u0026#39;: \u0026#39;新用户专享\u0026#39;, \u0026#39;price\u0026#39;: \u0026#39;599元/3年\u0026#39;, \u0026#39;remaining\u0026#39;: \u0026#39;已抢24.3%\u0026#39;} 51{\u0026#39;name\u0026#39;: \u0026#39;CDN流量包\u0026#39;, \u0026#39;labels\u0026#39;: [{\u0026#39;流量\u0026#39;: \u0026#39;50T\u0026#39;}, {\u0026#39;有效期\u0026#39;: \u0026#39;6个月\u0026#39;}], \u0026#39;month_price\u0026#39;: \u0026#39;约0.09元/G\u0026#39;, \u0026#39;price\u0026#39;: \u0026#39;4610元\u0026#39;, \u0026#39;remaining\u0026#39;: \u0026#39;已抢16.7%\u0026#39;} 52... ","date":"2019-05-24","img":"","permalink":"https://helixs.github.io/posts/2019-05-24-%E8%85%BE%E8%AE%AF%E4%BA%91%E7%A7%92%E6%9D%80%E6%B4%BB%E5%8A%A8%E4%BF%A1%E6%81%AF%E6%9F%A5%E8%AF%A2%E8%84%9A%E6%9C%AC/","series":null,"tags":null,"title":"腾讯云秒杀活动信息查询脚本"},{"categories":["编程语言"],"content":"表达式全集    字符 描述     \\ 将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，“n”匹配字符“n”。“\\n”匹配一个换行符。串行“\\”匹配“\\”而“(”则匹配“(”。   ^ 匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配“\\n”或“\\r”之后的位置。   $ 匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，$也匹配“\\n”或“\\r”之前的位置。   * 匹配前面的子表达式零次或多次。例如，zo*能匹配“z”以及“zoo”。*等价于{0,}。   + 匹配前面的子表达式一次或多次。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。   ? 匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“does”或“does”中的“do”。?等价于{0,1}。   {n} n是一个非负整数。匹配确定的n次。例如，“o{2}”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个o。   {n,} n是一个非负整数。至少匹配n次。例如，“o{2,}”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。“o{1,}”等价于“o+”。“o{0,}”则等价于“o*”。   {n,m} m和n均为非负整数，其中n\u0026lt;=m。最少匹配n次且最多匹配m次。例如，“o{1,3}”将匹配“fooooood”中的前三个o。“o{0,1}”等价于“o?”。请注意在逗号和两个数之间不能有空格。   ? 当该字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“oooo”，“o+?”将匹配单个“o”，而“o+”将匹配所有“o”。   . 匹配除“\\n”之外的任何单个字符。要匹配包括“\\n”在内的任何字符，请使用像“(.   (pattern) 匹配pattern并获取这一匹配。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0…$9属性。要匹配圆括号字符，请使用“(”或“)”。   (?:pattern) 匹配pattern但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用或字符“(   (?=pattern) 正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，“Windows(?=95   (?!pattern) 正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如“Windows(?!95   (?\u0026lt;=pattern) 反向肯定预查，与正向肯定预查类拟，只是方向相反。例如，“(?\u0026lt;=95   (?\u0026lt;!pattern) 反向否定预查，与正向否定预查类拟，只是方向相反。例如“(?\u0026lt;!95   x y   [xyz] 字符集合。匹配所包含的任意一个字符。例如，“[abc]”可以匹配“plain”中的“a”。   [^xyz] 负值字符集合。匹配未包含的任意字符。例如，“[^abc]”可以匹配“plain”中的“p”。   [a-z] 字符范围。匹配指定范围内的任意字符。例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。   [^a-z] 负值字符范围。匹配任何不在指定范围内的任意字符。例如，“[^a-z]”可以匹配任何不在“a”到“z”范围内的任意字符。   \\b 匹配一个单词边界，也就是指单词和空格间的位置。例如，“er\\b”可以匹配“never”中的“er”，但不能匹配“verb”中的“er”。   \\B 匹配非单词边界。“er\\B”能匹配“verb”中的“er”，但不能匹配“never”中的“er”。   \\cx 匹配由x指明的控制字符。例如，\\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“c”字符。   \\d 匹配一个数字字符。等价于[0-9]。   \\D 匹配一个非数字字符。等价于[^0-9]。   \\f 匹配一个换页符。等价于\\x0c和\\cL。   \\n 匹配一个换行符。等价于\\x0a和\\cJ。   \\r 匹配一个回车符。等价于\\x0d和\\cM。   \\s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于[ \\f\\n\\r\\t\\v]。   \\S 匹配任何非空白字符。等价于[^ \\f\\n\\r\\t\\v]。   \\t 匹配一个制表符。等价于\\x09和\\cI。   \\v 匹配一个垂直制表符。等价于\\x0b和\\cK。   \\w 匹配包括下划线的任何单词字符。等价于“[A-Za-z0-9_]”。   \\W 匹配任何非单词字符。等价于“[^A-Za-z0-9_]”。   \\xn 匹配n，其中n为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，“\\x41”匹配“A”。“\\x041”则等价于“\\x04\u0026amp;1”。正则表达式中可以使用ASCII编码。.   \\num 匹配num，其中num是一个正整数。对所获取的匹配的引用。例如，“(.)\\1”匹配两个连续的相同字符。   \\n 标识一个八进制转义值或一个向后引用。如果\\n之前至少n个获取的子表达式，则n为向后引用。否则，如果n为八进制数字（0-7），则n为一个八进制转义值。   \\nm 标识一个八进制转义值或一个向后引用。如果\\nm之前至少有nm个获得子表达式，则nm为向后引用。如果\\nm之前至少有n个获取，则n为一个后跟文字m的向后引用。如果前面的条件都不满足，若n和m均为八进制数字（0-7），则\\nm将匹配八进制转义值nm。   \\nml 如果n为八进制数字（0-3），且m和l均为八进制数字（0-7），则匹配八进制转义值nml。   \\un 匹配n，其中n是一个用四个十六进制数字表示的Unicode字符。例如，\\u00A9匹配版权符号（©）。    常用正则表达式          用户名 /^[a-z0-9_-]{3,16}$/   密码 /^[a-z0-9_-]{6,18}$/   十六进制值 /^#?([a-f0-9]{6}   电子邮箱 /^([a-z0-9_\\.-]+)@([\\da-z\\.-]+)\\.([a-z\\.]{2,6})$/ 或者 /^[a-z\\d]+(\\.[a-z\\d]+)*@([\\da-z](-[\\da-z])?)+(\\.{1,2}[a-z]+)+$/   URL /^(https?:\\/\\/)?([\\da-z\\.-]+)\\.([a-z\\.]{2,6})([\\/\\w \\.-]*)*\\/?$/   IP 地址 /((2[0-4]\\d   HTML 标签 /^\u0026lt;([a-z]+)([^\u0026lt;]+)(?:\u0026gt;(.)\u0026lt;/\\1\u0026gt;   删除代码\\注释 (?\u0026lt;!http:   Unicode编码中的汉字范围 /^[\\u2E80-\\u9FFF]+$/    ","date":"2019-05-23","img":"","permalink":"https://helixs.github.io/posts/2019-05-23-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AC%A6%E5%8F%B7%E8%A1%A8/","series":null,"tags":null,"title":"正则表达式符号表"},{"categories":["Android开发"],"content":" 今天有个需求，web页面有个视频是用标签进行播放的，点击放大按钮进行全屏播放。默认情况下，的确可以实现播放功能，但是放大按钮是无法点击的状态。所以我们要进行一下适配了。\n 注意事项\n    启动硬件加速    重写WebChromeClient-onShowCustomView方法    横竖屏切换的适配情况    Activity destory情况     1、硬件加速 1\u0026lt;activity android:hardwareAccelerated=“true” /\u0026gt; 2、重写onShowCustomView 此方法是通知我们当前的页面将进入全屏模式，也就是我们点击那个小全屏图标的时候，参数当中是一个view，需要将这个view添加到activity中的布局中，我们就直接添加到Webview上，毕竟Webview是个FrameLayout。\n1override fun onShowCustomView(view: View?, callback: CustomViewCallback?) { 2 super.onShowCustomView(view, callback) 3 addView(view) 4 } 实现了上面的方法后，video标签上的全屏按钮就有效果了，点击的时候，会撑满当前的WebView的大小（当然，如果实现全屏的话，那你的webview也要撑满全屏才是哦）。这个简易的全屏方式就实现了。\n我们也可以将这个全屏模式的view添加到别的layout上面，这个可以在webview不是全屏的页面上使用，具体就不介绍了，大家应该都会\n1//如果有特殊的退出全屏时的操作可以实现这个方法。 2override fun onHideCustomView() { 3 super.onHideCustomView() 4} 3、横竖屏的适配操作 如果页面全屏的时候需要有横屏的要求，需要加入兼容性的配置，最后不要让应用进行自动横竖屏，view的哪些东西保存状态是个麻烦，我们手动请求横竖屏，那么就可以躲避横竖屏自动切换所带来的生命周期干扰了。\n1\u0026lt;activity 2 android:name=\u0026#34;.web.WebActivity\u0026#34; 3 android:screenOrientation=\u0026#34;portrait\u0026#34; 4 android:configChanges=\u0026#34;orientation|screenSize|keyboardHidden\u0026#34; /\u0026gt; 当屏幕方向变化的时候会回调Activity的onConfigurationChanged方法，而不会进行生命周期的变化。\n1//当收到onShowCustomView回调的时候执行这个方法 2requestedOrientation = ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE 3// onHideCustomView 执行SCREEN_ORIENTATION_PORTRAIT 4override fun onConfigurationChanged(newConfig: Configuration?) { 5 super.onConfigurationChanged(newConfig) 6 when (newConfig!!.orientation) { 7 //全屏和非全屏切换状态栏高度的适配 8 Configuration.ORIENTATION_LANDSCAPE -\u0026gt; { 9 window.clearFlags(WindowManager.LayoutParams.FLAG_FORCE_NOT_FULLSCREEN) 10 window.addFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN) 11 } 12 Configuration.ORIENTATION_PORTRAIT -\u0026gt; { 13 window.clearFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN) 14 window.addFlags(WindowManager.LayoutParams.FLAG_FORCE_NOT_FULLSCREEN) 15 } 16 } 17 Log.d(\u0026#34;MainActivity\u0026#34;,\u0026#34;onConfigurationChanged\u0026#34;) 18} 基本上我们的全屏功能就完成啦，切换时候的addview和removeView等等需要根据自己的情况实现\n4、webview.destory() 退出的WebActivity的时候记得调用webview.destory()，异步进程可能导致视频还有声音在播放。\n","date":"2019-05-22","img":"","permalink":"https://helixs.github.io/posts/android/2019-05-22-android-webview%E8%A7%86%E9%A2%91%E5%85%A8%E5%B1%8F%E6%92%AD%E6%94%BE%E6%A0%87%E7%AD%BE/","series":null,"tags":null,"title":"Android WebView视频全屏播放"},{"categories":["vps工具"],"content":"基于总所周知的原因，获取开发者资料也很是麻烦，顺便做个记录，怕以后忘记。下面所有的xxxxx 替换为 shdowocks\nlibev的版本呢比较的轻量级，用docker的方式安装最是省心。也怪自己不太会docker的使用，就直接用原生吧，以下都是基于centos7的\n打开它的github，找到centos 添加libev的源。顺便复制一下这个，创建文件librehat-xxxxx-epel-7.repo\n1[librehat-xxxxx] 2name=Copr repo for xxxxxx owned by librehat 3baseurl=https://copr-be.cloud.fedoraproject.org/results/librehat/xxxxx/epel-7-$basearch/ 4type=rpm-md 5skip_if_unavailable=True 6gpgcheck=1 7gpgkey=https://copr-be.cloud.fedoraproject.org/results/librehat/xxxxxx/pubkey.gpg 8repo_gpgcheck=0 9enabled=1 10enabled_metadata=1 放入/etc/yum.repos.d/或者:\n1cd /etc/yum.repos.d/ 2wget https://copr.fedorainfracloud.org/coprs/librehat/xxxxxx/repo/epel-7/librehat-xxxxxx-epel-7.repo 1yum install epel-release -y 2yum install gcc gettext autoconf libtool automake make pcre-devel asciidoc xmlto c-ares-devel libev-devel libsodium-devel mbedtls-devel -y 3yum update 4yum install xxxxxx-libev 如果出现\n1Error: Package: xxxxxxx-libev-3.2.0-2.el7.x86_64 (librehat-xxxxx) 2Requires: libsodium \u0026gt;= 1.0.4 3Error: Package: xxxxxx-libev-3.2.0-2.el7.x86_64 (librehat-xxxxx) 4Requires: mbedtls 好像是udns源没有启用上，部分的vps可能会出现这个情况 解决办法 1yum install http://dl.fedoraproject.org/pub/epel/7/x86_64/Packages/u/udns-0.4-3.el7.x86_64.rpm 2yum install http://dl.fedoraproject.org/pub/epel/7/x86_64/Packages/u/udns-devel-0.4-3.el7.x86_64.rpm 或者\n1yum install epel-release yum-utils -y 2yum-config-manager --enable epel 3yum install udns-devel -y 成功后再执行安装操作:\n1vi /etc/xxxxxx-libev/config.json 1{ 2 \u0026#34;server\u0026#34;:\u0026#34;0.0.0.0\u0026#34;, 3 \u0026#34;server_port\u0026#34;:8888, 4 \u0026#34;local_port\u0026#34;:1080, 5 \u0026#34;password\u0026#34;:\u0026#34;xxxxxxxxxxx\u0026#34;, 6 \u0026#34;timeout\u0026#34;:60, 7 \u0026#34;method\u0026#34;:\u0026#34;aes-256-gcm\u0026#34; 8} 9 0.0.0.0 表示任意ip可以访问 也可以使用指定的ip地址 aes-256-gcm 推荐使用gcm和chacha\n1systemctl enable xxxxxx-libev 2systemctl start xxxxx-libev 3systemctl status xxxxxx-libev  ","date":"2019-05-17","img":"","permalink":"https://helixs.github.io/posts/linux/2019-05-17-centos7%E5%AE%89%E8%A3%85shadows-libev/","series":null,"tags":null,"title":"Centos7安装sha*dow***s-Libev"},{"categories":["未分类"],"content":"在介绍这个方便的轮子之前，我们先一起来回顾一下实现沉浸式状态栏的一般套路。\n 在Android上，关于对StatusBar（状态栏）的操作，一直都在不断改善，并且表现越来越好，在Android4.4 以下，我们可以对StatusBar和 NavigationBar进行显示和隐藏操作。但是直到Android4.4,我们才能真正意义上的实现沉浸式状态栏。从Android4.4 到现在（Android 7.1），关于沉浸式大概可以分成三个阶段：\n  Android4.4（API 19） – Android 5.0（API 21）： 这个阶段可以实现沉浸式，但是表现得还不是很好，实现方式为: 通过FLAG_TRANSLUCENT_STATUS设置状态栏为透明并且为全屏模式，然后通过添加一个与StatusBar 一样大小的View，将View 的 background 设置为我们想要的颜色，从而来实现沉浸式。 Android 5.0（API 21) 以上版本： 在Android 5.0的时候，加入了一个重要的属性和方法 android:statusBarColor （对应方法为 setStatusBarColor），通过这个方法我们就可以轻松实现沉浸式。也就是说，从Android5.0开始，系统才真正的支持沉浸式。 Android 6.0（API 23) 以上版本：其实Android6.0以上的实现方式和Android 5.0 +是一样，为什么要将它归为一个单独重要的阶段呢？是因为从Android 6.0（API 23）开始，我们可以改状态栏的绘制模式，可以显示白色或浅黑色的内容和图标（除了魅族手机，魅族自家有做源码更改，6.0以下就能实现）    大概就是这个三个阶段，那么接下来我们就看一下这个三个阶段分别是如何来实现的。\n Android4.4（API 19） – Android 5.0（API 21）实现沉浸式的方式 Android 4.4 为什么能够实现沉浸式的效果呢？因为在Android 4.4 新增了一个重要的属性：FLAG_TRANSLUCENT_STATUS\n1 /** 2* Window flag: request a translucent status bar with minimal system-provided 3* background protection. 4* 5* \u0026lt;p\u0026gt;This flag can be controlled in your theme through the 6* {@link android.R.attr#windowTranslucentStatus} attribute; this attribute 7* is automatically set for you in the standard translucent decor themes 8* such as 9* {@link android.R.style#Theme_Holo_NoActionBar_TranslucentDecor}, 10* {@link android.R.style#Theme_Holo_Light_NoActionBar_TranslucentDecor}, 11* {@link android.R.style#Theme_DeviceDefault_NoActionBar_TranslucentDecor}, and 12* {@link android.R.style#Theme_DeviceDefault_Light_NoActionBar_TranslucentDecor}.\u0026lt;/p\u0026gt; 13* 14* \u0026lt;p\u0026gt;When this flag is enabled for a window, it automatically sets 15* the system UI visibility flags {@link View#SYSTEM_UI_FLAG_LAYOUT_STABLE} and 16* {@link View#SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN}.\u0026lt;/p\u0026gt; 17*/ 18 public static final int FLAG_TRANSLUCENT_STATUS = 0x04000000; 设置状态栏透明，并且变为全屏模式。上面的解释已经说得很清楚了，当window的这个属性有效的时候，会自动设置 system ui visibility的标志SYSTEM_UI_FLAG_LAYOUT_STABLE和SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN 。\n有两种方式实现这个属性：  代码中  1activity.getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);  当然也可以在theme 中设置属性windowTranslucentStatus,如下：  1android:windowTranslucentStatus 沉浸式的效果是出来了，但是也有一个问题，我们的标题栏和状态栏重叠了，相当于整个布局上移了StatusBar 的高度。\n小结：Android4.4上实现沉浸式状态栏的套路是：为window添加FLAG_TRANSLUCENT_STATUS Flag,然后添加一个和status bar 一样大小的View 站位，从而让让标题栏不会与status bar 重叠。而图片延伸到状态栏只需要设置FLAG_TRANSLUCENT_STATUS就OK。 前面说过，沉浸式在Android4.4 – Android5.0 之间的版本表现得不是很好，从上面贴的几张图就可以看出，状态栏的顶部有一个渐变，会显示出黑色的阴影（底部的导航栏也是一样的效果），在Android 5.0 版本已经被修复了。\nAndroid 5.0（API 21）以上实现沉浸式的方式 Android 5.0 是一个里程碑式的版本，从Android 5.0开始，Google 推出了全新的设计规范 Material Design,并且原生控件就可以实现一些炫酷的UI动效。从这个版本开始，google 加入了一个比较重要的方法setStatusBarColor (对应属性：android:statusBarColor),通过这个方法，可以很轻松地实现沉浸式状态栏。方法如下：\n1 /** 2* Sets the color of the status bar to {@code color}. 3* 4* For this to take effect, 5* the window must be drawing the system bar backgrounds with 6* {@link android.view.WindowManager.LayoutParams#FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS} and 7* {@link android.view.WindowManager.LayoutParams#FLAG_TRANSLUCENT_STATUS} must not be set. 8* 9* If {@code color} is not opaque, consider setting 10* {@link android.view.View#SYSTEM_UI_FLAG_LAYOUT_STABLE} and 11* {@link android.view.View#SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN}. 12* \u0026lt;p\u0026gt; 13* The transitionName for the view background will be \u0026#34;android:status:background\u0026#34;. 14* \u0026lt;/p\u0026gt; 15*/ 16 public abstract void setStatusBarColor(@ColorInt int color); 注意看这个方法的注释，想要这个方法生效，必须还要配合一个Flag一起使用，必须设置FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS ,并且不能设置FLAG_TRANSLUCENT_STATUS(Android 4.4才用这个)\n设置了FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS,表明会Window负责系统bar的background 绘制，绘制透明背景的系统bar（状态栏和导航栏），然后用getStatusBarColor()和getNavigationBarColor()的颜色填充相应的区域。这就是Android 5.0 以上实现沉浸式导航栏的原理。 实现沉浸式添加如下代码：\n1getWindow().addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS); 2//注意要清除 FLAG_TRANSLUCENT_STATUS flag 3getWindow().clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS); 4getWindow().setStatusBarColor(getResources().getColor(android.R.color.holo_red_light)); 图片延伸到状态栏 在Android 5.0 使图片延伸到状态栏，只需设置windowTranslucentStatus,将 statusBarColor 设置为透明即可：\n1\u0026lt;style name=\u0026#34;ImageTranslucentTheme\u0026#34; parent=\u0026#34;Theme.AppCompat.DayNight.NoActionBar\u0026#34;\u0026gt; 2 \u0026lt;item name=\u0026#34;android:windowTranslucentNavigation\u0026#34;\u0026gt;true\u0026lt;/item\u0026gt; 3 \u0026lt;item name=\u0026#34;android:windowTranslucentStatus\u0026#34;\u0026gt;true\u0026lt;/item\u0026gt; 4 \u0026lt;!-- 设置statusBarColor 为透明--\u0026gt; 5 \u0026lt;item name=\u0026#34;android:statusBarColor\u0026#34;\u0026gt;@android:color/transparent\u0026lt;/item\u0026gt; 6\u0026lt;/style\u0026gt; 1activity.getWindow().addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS); 2activity.getWindow().clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS); 3activity.getWindow().setStatusBarColor(calculateStatusColor(color, statusBarAlpha)); Android 6.0 + 实现状态栏字色和图标浅黑色 使用沉浸式的时候会遇到一个问题，那就是Android 系统状态栏的字色和图标颜色为白色，当我的主题色或者图片接近白色或者为浅色的时候，状态栏上的内容就看不清了。 ，这个问题在Android 6.0的时候得到了解决。Android 6.0 新添加了一个属性SYSTEM_UI_FLAG_LIGHT_STATUS_BAR\n 为setSystemUiVisibility(int)方法添加的Flag,请求status bar 绘制模式，它可以兼容亮色背景的status bar 。要在设置了FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS ,同时清除了FLAG_TRANSLUCENT_STATUS 才会生效\n 1if (Build.VERSION.SDK_INT \u0026gt;= Build.VERSION_CODES.M) { 2//不然会出现灰色状态栏 3getWindow().clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS); 4getWindow().getDecorView().setSystemUiVisibility( 5 View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN|View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR); 6} ","date":"2019-03-27","img":"","permalink":"https://helixs.github.io/posts/android/2019-03-27-android%E6%B2%89%E6%B5%B8%E7%8A%B6%E6%80%81%E6%A0%8F/","series":null,"tags":null,"title":"Android沉浸状态栏"},{"categories":["Android开发"],"content":"什么是Fastboot，ADB？  Fastboot：在百度百科中，可以看到这样的解释：在安卓手机中fastboot是一种比recovery更底层的刷机模式，fastboot是一种线刷，就是使用USB数据线连接手机的一种刷机模式。相对于某些系卡刷来说，线刷更可靠，安全。在PC端使用fastboot需要相应的fastboot工具，我们平常使用工具箱刷写Recovery镜像，实际上即是通过fastboot这个工具来调用实现。\n  ADB：ADB的全称为Android Debug Bridge，即调试桥，方便调试设备或调试开发的Android APP。\n 怎样启动Fastboot和ADB？  1.将adb工具包解压到合适的地方，本文以将其解压到D:\\adb为例进行展示 2.启动命令提示符 3.可通过运行cmd启动或在Windows徽标处右键，选择命令提示符启动 4.定位到工具包所在目录，依次输入：  1D: 2cd adb 3#以此切换到D:/adb工作目录，此时可通过输入 4adb version 5#根据提示信息确定是否可正常使用，如图即为正常的情况。 我可以用ADB和Fastboot干什么，怎么做？ 在做任何事情之前，我们都需要连接手机到电脑端，并开启USB调试模式，通过命令查看是否连接正常。 如果处在开机状态或recovery下，命令为：\n1adb devices Fastboot下，命令为\n1fastboot devices 根据返回信息确认是否连接正常，若返回信息左侧显示为一序列号，右侧显示device或recovery或sideload或fastboot均为正常情况，分别代表此时设备所处的状态\nADB工具 最常用的，我们可以通过ADB，我们可以进行通过USB端进行ROM刷机包刷机操作。 将手机进入Recovery模式，可看到，由于一加三由于出厂Android版本为6.0，为遵循Google新的安全规范，已经对data分区进行了加密，在官方Recovery下已经看不到曾经熟悉的从内置存储中升级的选项，这时候就可以选择从USB端进行升级选项，借助强大的ADB完成系统升级。具体命令为：\n1adb sideload \u0026lt;file_location\u0026gt; 其中，\u0026lt;file_location\u0026gt;应为刷机包所在位置，如果较为复杂，可以讨巧地选择拖拽方式，利用鼠标拖拽将外部ZIP包拖拽入窗口中,回车即可等待ADB自动完成刷机包推送和更新操作。\n此外，我们还可以用ADB工具进行安装APK，推送文件到系统等等。在此只提供相关命令\n   名称 解释     卸载软件 adb install \u0026lt;apk文件路径\u0026gt;（可拖拽）   安装apk adb uninstall \u0026lt;软件包名\u0026gt;）   从电脑上发送文件到设备 adb push \u0026lt;本地路径\u0026gt; \u0026lt;远程路径\u0026gt;）   从设备上下载文件到电脑 adb pull \u0026lt;远程路径\u0026gt; \u0026lt;本地路径\u0026gt;）   重启到recovery adb reboot recovery   重启到fastboot adb reboot bootloader   重启手机至系统 adb reboot    Fastboot工具 Fastboot工具与ADB工具使用方法相同，只是相关实现命令与作用不同，总的来说，fastboot具有 为设备解锁，刷写img刷机包，格式化系统分区，启动（运行）img文件（通常用于不刷写测试recovery）等功能，相关命令如下：\n   名称 命令 解释     进行设备的解锁 fastboot oem unlock 解锁将擦除所有数据，包括音乐，视频，图片等，请先做好备份！！   进行设备的重上锁 fastboot oem lock    刷写IMG刷机包 fastboot flash \u0026lt;分区名\u0026gt; \u0026lt;IMG路径\u0026gt; 例如，刷写recovery时，输入的命令为fastboot flash recovery \u0026lt;recovery的img文件路径\u0026gt;（可拖拽入窗口）注：主要的分区有 recovery（恢复模式） system（系统分区） boot（引导分区，存放内核和ramdisk） data（数据分区） cache（缓存分区）等   格式化（清除）分区 fastboot erase \u0026lt;分区名\u0026gt;    启动IMG镜像 fastboot boot \u0026lt;IMG路径\u0026gt;（可拖拽入窗口） 可用于测试我们下载的recovery是否可用或效果如何而不直接将其刷入手机   启动到系统 fastboot reboot     刷一个第三方recovery 1adb devices 2adb reboot bootloader 3fastboot flash recovery [此处拖入下载的img文件] 4fastboot boot [此处拖入下载的img文件] ","date":"2019-03-19","img":"","permalink":"https://helixs.github.io/posts/android/2019-03-19-adb_fastboot%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","series":null,"tags":null,"title":"Adb_fastboot常用命令"},{"categories":["未分类"],"content":"今天在代码中设置button的minheight，发现没有效果。结果发现代码中设置minHeight实际上对应的是text的绘制最小区域，要使用minimumHeight\n1minWidth = ConvertUtils.dp2px(50f) 2minimumWidth = ConvertUtils.dp2px(50f) 3minHeight=0 4minimumHeight=0 ","date":"2019-03-11","img":"","permalink":"https://helixs.github.io/posts/android/2019-03-11-androidbutton%E8%AE%BE%E7%BD%AEminheight%E5%92%8Cminwidth%E6%97%A0%E6%95%88%E7%9A%84%E9%97%AE%E9%A2%98/","series":null,"tags":null,"title":"AndroidButton设置minHeight和minWidth无效的问题"},{"categories":["未分类"],"content":"1public class SquareCardView extends CardView { 2 3 private Configuration mConfig; 4 5 public SquareCardView(@NonNull Context context) { 6 this(context, null, 0); 7 } 8 9 public SquareCardView(@NonNull Context context, @Nullable AttributeSet attrs) { 10 this(context, attrs, 0); 11 } 12 13 public SquareCardView(@NonNull Context context, @Nullable AttributeSet attrs, int defStyleAttr) { 14 super(context, attrs, defStyleAttr); 15 this.mConfig = getResources().getConfiguration(); 16 } 17 18 @Override 19 protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { 20 int orientation = mConfig.orientation; 21 switch (orientation) { 22 case Configuration.ORIENTATION_PORTRAIT: { 23 super.onMeasure(widthMeasureSpec, widthMeasureSpec); 24 break; 25 } 26 case Configuration.ORIENTATION_LANDSCAPE: { 27 super.onMeasure(heightMeasureSpec, heightMeasureSpec); 28 break; 29 } 30 default: { 31 throw new AssertionError(\u0026#34;This should not be the case.\u0026#34;); 32 } 33 } 34 } 35} ","date":"2019-03-06","img":"","permalink":"https://helixs.github.io/posts/android/2019-03-06-%E5%AE%9E%E7%8E%B0%E5%9C%A8gridlayoutmanager%E4%B8%AD%E5%AE%BD%E9%AB%98%E4%B8%80%E8%87%B4%E7%9A%84item/","series":null,"tags":null,"title":"实现在gridLayoutManager中宽高一致的item"},{"categories":["linux常用配置"],"content":"卸载阿里云盾监控： 1wget http://update.aegis.aliyun.com/download/uninstall.sh 2chmod +x uninstall.sh 3sudo ./uninstall.sh 4wget http://update.aegis.aliyun.com/download/quartz_uninstall.sh 5chmod +x quartz_uninstall.sh 6sudo ./quartz_uninstall.sh 删除残留： 1sudo pkill aliyun-service 2sudo rm -fr /etc/init.d/agentwatch /usr/sbin/aliyun-service 3sudo rm -rf /usr/local/aegis* 屏蔽云盾 IP，用包过滤屏蔽如下IP： 1iptables -I INPUT -s 140.205.201.0/28 -j DROP 2iptables -I INPUT -s 140.205.201.16/29 -j DROP 3iptables -I INPUT -s 140.205.201.32/28 -j DROP 4iptables -I INPUT -s 140.205.225.192/29 -j DROP 5iptables -I INPUT -s 140.205.225.200/30 -j DROP 6iptables -I INPUT -s 140.205.225.184/29 -j DROP 7iptables -I INPUT -s 140.205.225.183/32 -j DROP 8iptables -I INPUT -s 140.205.225.206/32 -j DROP 9iptables -I INPUT -s 140.205.225.205/32 -j DROP 卸载云监控Java版本插件： 1sudo /usr/local/cloudmonitor/wrapper/bin/cloudmonitor.sh stop 2sudo /usr/local/cloudmonitor/wrapper/bin/cloudmonitor.sh remove 3sudo rm -rf /usr/local/cloudmonitor ","date":"2019-03-06","img":"","permalink":"https://helixs.github.io/posts/linux/2019-03-06-%E5%8D%B8%E8%BD%BD%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%91%E6%8E%A7%E6%9C%8D%E5%8A%A1/","series":null,"tags":null,"title":"卸载阿里云监控服务"},{"categories":["Android开发"],"content":"我们从屏幕截图或者从imageView中获得bitmap大多都是从以下代码获取\n1imageView.isDrawingCacheEnabled = true 2imageView.buildDrawingCache() 3val bitmap=Bitmap.createBitmap(imageView.drawingCache, xxxxx,xxx,xxx） 4imageView.destroyDrawingCache() 但是这些方法在api28的时候都过期了，虽然可以用不过在api26之后google放了个PixelCopy这个类，他是直接从指定的window上获取surface对象在通过native方法获取的。\n1fun getBitmapFromView(view: View, activity: Activity, callback: (Bitmap) -\u0026gt; Unit) { 2 activity.window?.let { window -\u0026gt; 3 val bitmap = Bitmap.createBitmap(view.width, view.height, Bitmap.Config.ARGB_8888) 4 val locationOfViewInWindow = IntArray(2) 5 view.getLocationInWindow(locationOfViewInWindow) 6 try { 7 PixelCopy.request(window, Rect(locationOfViewInWindow[0], locationOfViewInWindow[1], locationOfViewInWindow[0] + view.width, locationOfViewInWindow[1] + view.height), bitmap, { copyResult -\u0026gt; 8 if (copyResult == PixelCopy.SUCCESS) { 9 callback(bitmap) 10 } 11 // possible to handle other result codes ... 12 }, Handler(Looper.getMainLooper())) 13 } catch (e: IllegalArgumentException) { 14 // PixelCopy may throw IllegalArgumentException, make sure to handle it 15 e.printStackTrace() 16 } 17 } 18}  Window source:提供一个copy源，这里的源表示window，表示从哪个window。 Rect srcRect：提供一个范围 Bitmap dest：表示将从window中拷贝出来的图像写如到目标位图对象中。 OnPixelCopyFinishedListener listener ：这是一个回调，当拷贝结束后会调用此方法。 Handler listenerThread:该参数表示指定上面的回调在哪个线程中执行。 翻译   注意的就是Bitmap.Config这个参数要选择是ARGB_8888不然会返回PixelCopy.ERROR_UNKNOWN，可能必须要把32位色值写满才行吧。\n还有它不是直接在view上获取，而是在window上，所以要确定要位置，不然获取的地方不单单是你绘制的那个区域了，所以我们要把控好位置和距离，这个是缺点如果图像层叠的话那就没办法了，盖住的部分肯定无法获取，这是缺点。不过也带来了优点，如果像获取某个区域块的图像，更是一种好方法。 如果不行那就还是用老的方法吧。\n","date":"2019-02-28","img":"","permalink":"https://helixs.github.io/posts/android/2019-02-28-android%E4%BB%8Eview%E4%B8%AD%E8%8E%B7%E5%8F%96bitmap/","series":null,"tags":null,"title":"Android从view中获取bitmap"},{"categories":["未分类"],"content":"Android图像处理——Paint之Xfermode https://blog.csdn.net/allen315410/article/details/45077165 ","date":"2019-02-26","img":"","permalink":"https://helixs.github.io/posts/2019-02-26-paint-xfermode-/","series":null,"tags":null,"title":"自定义View绘制等相关介绍地址"},{"categories":["Android开发"],"content":"[转载]https://juejin.im/entry/59b6419d5188257e82675716 1.Bitmap类  Bitmap图像处理的最重要类之一。用它可以获取图像文件信息，进行图像颜色变换、剪切、旋转、缩放等操作，并可以指定格式保存图像文件\n 1.1 Bitmap常用的方法 1.2 Bitmap的颜色配置信息与压缩方式信息  Bitmap中有两个内部枚举类：Config和CompressFormat，\nConfig是用来设置颜色配置信息的，\nCompressFormat是用来设置压缩方式的。\n Config解析：\n  Bitmap.Config.ALPHA_8：颜色信息只由透明度组成，占8位。\n  Bitmap.Config.ARGB_4444：颜色信息由透明度与R（Red），G（Green），B（Blue）四部分组成，每个部分都占4位，总共占16位。\n  Bitmap.Config.ARGB_8888：颜色信息由透明度与R（Red），G（Green），B（Blue）四部分组成，每个部分都占8位，总共占32位。是Bitmap默认的颜色配置信息，也是最占空间的一种配置。\n  Bitmap.Config.RGB_565：颜色信息由R（Red），G（Green），B（Blue）三部分组成，R占5位，G占6位，B占5位，总共占16位。\n   通常我们优化Bitmap时，当需要做性能优化或者防止OOM（Out Of Memory），我们通常会使用Bitmap.Config.RGB_565这个配置，因为Bitmap.Config.ALPHA_8只有透明度，显示一般图片没有意义，Bitmap.Config.ARGB_4444显示图片不清楚，Bitmap.Config.ARGB_8888占用内存最多。\n CompressFormat解析：\n Bitmap.CompressFormat.JPEG：表示以JPEG压缩算法进行图像压缩，压缩后的格式可以是”.jpg”或者”.jpeg”，是一种有损压缩。 Bitmap.CompressFormat.PNG：表示以PNG压缩算法进行图像压缩，压缩后的格式可以是”.png”，是一种无损压缩。 Bitmap.CompressFormat.WEBP：表示以WebP压缩算法进行图像压缩，压缩后的格式可以是”.webp”，是一种有损压缩，质量相同的情况下，WebP格式图像的体积要比JPEG格式图像小40%。美中不足的是，WebP格式图像的编码时间“比JPEG格式图像长8倍”。  1.3 Bitmap对图像进行操作 1）Bitmap裁剪图像\n1Bitmap.createBitmap(Bitmap source, int x, int y, int width, int height) 根据源Bitmap对象source，创建出source对象裁剪后的图像的Bitmap。x,y分别代表裁剪时，x轴和y轴的第一个像素，width，height分别表示裁剪后的图像的宽度和高度。 注意：x+width要小于等于source的宽度，y+height要小于等于source的高度。\n1Bitmap.createBitmap(Bitmap source, int x, int y, int width, int height,Matrix m, boolean filter) 这个方法只比上面的方法多了m和filter这两个参数，m是一个Matrix（矩阵）对象，可以进行缩放，旋转，移动等动作，filter为true时表示source会被过滤，仅仅当m操作不仅包含移动操作，还包含别的操作时才适用。其实上面的方法本质上就是调用这个方法而已。\n1public static Bitmap createBitmap(Bitmap source, int x, int y, int width, int height) { 2 return createBitmap(source, x, y, width, height, null, false); 3} 2 ）Bitmap缩放，旋转，移动图像\nBitmap缩放，旋转，移动，倾斜图像其实就是通过Bitmap.createBitmap(Bitmap source, int x, int y, int width, int height,Matrix m, boolean filter)方法实现的，只是在实现这些功能的同时还可以实现图像的裁剪。\n1// 定义矩阵对象 2Matrix matrix = new Matrix(); 3// 缩放图像 4matrix.postScale(0.8f, 0.9f); 5// 向左旋转（逆时针旋转）45度，参数为正则向右旋转（顺时针旋转） 6matrix.postRotate(-45); 7//移动图像 8//matrix.postTranslate(100,80); 9Bitmap bitmap = Bitmap.createBitmap(source, 0, 0, source.getWidth(), source.getHeight(), 10 matrix, true); Matrix的postScale和postRotate方法还有多带两个参数的重载方法postScale(float sx, float sy, float px, float py)和postRotate(float degrees, float px, float py)，后两个参数px和py都表示以该点为中心进行操作。\n注意：虽然Matrix还可以调用postSkew方法进行倾斜操作，但是却不可以在此时创建Bitmap时使用。\n3）Bitmap保存图像与释放资源\n1bitmap=BitmapFactory.decodeResource(getResources(),R.drawable.feng); 2File file=new File(getFilesDir(),\u0026#34;lavor.jpg\u0026#34;); 3if(file.exists()){ 4 file.delete(); 5} 6try { 7 FileOutputStream outputStream=new FileOutputStream(file); 8 bitmap.compress(Bitmap.CompressFormat.JPEG,90,outputStream); 9 outputStream.flush(); 10 outputStream.close(); 11} catch (FileNotFoundException e) { 12 e.printStackTrace(); 13} catch (IOException e) { 14 e.printStackTrace(); 15} 16bitmap.recycle();//释放bitmap的资源，这是一个不可逆转的操作 3）Matrix拓展类\n   方法 介绍     setRotate(float degrees, float px, float py) 对图片进行旋转   setScale(float sx, float sy) 对图片进行缩放   setTranslate(float dx, float dy) 对图片进行平移   postTranslate(centerX, centerY) 在上一次修改的基础上进行再次修改 set 每次操作都是最新的 会覆盖上次的操作    1//显示原图 2ImageView iv_src = (ImageView) findViewById(R.id.iv_src); 3 4//显示副本 5ImageView iv_copy = (ImageView) findViewById(R.id.iv_copy); 6 7//[1]先把tomcat.png 图片转换成bitmap 显示到iv_src 8Bitmap srcBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.tomcat); 9 10//[1.1]操作图片 11// srcBitmap.setPixel(20, 30, Color.RED); 12iv_src.setImageBitmap(srcBitmap); 13 14//[2]创建原图的副本 15 16//[2.1]创建一个模板 相当于 创建了一个大小和原图一样的 空白的白纸 17Bitmap copybiBitmap = Bitmap.createBitmap(srcBitmap.getWidth(), srcBitmap.getHeight(), srcBitmap.getConfig()); 18//[2.2]想作画需要一个画笔 19Paint paint = new Paint(); 20//[2.3]创建一个画布 把白纸铺到画布上 21Canvas canvas = new Canvas(copybiBitmap); 22//[2.4]开始作画 23Matrix matrix = new Matrix(); 24 25//[2.5]对图片进行旋转 26//matrix.setRotate(20, srcBitmap.getWidth()/2, srcBitmap.getHeight()/2); 27 28//[2.5]对图片进行 29// matrix.setScale(0.5f, 0.5f); 30 31//[2.6]对图片进行平移 32// matrix.setTranslate(30, 0); 33 34 35//[2.7]镜面效果 如果2个方法一起用 36// matrix.setScale(-1.0f, 1); 37//post是在上一次修改的基础上进行再次修改 set 每次操作都是最新的 会覆盖上次的操作 38// matrix.postTranslate(srcBitmap.getWidth(), 0); 39 40 41 42//[2,7]倒影效果 43matrix.setScale(1.0f, -1); 44//post是在上一次修改的基础上进行再次修改 set 每次操作都是最新的 会覆盖上次的操作 45matrix.postTranslate(0, srcBitmap.getHeight()); 46canvas.drawBitmap(srcBitmap,matrix , paint); 47 48 49 50//[3]把copybimap显示到iv_copy上 51iv_copy.setImageBitmap(copybiBitmap); 2.BitmapFactory类  创建位图对象从不同的来源,包括文件、流, 和字节数组。\n 2.1BitmapFactory常用方法    方法 说明     decodeFile(String pathName, Options opts) 从文件读取图片   decodeFile(String pathName) 从文件读取图片   decodeFileDescriptor(FileDescriptor fd) 从文件读取文件 与decodeFile不同的是这个直接调用JNI函数进行读取 效率比较高   decodeFileDescriptor(FileDescriptor fd, Rect outPadding, Options opts) 同上   decodeStream(InputStream is) 从输入流读取图片   decodeStream(InputStream is, Rect outPadding, Options opts) 从输入流读取图片   decodeStream(InputStream is, Rect outPadding, Options opts) 从资源文件读取图片   decodeResource(Resources res, int id) 从资源文件读取图片   decodeResource(Resources res, int id, Options opts) 从资源文件读取图片   decodeByteArray(byte[] data, int offset, int length) 从数组读取图片   decodeByteArray(byte[] data, int offset, int length, Options opts) 从数组读取图片     BitmapFactory.decodeResource 加载的图片可能会经过缩放，该缩放目前是放在 java 层做的，效率比较低，而且需要消耗 java 层的内存。因此，如果大量使用该接口加载图片，容易导致OOM错误\nBitmapFactory.decodeStream 不会对所加载的图片进行缩放，相比之下占用内存少，效率更高。\n这两个接口各有用处，如果对性能要求较高，则应该使用 decodeStream；如果对性能要求不高，且需要 Android 自带的图片自适应缩放功能，则可以使用 decodeResource。\n 2.2 BitmapFactory三种加载图片   1）从资源文件读取图片\n1Bitmap bitmap= BitmapFactory.decodeResource(getResources(),R.drawable.after19); 2iv.setImageBitmap(bitmap);   2）从输入流中读取图片\n1FileInputStream fis=new FileInputStream(new File(getFilesDir()+\u0026#34;/psb.jpg\u0026#34;)); 2 Bitmap bitmap= BitmapFactory.decodeStream(fis); 3 iv.setImageBitmap(bitmap);   3）从数组中读取图片\n1public static Bitmap readBitmapFromByteArray(byte[] data, int width, int height) { 2 BitmapFactory.Options options = new BitmapFactory.Options(); 3 options.inJustDecodeBounds = true; 4 BitmapFactory.decodeByteArray(data, 0, data.length, options); 5 float srcWidth = options.outWidth; 6 float srcHeight = options.outHeight; 7 int inSampleSize = 1; 8 9 if (srcHeight \u0026gt; height || srcWidth \u0026gt; width) { 10 if (srcWidth \u0026gt; srcHeight) { 11 inSampleSize = Math.round(srcHeight / height); 12 } else { 13 inSampleSize = Math.round(srcWidth / width); 14 } 15 } 16 17 options.inJustDecodeBounds = false; 18 options.inSampleSize = inSampleSize; 19 20 return BitmapFactory.decodeByteArray(data, 0, data.length, options); 21}   2.3 BitmapFactory常用操作   1）保存本地图片\n1public static void writeBitmapToFile(String filePath, Bitmap b, int quality) { 2 try { 3 File desFile = new File(filePath); 4 FileOutputStream fos = new FileOutputStream(desFile); 5 BufferedOutputStream bos = new BufferedOutputStream(fos); 6 b.compress(Bitmap.CompressFormat.JPEG, quality, bos); 7 bos.flush(); 8 bos.close(); 9 } catch (IOException e) { 10 e.printStackTrace(); 11 } 12}   2）图片缩放\n1public static Bitmap bitmapScale(Bitmap bitmap, float scale) { 2 Matrix matrix = new Matrix(); 3 matrix.postScale(scale, scale); // 长和宽放大缩小的比例 4 Bitmap resizeBmp = Bitmap.createBitmap(bitmap, 0, 0, bitmap.getWidth(), bitmap.getHeight(), matrix, true); 5 return resizeBmp; 6 }   3）对 bitmap 进行裁剪\n1public Bitmap bitmapClip(Context context , int id , int x , int y){ 2 Bitmap map = BitmapFactory.decodeResource(context.getResources(), id); 3 map = Bitmap.createBitmap(map, x, y, 120, 120); 4 return map; 5}   3. BitmapFactory.option常用方法    Option参数类方法 说明     public boolean inJustDecodeBounds 如果设置为true，不获取图片，不分配内存，但会返回图片的高度宽度信息   public int inSampleSize 图片缩放的倍数   public int outWidth 获取图片的宽度值   public int outHeight 获取图片的高度值   public int inDensity 用于位图的像素压缩比   public int inTargetDensity 用于目标位图的像素压缩比（要生成的位图）   public byte[] inTempStorage 创建临时文件，将图片存储   public boolean inScaled 设置为true时进行图片压缩，从inDensity到inTargetDensity   public boolean inDither 如果为true,解码器尝试抖动解码   public Bitmap.Config inPreferredConfig 设置解码器这个值是设置色彩模式，默认值是ARGB_8888，在这个模式下，一个像素点占用4bytes空间，一般对透明度不做要求的话，一般采用RGB_565模式，这个模式下一个像素点占用2bytes   public String outMimeType 设置解码图像   public boolean inPurgeable 当存储Pixel的内存空间在系统内存不足时是否可以被回收   public boolean inInputShareable inPurgeable为true情况下才生效，是否可以共享一个InputStream   public boolean inPreferQualityOverSpeed 为true则优先保证Bitmap质量其次是解码速度   public boolean inMutable 配置Bitmap是否可以更改，比如：在Bitmap上隔几个像素加一条线段   public int inScreenDensity 当前屏幕的像素密度    https://www.jianshu.com/p/384a70897ba6 https://www.jianshu.com/p/98c88f9ceafa 4. Bitmap 的基本使用 1private fun calImage(path: String) { 2 val degree = readPictureDegree(path) 3 var bitmap = getBitmapOfInSampleSize(path, width, height) 4 if (degree!=0){ 5 bitmap= rotateBitmap(bitmap, degree) 6 } 7 imageView.setImageBitmap(bitmap) 8} 9 10 companion object { 11 12 /** 13* 根据缩放比例获取bitmap 来防止oom 14*/ 15 private fun getBitmapOfInSampleSize(path: String, reqWidth: Int, reqHeight: Int): Bitmap { 16 val options = BitmapFactory.Options() 17 //获取图片的信息，并不会将图片加到内存中 18 options.inJustDecodeBounds = true 19 options.inPreferredConfig = Bitmap.Config.RGB_565 20 BitmapFactory.decodeFile(path, options) 21 options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight) 22 //将bitmap放入内存中 23 options.inJustDecodeBounds = false 24 return BitmapFactory.decodeFile(path, options) 25 } 26 27 /** 28* 计算inSampleSize也就是压缩比率 29* inSampleSize比1小的话会被当做1，任何inSampleSize的值会被取接近2的幂值。 30* @param reqHeight 需要展示的图片的最大高度 31* @param reqWidth 需要展示的图片最大宽度 32*/ 33 private fun calculateInSampleSize(options: BitmapFactory.Options, reqWidth: Int, 34 reqHeight: Int): Int { 35 //获取图片的真实宽高 36 val optionsWidth = options.outWidth 37 val optionsHeight = options.outHeight 38 var inSampleSize = 1 39 if (optionsHeight \u0026gt; reqHeight || optionsWidth \u0026gt; reqWidth) { 40 41 val halfHeight = optionsHeight / 2 42 val halfWidth = optionsWidth / 2 43 // 宽和高比需要的宽高大的前提下最大的inSampleSize 44 while ((halfHeight / inSampleSize) \u0026gt;= reqHeight 45 \u0026amp;\u0026amp; (halfWidth / inSampleSize) \u0026gt;= reqWidth) { 46 inSampleSize *= 2 47 } 48 } 49 return inSampleSize 50 } 51 52 /** 53* 获取照片角度 54* 55* @param path 56* @return 57*/ 58 fun readPictureDegree(path: String): Int { 59 var degree = 0 60 try { 61 val exifInterface = ExifInterface(path) 62 val orientation = exifInterface.getAttributeInt( 63 ExifInterface.TAG_ORIENTATION, 64 ExifInterface.ORIENTATION_NORMAL) 65 when (orientation) { 66 ExifInterface.ORIENTATION_ROTATE_90 -\u0026gt; degree = 90 67 ExifInterface.ORIENTATION_ROTATE_180 -\u0026gt; degree = 180 68 ExifInterface.ORIENTATION_ROTATE_270 -\u0026gt; degree = 270 69 } 70 } catch (e: IOException) { 71 e.printStackTrace() 72 } 73 74 return degree 75 } 76 77 /** 78* 旋转照片 79* 80* @param bitmap 81* @param degress 82* @return 83*/ 84 fun rotateBitmap(bitmapSource: Bitmap, degress: Int): Bitmap { 85 var bitmap = bitmapSource 86 val m = Matrix() 87 m.postRotate(degress.toFloat()) 88 bitmap = Bitmap.createBitmap(bitmap, 0, 0, bitmap.width, 89 bitmap.height, m, true) 90 return bitmap 91 } 92} ","date":"2019-02-26","img":"","permalink":"https://helixs.github.io/posts/android/2019-02-26-android-bitmap%E6%9C%80%E5%85%A8%E9%9D%A2%E8%AF%A6%E8%A7%A3/","series":null,"tags":null,"title":"Android Bitmap最全面详解"},{"categories":["未分类"],"content":"1 2 3package com.ex; 4 5import android.app.Activity; 6import android.content.Context; 7import android.content.res.Resources; 8import android.graphics.Bitmap; 9import android.graphics.Canvas; 10import android.graphics.Color; 11import android.graphics.Matrix; 12import android.graphics.Paint; 13import android.graphics.Point; 14import android.graphics.Rect; 15import android.graphics.drawable.ColorDrawable; 16import android.graphics.drawable.Drawable; 17import android.os.Build; 18import android.util.DisplayMetrics; 19import android.util.Log; 20import android.view.View; 21import android.view.ViewGroup; 22import android.view.Window; 23import android.view.WindowManager; 24import android.widget.ListAdapter; 25import android.widget.ListView; 26 27import java.util.ArrayList; 28import java.util.List; 29 30import androidx.annotation.ColorInt; 31import androidx.collection.LruCache; 32import androidx.recyclerview.widget.RecyclerView; 33 34/** 35* 获取屏幕的宽高度 36* 37* @author BoBoMEe 38*/ 39public class ScreenUtil { 40 41 /** 42* shot the current screen ,with the status but the status is trans * 43* 44* @param ctx current activity 45*/ 46 public static Bitmap shotActivity(Activity ctx) { 47 48 View view = ctx.getWindow().getDecorView(); 49 view.setDrawingCacheEnabled(true); 50 view.buildDrawingCache(); 51 52 Bitmap bp = Bitmap.createBitmap(view.getDrawingCache(), 0, 0, view.getMeasuredWidth(), 53 view.getMeasuredHeight()); 54 55 view.setDrawingCacheEnabled(false); 56 view.destroyDrawingCache(); 57 58 return bp; 59 } 60 61 /** 62* shot the current screen ,with the status and navigationbar* 63*/ 64 public static Bitmap ShotActivity$WithoutStatus$WithoutNavigationBar(Activity ctx) { 65 int statusH = getStatusH(ctx); 66 int navigationBarH = getNavigationBarHeight(ctx); 67 68 View view = ctx.getWindow().getDecorView(); 69 view.setDrawingCacheEnabled(true); 70 view.buildDrawingCache(); 71 72 Bitmap bp = Bitmap.createBitmap(view.getDrawingCache(), 0, statusH, view.getMeasuredWidth(), 73 view.getMeasuredHeight() - statusH - navigationBarH); 74 75 view.setDrawingCacheEnabled(false); 76 view.destroyDrawingCache(); 77 78 return bp; 79 } 80 81 /** 82* 获得屏幕高度 83*/ 84 public static int getScreenWidth(Context context) { 85 WindowManager wm = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE); 86 DisplayMetrics outMetrics = new DisplayMetrics(); 87 wm.getDefaultDisplay().getMetrics(outMetrics); 88 return outMetrics.widthPixels; 89 } 90 91 /** 92* get the height of screen * 93*/ 94 public static int getScreenH(Context ctx) { 95 int h = 0; 96 if (Build.VERSION.SDK_INT \u0026amp;gt; 13) { 97 Point p = new Point(); 98 ((WindowManager) ctx.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay().getSize(p); 99 h = p.y; 100 } else { 101 h = ((WindowManager) ctx.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay() 102 .getHeight(); 103 } 104 return h; 105 } 106 107 /** 108* get the width of screen ** 109*/ 110 public static int getScreenW(Context ctx) { 111 int w = 0; 112 if (Build.VERSION.SDK_INT \u0026amp;gt; 13) { 113 Point p = new Point(); 114 ((WindowManager) ctx.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay().getSize(p); 115 w = p.x; 116 } else { 117 w = ((WindowManager) ctx.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay() 118 .getWidth(); 119 } 120 return w; 121 } 122 123 /** 124* get the height of status * 125*/ 126 public static int getStatusH(Activity ctx) { 127 Rect s = new Rect(); 128 ctx.getWindow().getDecorView().getWindowVisibleDisplayFrame(s); 129 return s.top; 130 } 131 132 /** 133* get the height of status * 134*/ 135 public static int getStatusHeight(Context activity) { 136 int resourceId = activity.getResources().getIdentifier(\u0026#34;status_bar_height\u0026#34;, \u0026#34;dimen\u0026#34;, \u0026#34;android\u0026#34;); 137 return resourceId \u0026amp;gt; 0 ? activity.getResources().getDimensionPixelSize(resourceId) : 0; 138 } 139 140 /** 141* get the height of status * 142*/ 143 public static int getStatusH(Context ctx) { 144 int statusHeight = -1; 145 try { 146 Class\u0026amp;lt;?\u0026amp;gt; clazz = Class.forName(\u0026#34;com.android.internal.R$dimen\u0026#34;); 147 Object object = clazz.newInstance(); 148 int height = Integer.parseInt(clazz.getField(\u0026#34;status_bar_height\u0026#34;).get(object).toString()); 149 statusHeight = ctx.getResources().getDimensionPixelSize(height); 150 } catch (Exception e) { 151 e.printStackTrace(); 152 } 153 return statusHeight; 154 } 155 156 /** 157* get the height of title * 158*/ 159 public static int getTitleH(Activity ctx) { 160 int contentTop = ctx.getWindow().findViewById(Window.ID_ANDROID_CONTENT).getTop(); 161 return contentTop - getStatusH(ctx); 162 } 163 164 /** 165* get the height of NavigationBar 166*/ 167 168 public static int getNavigationBarHeight(Activity mActivity) { 169 Resources resources = mActivity.getResources(); 170 int resourceId = resources.getIdentifier(\u0026#34;navigation_bar_height\u0026#34;, \u0026#34;dimen\u0026#34;, \u0026#34;android\u0026#34;); 171 int height = resources.getDimensionPixelSize(resourceId); 172 return height; 173 } 174 175 /** 176* http://stackoverflow.com/questions/12742343/android-get-screenshot-of-all-listview-items 177*/ 178 public static Bitmap shotListView(ListView listview) { 179 180 ListAdapter adapter = listview.getAdapter(); 181 int itemscount = adapter.getCount(); 182 int allitemsheight = 0; 183 List\u0026amp;lt;Bitmap\u0026amp;gt; bmps = new ArrayList\u0026amp;lt;Bitmap\u0026amp;gt;(); 184 185 for (int i = 0; i \u0026amp;lt; itemscount; i++) { 186 187 View childView = adapter.getView(i, null, listview); 188 childView.measure( 189 View.MeasureSpec.makeMeasureSpec(listview.getWidth(), View.MeasureSpec.EXACTLY), 190 View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED)); 191 192 childView.layout(0, 0, childView.getMeasuredWidth(), childView.getMeasuredHeight()); 193 childView.setDrawingCacheEnabled(true); 194 childView.buildDrawingCache(); 195 bmps.add(childView.getDrawingCache()); 196 allitemsheight += childView.getMeasuredHeight(); 197 } 198 199 Bitmap bigbitmap = 200 Bitmap.createBitmap(listview.getMeasuredWidth(), allitemsheight, Bitmap.Config.ARGB_8888); 201 Canvas bigcanvas = new Canvas(bigbitmap); 202 203 Paint paint = new Paint(); 204 int iHeight = 0; 205 206 for (int i = 0; i \u0026amp;lt; bmps.size(); i++) { 207 Bitmap bmp = bmps.get(i); 208 bigcanvas.drawBitmap(bmp, 0, iHeight, paint); 209 iHeight += bmp.getHeight(); 210 211 bmp.recycle(); 212 bmp = null; 213 } 214 215 return bigbitmap; 216 } 217 218 public static Bitmap spliceBitmap(Bitmap bmp1, Bitmap bmp2) { 219 Bitmap retBmp; 220 int width = bmp1.getWidth(); 221 if (bmp2.getWidth() != width) { 222 //以第一张图片的宽度为标准，对第二张图片进行缩放。 223 224 int h2 = bmp2.getHeight() * width / bmp2.getWidth(); 225 retBmp = Bitmap.createBitmap(width, bmp1.getHeight() + h2, Bitmap.Config.ARGB_8888); 226 Canvas canvas = new Canvas(retBmp); 227 Bitmap newSizeBmp2 = resizeBitmap(bmp2, width, h2); 228 canvas.drawBitmap(bmp1, 0, 0, null); 229 canvas.drawBitmap(newSizeBmp2, 0, bmp1.getHeight(), null); 230 } else { 231 //两张图片宽度相等，则直接拼接。 232 233 retBmp = Bitmap.createBitmap(width, bmp1.getHeight() + bmp2.getHeight(), Bitmap.Config.ARGB_8888); 234 Canvas canvas = new Canvas(retBmp); 235 canvas.drawBitmap(bmp1, 0, 0, null); 236 canvas.drawBitmap(bmp2, 0, bmp1.getHeight(), null); 237 } 238 239 return retBmp; 240 } 241 242 public static Bitmap resizeBitmap(Bitmap bitmap, int newWidth, int newHeight) { 243 float scaleWidth = ((float) newWidth) / bitmap.getWidth(); 244 float scaleHeight = ((float) newHeight) / bitmap.getHeight(); 245 Matrix matrix = new Matrix(); 246 matrix.postScale(scaleWidth, scaleHeight); 247 Bitmap bmpScale = Bitmap.createBitmap(bitmap, 0, 0, bitmap.getWidth(), bitmap.getHeight(), matrix, true); 248 return bmpScale; 249 } 250 251 /** 252* https://gist.github.com/PrashamTrivedi/809d2541776c8c141d9a 253*/ 254 public static Bitmap shotRecyclerView(RecyclerView view) { 255 RecyclerView.Adapter adapter = view.getAdapter(); 256 Bitmap bigBitmap = null; 257 if (adapter != null) { 258 int size = adapter.getItemCount(); 259 int height = 0; 260 Paint paint = new Paint(); 261 int iHeight = 0; 262 final int maxMemory = (int) (Runtime.getRuntime().maxMemory() / 1024); 263 264 // Use 1/8th of the available memory for this memory cache. 265 final int cacheSize = maxMemory / 8; 266 LruCache\u0026amp;lt;String, Bitmap\u0026amp;gt; bitmaCache = new LruCache\u0026amp;lt;\u0026amp;gt;(cacheSize); 267 for (int i = 0; i \u0026amp;lt; size; i++) { 268 RecyclerView.ViewHolder holder = adapter.createViewHolder(view, adapter.getItemViewType(i)); 269 adapter.onBindViewHolder(holder, i); 270 holder.itemView.measure( 271 View.MeasureSpec.makeMeasureSpec(view.getWidth(), View.MeasureSpec.EXACTLY), 272 View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED)); 273 holder.itemView.layout(0, 0, holder.itemView.getMeasuredWidth(), 274 holder.itemView.getMeasuredHeight()); 275 holder.itemView.setDrawingCacheEnabled(true); 276 holder.itemView.buildDrawingCache(); 277 Bitmap drawingCache = holder.itemView.getDrawingCache(); 278 if (drawingCache != null) { 279 280 bitmaCache.put(String.valueOf(i), drawingCache); 281 } 282 height += holder.itemView.getMeasuredHeight(); 283 } 284 285 bigBitmap = Bitmap.createBitmap(view.getMeasuredWidth(), height, Bitmap.Config.ARGB_8888); 286 Canvas bigCanvas = new Canvas(bigBitmap); 287 Drawable lBackground = view.getBackground(); 288 if (lBackground instanceof ColorDrawable) { 289 ColorDrawable lColorDrawable = (ColorDrawable) lBackground; 290 int lColor = lColorDrawable.getColor(); 291 bigCanvas.drawColor(lColor); 292 } 293 294 for (int i = 0; i \u0026amp;lt; size; i++) { 295 Bitmap bitmap = bitmaCache.get(String.valueOf(i)); 296 bigCanvas.drawBitmap(bitmap, 0f, iHeight, paint); 297 iHeight += bitmap.getHeight(); 298 bitmap.recycle(); 299 } 300 } 301 return bigBitmap; 302 } 303 304 /** 305* http://blog.csdn.net/lyy1104/article/details/40048329 306*/ 307 public static Bitmap shotScrollView(ViewGroup scrollView) { 308 int h = 0; 309 Bitmap bitmap = null; 310 for (int i = 0; i \u0026amp;lt; scrollView.getChildCount(); i++) { 311 h += scrollView.getChildAt(i).getHeight(); 312 scrollView.getChildAt(i).setBackgroundColor(Color.parseColor(\u0026#34;#ffffff\u0026#34;)); 313 } 314 bitmap = Bitmap.createBitmap(scrollView.getWidth(), h, Bitmap.Config.RGB_565); 315 final Canvas canvas = new Canvas(bitmap); 316 scrollView.draw(canvas); 317 return bitmap; 318 } 319 320 /** 321* http://stackoverflow.com/questions/9791714/take-a-screenshot-of-a-whole-view 322*/ 323 public static Bitmap shotView(View v, int width, int height) { 324 Bitmap b = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888); 325 Canvas c = new Canvas(b); 326 v.layout(0, 0, v.getLayoutParams().width, v.getLayoutParams().height); 327 v.draw(c); 328 return b; 329 } 330 331 /** 332* 获取整个窗口的截图 333* 334* @param context 335* @return 336*/ 337 public static Bitmap captureScreen(Activity context) { 338 View cv = context.getWindow().getDecorView(); 339 cv.setDrawingCacheEnabled(true); 340 cv.buildDrawingCache(); 341 Bitmap bmp = Bitmap.createBitmap(cv.getDrawingCache()); 342 if (bmp == null) { 343 return null; 344 } 345 bmp.setHasAlpha(false); 346 bmp.prepareToDraw(); 347 cv.destroyDrawingCache(); 348 return bmp; 349 } 350 351 public static Bitmap captureScreenOfViews(List\u0026amp;lt;View\u0026amp;gt; views,@ColorInt int backGroundColor){ 352 if (views==null){ 353 return null; 354 } 355 int height = 0; 356 int width = 0; 357 for (View view : views) { 358 height += view.getMeasuredHeight(); 359 if (width\u0026amp;lt;view.getWidth()){ 360 width = view.getWidth(); 361 } 362 } 363 Bitmap allBit = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888); 364 Canvas canvas = new Canvas(allBit); 365 canvas.drawColor(backGroundColor); 366 Paint paint = new Paint(); 367 int heights = 0; 368 for (int i = 0; i \u0026amp;lt;views.size(); i++) { 369 View view =views.get(i); 370 if (view.getMeasuredHeight()\u0026amp;lt;=0){ 371 continue; 372 } 373 view.setDrawingCacheEnabled(true); 374 view.buildDrawingCache(); 375 view.measure(View.MeasureSpec.makeMeasureSpec(view.getWidth(), 376 View.MeasureSpec.EXACTLY), View.MeasureSpec.makeMeasureSpec( 377 view.getHeight(), View.MeasureSpec.EXACTLY)); 378 view.layout((int) view.getX(), (int) view.getY(), 379 (int) view.getX() + view.getMeasuredWidth(), 380 (int) view.getY() + view.getMeasuredHeight()); 381 Bitmap drawingCache = Bitmap.createBitmap(view.getDrawingCache(),0,0,view.getMeasuredWidth(),view.getMeasuredHeight()); 382 float left = 0f; 383 if (width\u0026amp;gt;view.getWidth()){ 384 left+=(width-view.getWidth())/2f; 385 } 386 387 canvas.drawBitmap(drawingCache,left,heights,paint); 388 view.setDrawingCacheEnabled(false); 389 view.destroyDrawingCache(); 390 heights+=view.getHeight(); 391 } 392 return allBit; 393 } 394} ","date":"2019-02-25","img":"","permalink":"https://helixs.github.io/posts/android/2019-02-25-android%E5%BA%94%E7%94%A8%E5%86%85%E6%88%AA%E5%9B%BE/","series":null,"tags":null,"title":"Android应用内截图"},{"categories":["Android开发"],"content":"使用 FragmentPagerAdapter 时，ViewPager 中的所有 Fragment 实例常驻内存，当 Fragment 变得不可见时仅仅是视图结构的销毁，即调用了 onDestroyView 方法。由于 FragmentPagerAdapter 内存消耗较大，所以适合少量静态页面的场景。\n使用 FragmentStatePagerAdapter 时，当 Fragment 变得不可见，不仅视图层次销毁，实例也被销毁，即调用了 onDestroyView 和 onDestroy 方法，仅仅保存 Fragment 状态。相比而言， FragmentStatePagerAdapter 内存占用较小，所以适合大量动态页面，比如我们常见的新闻列表类应用。\n不管是哪种情况，他们的view都是有可能被销毁的。关键点是在于view的保存和fragment的显示隐藏状态\n1package com.demo; 2 3import android.os.Bundle; 4import android.view.LayoutInflater; 5import android.view.View; 6import android.view.ViewGroup; 7 8import androidx.annotation.NonNull; 9import androidx.annotation.Nullable; 10import androidx.fragment.app.Fragment; 11 12/** 13* 只针对于FragmentPagerAdapter 只适用于懒加载 14*/ 15public abstract class BasePagerFragment extends Fragment { 16 17 private View rootView; 18 19 private boolean isViewCreated; 20 private boolean isDataLoaded; 21 22 /** 23* 是否每次在createview的时候加载数据 24*/ 25 private boolean isCreateRefresh; 26 27 /** 28* 设置每次fragment显示的时候是否LoadData 29* 30* @param createRefresh 31*/ 32 protected void setDisplayRefresh(boolean createRefresh) { 33 isCreateRefresh = createRefresh; 34 } 35 36 @Override 37 public void onCreate(@Nullable Bundle savedInstanceState) { 38 super.onCreate(savedInstanceState); 39 } 40 41 @Nullable 42 @Override 43 public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) { 44 //todo init 45 if (rootView == null) { 46 rootView =getRootView(inflater,container); 47 } else { 48 //如果不需要每次都刷新那么就视为已加载 49 if (!isCreateRefresh) { 50 isDataLoaded = true; 51 } 52 } 53 return rootView; 54 } 55 56 @Override 57 public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) { 58 super.onViewCreated(view, savedInstanceState); 59 isViewCreated = true; 60 if (canloadData(isCreateRefresh)) { 61 loadData(); 62 isDataLoaded = true; 63 } 64 } 65 66 @Override 67 public void onDestroyView() { 68 super.onDestroyView(); 69 isViewCreated = false; 70 isDataLoaded = false; 71 } 72 73 @Override 74 public void setUserVisibleHint(boolean isVisibleToUser) { 75 super.setUserVisibleHint(isVisibleToUser); 76 if (canloadData(isCreateRefresh)) { 77 loadData(); 78 isDataLoaded = true; 79 } 80 } 81 82 83 /** 84* 检查是否可以刷新数据 85* 86* @param forceUpdate 是否可以主动刷新数据 87*/ 88 private boolean canloadData(boolean forceUpdate) { 89 return (getUserVisibleHint() \u0026amp;\u0026amp; isViewCreated \u0026amp;\u0026amp; (!isDataLoaded || forceUpdate)); 90 91 } 92 93 /** 94* 本方法只会在数据没有加载或者view重新绘制的时候调用 95*/ 96 protected abstract void loadData(); 97 98 /** 99* 获取跟布局 100* 101* @return rootView 102* @param inflater 103* @param container 104*/ 105 protected abstract View getRootView(LayoutInflater inflater, ViewGroup container); 106 107} 二 、当使用FragmentPagerAdapter动态删除和添加的问题 1//源代码 2 3public Object instantiateItem(@NonNull ViewGroup container, int position) { 4 if (mCurTransaction == null) { 5 mCurTransaction = mFragmentManager.beginTransaction(); 6 } 7 8 final long itemId = getItemId(position); 9 10 // Do we already have this fragment? 11 String name = makeFragmentName(container.getId(), itemId); 12 Fragment fragment = mFragmentManager.findFragmentByTag(name); 13 if (fragment != null) { 14 if (DEBUG) Log.v(TAG, \u0026#34;Attaching item #\u0026#34; + itemId + \u0026#34;: f=\u0026#34; + fragment); 15 mCurTransaction.attach(fragment); 16 } else { 17 fragment = getItem(position); 18 if (DEBUG) Log.v(TAG, \u0026#34;Adding item #\u0026#34; + itemId + \u0026#34;: f=\u0026#34; + fragment); 19 mCurTransaction.add(container.getId(), fragment, 20 makeFragmentName(container.getId(), itemId)); 21 } 22 if (fragment != mCurrentPrimaryItem) { 23 fragment.setMenuVisibility(false); 24 fragment.setUserVisibleHint(false); 25 } 26 27 return fragment; 28} instantiateItem在执行时会FragmentManager里面查找是否已存在对应的fragment，如果不存在，才会执行getItem 。所以会无效\n两个解决方法\n  1.使用FragmentPagerStateAdapter\n  2.覆写getItemId()\n  1@Override 2public long getItemId(int position) { 3 return fragments.get(position).hashCode(); 4} 感谢http://yifeng.studio/2016/12/23/android-fragment-and-viewpager-attentions/ ","date":"2019-02-15","img":"","permalink":"https://helixs.github.io/posts/android/2019-02-15-viewpagerfragment%E7%9A%84%E6%87%92%E5%8A%A0%E8%BD%BD/","series":null,"tags":["fragment"],"title":"Viewpager+fragment的懒加载"},{"categories":["Android开发"],"content":"前前后后google不知道每年推出N中新东西，每次看了看就忘记了，还是回忆一下ConstraintLayout这个约束布局了。\n 布局在2016年就已经推出了，并且在当年的IO大会上重点讲解了它的特点：\n  解决复杂布局嵌套过多，影响性能的问题。 相对定位，和RelativeLayout大致相同，也同样支持Baseline基线定位。 角度定位，更加玄学了。角度和距离定位了（想象一下在直角坐标系中中心点O距离点A的角度和距离了）。 支持按照比例偏移。 尺寸方面，match_parent尽量少用，直接0dp往上干。并且更好的支持比例约束。 链式布局，可以想象在Flex布局中justify-content，不过没有flex那么强大啦，也只有3个属性选择。 Optimizer，当控件设置尺寸为0dp的时候布局会进行二次测量，不可避免的会进行耗时操作，所以要进行处理。 Barrier，屏障，相当于一个阈值吧，不过我这样形容不恰当。 Group，可以将控件进行分组，而直接在这个组上面设置属性，那么组当中所带入的属性会直接传到属于这个组的控件上面。感觉这个设计特别棒，如统一的颜色和统一的显示隐藏等。 Placeholder，占位符，也很吊，可以动态控制显示的控件。不需要我们每次动态setVisibility了。 Guideline，辅助线，执行复杂布局中这个是很有效的东西哦。   上面就是这个ConstraintLayout的一些特性了。下面就慢慢的介绍一下它的具体使用方式\nConstraintLayout  1public class ConstraintLayout extends ViewGroup  java.lang.Object\n android.view.View\n android.view.ViewGroup\n android.support.constraint.ConstraintLayout\n    1、相对约束 RelativeLayout用的还算熟练吧，不过我自己基本不用，为啥？大家应该都知道，要些一堆的align,to….等等和一大堆的ID，没有很好的层级关系和组关系。不喜欢麻烦的我往往喜欢使用一大堆LinearLayout和FrameLayout进行嵌套。层次倒是很清楚了哈。这样往往写的代码量也很多，嵌套也很多。\n我们先看看在ConstraintLayout中相对约束的基本使用\n如layout_constraintLeft_toLeftOf=”parent” ：意思就是当前控件左边的约束是在父控件的左边，当然parent也可以是某个控件，依次类推基本的实现方式就是这样了。其实使用layout_constraintStart_toStartOf和上面是一样的效果，不过基本上被start和end替代了，因为有些语言是从右往左读的啦就是RTL-\u0026gt;right to left，如阿拉伯语。哈哈是不是古时候的汉语也是从右往左呢。如果做国际化是有这个需求啦。\nlayout_constraintBaseline_toBaselineOf 这个是基线对齐哦。\n2、角度定位 1\u0026lt;Button 2 android:id=\u0026#34;@+id/btn1\u0026#34; 3 android:layout_width=\u0026#34;wrap_content\u0026#34; 4 android:layout_height=\u0026#34;wrap_content\u0026#34; /\u0026gt; 5 6\u0026lt;Button 7 android:id=\u0026#34;@+id/btn2\u0026#34; 8 android:layout_width=\u0026#34;wrap_content\u0026#34; 9 android:layout_height=\u0026#34;wrap_content\u0026#34; 10 app:layout_constraintCircle=\u0026#34;@+id/btn1\u0026#34; 11 app:layout_constraintCircleAngle=\u0026#34;120\u0026#34; 12 app:layout_constraintCircleRadius=\u0026#34;150dp\u0026#34; /\u0026gt; 角度定位是按照控件的中心点来的，在Y轴正方向上取长度为150dp的线段绕着点btn1中心顺时针旋转120度后就是btn2中心位置。\n3、MARGIN ConstraintLayout中的margin和普通布局一样的，需要注意的是必须是控件已经完全约束了才能使margin这个属性有效果。\n这里主要说一下goneMargin\n1 \u0026lt;Button 2 android:id=\u0026#34;@+id/btn1\u0026#34; 3 android:layout_width=\u0026#34;wrap_content\u0026#34; 4 android:layout_height=\u0026#34;wrap_content\u0026#34; /\u0026gt; 5 6\u0026lt;Button 7 android:id=\u0026#34;@+id/btn2\u0026#34; 8 android:layout_width=\u0026#34;wrap_content\u0026#34; 9 android:layout_height=\u0026#34;wrap_content\u0026#34; 10 app:layout_goneMarginTop=\u0026#34;10\u0026#34; 11 app:layout_constraintCircle=\u0026#34;@+id/btn1\u0026#34; 12 app:layout_constraintCircleAngle=\u0026#34;120\u0026#34; 13 app:layout_constraintCircleRadius=\u0026#34;150dp\u0026#34; /\u0026gt; 如果当btn1被gone掉了，btn2依然可以距离btn1底部10dp。\n4、比例偏移 我们偏移常常用的是margin具体的大小。ConstraintLayout可以按照比例偏移\n1\u0026lt;Button 2 android:id=\u0026#34;@+id/btn1\u0026#34; 3 app:layout_constraintStart_toStartOf=\u0026#34;parent\u0026#34; 4 app:layout_constraintTop_toTopOf=\u0026#34;parent\u0026#34; 5 android:layout_width=\u0026#34;wrap_content\u0026#34; 6 android:background=\u0026#34;@color/design_default_color_primary\u0026#34; 7 android:layout_height=\u0026#34;wrap_content\u0026#34; /\u0026gt; 8 9\u0026lt;Button 10 android:layout_width=\u0026#34;wrap_content\u0026#34; 11 app:layout_constraintTop_toTopOf=\u0026#34;parent\u0026#34; 12 app:layout_constraintStart_toStartOf=\u0026#34;@id/btn1\u0026#34; 13 app:layout_constraintEnd_toEndOf=\u0026#34;@id/btn2\u0026#34; 14 android:layout_height=\u0026#34;wrap_content\u0026#34; /\u0026gt; 15 16\u0026lt;Button 17 android:id=\u0026#34;@+id/btn2\u0026#34; 18 app:layout_constraintEnd_toEndOf=\u0026#34;parent\u0026#34; 19 app:layout_constraintTop_toTopOf=\u0026#34;parent\u0026#34; 20 android:layout_width=\u0026#34;wrap_content\u0026#34; 21 android:background=\u0026#34;@color/design_default_color_primary\u0026#34; 22 android:layout_height=\u0026#34;wrap_content\u0026#34; /\u0026gt; 按照上面的方式：\n默认是居中的，我们修改一下:\n1\u0026lt;Button 2 android:id=\u0026#34;@+id/btn1\u0026#34; 3 app:layout_constraintStart_toStartOf=\u0026#34;parent\u0026#34; 4 app:layout_constraintTop_toTopOf=\u0026#34;parent\u0026#34; 5 android:layout_width=\u0026#34;wrap_content\u0026#34; 6 android:background=\u0026#34;@color/design_default_color_primary\u0026#34; 7 android:layout_height=\u0026#34;wrap_content\u0026#34; /\u0026gt; 8 9\u0026lt;Button 10 android:layout_width=\u0026#34;wrap_content\u0026#34; 11 app:layout_constraintTop_toTopOf=\u0026#34;parent\u0026#34; 12 app:layout_constraintStart_toStartOf=\u0026#34;@id/btn1\u0026#34; 13 app:layout_constraintHorizontal_bias=\u0026#34;0.3\u0026#34; 14 app:layout_constraintEnd_toEndOf=\u0026#34;@id/btn2\u0026#34; 15 android:layout_height=\u0026#34;wrap_content\u0026#34; /\u0026gt; 16 17\u0026lt;Button 18 android:id=\u0026#34;@+id/btn2\u0026#34; 19 app:layout_constraintEnd_toEndOf=\u0026#34;parent\u0026#34; 20 app:layout_constraintTop_toTopOf=\u0026#34;parent\u0026#34; 21 android:layout_width=\u0026#34;wrap_content\u0026#34; 22 android:background=\u0026#34;@color/design_default_color_primary\u0026#34; 23 android:layout_height=\u0026#34;wrap_content\u0026#34; /\u0026gt; 是这样的:\n看到了吧，我们可以按照比例来放置约束条件，是不是不错呢。我们以前的话是不是还要在外面放入LinearLayout加入weight呢。\n5、尺寸约束 如果你的控件想撑满parent的宽或者高，就不要使用match_parent了，直接设置0dp便是，前提是加上约束条件。如果直接用match_parent会超过屏幕显示哦，gg了。\nlayout_constraintDimensionRatio这个属性是设置宽高比例。如果当宽或高其中一个设置为0dp的时候，\n可以设置layout_constraintDimensionRatio=”1:1″，就是宽高1:1。\n当然也可以设置别的比例，很方便:\n layout_constraintDimensionRatio=”H,2:3″ 高宽比\nlayout_constraintDimensionRatio=”W,3:2″ 宽高比\n 6、链式布局   1.如果使用链式布局需要遵循这种要求\n即链的两边都要有约束，且链上的控件只与相邻控件有约束条件\n  2.链头\n链头即第一个控件是链属性设置的位置，水平方向上的开头或者垂直方向上的顶部第一个。链的属性都在这上面设置。\n  3.链属性\n通过在链头设置layout_constraintHorizontal_chainStyle和layout_constraintVertical_chainStyle分别设置水平和垂直方向上的链样式。并且提供了三种属性\n CHAIN_SPREAD 默认属性，元素相互展开 CHAIN_SPREAD_INSIDE 元素也是相互展开，但是链的两端贴紧约束，不会展开 CHAIN_PACKED 将元素们紧紧贴在一起，就是一坨。    其中Weighted Chain是当width为0dp时候加入layout_constraintHorizontal_weight权重比例来的。而Packed Cain with Bias 是加入了layout_constraintHorizontal_bias出现的比例。\n  7、OPTIMIZER 就是当控件中使用了0dp的宽或者高的时候会进行2次测量，这时候就需要优化，不过我感觉真不知道怎么用，还需要多看看 layout_optimizationLevel\n none : no optimizations are applied standard : Default. Optimize direct and barrier constraints only direct : optimize direct constraints barrier : optimize barrier constraints chain : optimize chain constraints (experimental) dimensions : optimize dimensions measures (experimental), reducing the number of measures of match constraints elements  8、BARRIER 屏障 当我们有ABC三个控件，C在AB的右边，但AB的宽度不一样，我们要让C永远都在A或者B的右边怎么办\n1\u0026lt;TextView 2 android:id=\u0026#34;@+id/TextView1\u0026#34; 3 android:layout_width=\u0026#34;wrap_content\u0026#34; 4 android:layout_height=\u0026#34;wrap_content\u0026#34; /\u0026gt; 5 6\u0026lt;TextView 7 android:id=\u0026#34;@+id/TextView2\u0026#34; 8 android:layout_width=\u0026#34;wrap_content\u0026#34; 9 android:layout_height=\u0026#34;wrap_content\u0026#34; 10 app:layout_constraintTop_toBottomOf=\u0026#34;@+id/TextView1\u0026#34; /\u0026gt; 11 12\u0026lt;android.support.constraint.Barrier 13 android:id=\u0026#34;@+id/barrier\u0026#34; 14 android:layout_width=\u0026#34;wrap_content\u0026#34; 15 android:layout_height=\u0026#34;wrap_content\u0026#34; 16 app:barrierDirection=\u0026#34;right\u0026#34; 17 app:constraint_referenced_ids=\u0026#34;TextView1,TextView2\u0026#34; /\u0026gt; 18 19\u0026lt;TextView 20 android:id=\u0026#34;@+id/TextView3\u0026#34; 21 android:layout_width=\u0026#34;wrap_content\u0026#34; 22 android:layout_height=\u0026#34;wrap_content\u0026#34; 23 app:layout_constraintLeft_toRightOf=\u0026#34;@+id/barrier\u0026#34; /\u0026gt; app:barrierDirection为屏障所在的位置，可设置的值有：bottom、end、left、right、start、top ,app:constraint_referenced_ids为屏障引用的控件，可设置多个(用“,”隔开)\n10、占位符 我们通过Placeholder控件，将其中其他一个控件进行绑定，转移到这里来，通过content属性\n11、GUIDELINE 辅助线 通过guideline可以实现较为复杂的布局，并且这个不会显示在屏幕上。主要属性是\n  android:orientation layout_constraintGuide_begin layout_constraintGuide_end layout_constraintGuide_percent   遇到的问题 1.当ConstrainLayout布局高度固定，子布局是动态高度，要求子布局不超过父布局，所以子布局高度warp_conent，但是怎么加约束高度到了还是会超过父布局，比如子布局当中有个RecyclerView或者Scrollview等等。用两个属性：\n  app:layout_constrainedHeight=\u0026ldquo;true\u0026rdquo; app:layout_constrainedWidth=\u0026ldquo;true\u0026rdquo;   意思就是约束宽高。\n","date":"2019-01-22","img":"","permalink":"https://helixs.github.io/posts/android/2019-01-22-android%E5%B8%83%E5%B1%80%E4%B9%8Bconstraintlayout%E7%9A%84%E4%B8%80%E4%BA%9B%E7%89%B9%E6%80%A7/","series":null,"tags":null,"title":"Android布局之ConstraintLayout的一些特性"},{"categories":["vps工具"],"content":"什么是BBR：  TCP BBR是谷歌出品的TCP拥塞控制算法。BBR目的是要尽量跑满带宽，并且尽量不要有排队的情况。BBR可以起到单边加速TCP连接的效果。\n  Google提交到Linux主线并发表在ACM queue期刊上的TCP-BBR拥塞控制算法。继承了Google“先在生产环境上部署，再开源和发论文”的研究传统。TCP-BBR已经再YouTube服务器和Google跨数据中心的内部广域网(B4)上部署。由此可见出该算法的前途。\n  TCP-BBR的目标就是最大化利用网络上瓶颈链路的带宽。一条网络链路就像一条水管，要想最大化利用这条水管，最好的办法就是给这跟水管灌满水。\n BBR解决了两个问题：\n 在有一定丢包率的网络链路上充分利用带宽。非常适合高延迟，高带宽的网络链路。 降低网络链路上的buffer占用率，从而降低延迟。非常适合慢速接入网络的用户。  以上来自http://blog.51cto.com/zero01/2064660  通过上面我们大概知道bbr就是想办法给你加大带宽流量的和速锐那种暴力发包是两回事。google的这个bbr算法已经集成到linux4.9内核以上，即便你的系统是最新版但是大多数情况下云服务厂商默认都还是使用的3.x，所以我们要升级内核并且切换到该内核上面，最后再开启bbr。\n1#查看使用的内核版本，如果是4.9+的话就可以跳过了 2uname -a 然后我们进入http://elrepo.org/tiki/tiki-index.php 查看最新的rpm源，按照上面的方法进行源设置\n1#导入源 2rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org 3#设置源 4rpm -Uvh https://www.elrepo.org/elrepo-release-7.0-3.el7.elrepo.noarch.rpm 最新的教程已经不需要上面的这样了直接install\n1yum install https://www.elrepo.org/elrepo-release-7.0-3.el7.elrepo.noarch.rpm 然后，进入http://elrepo.org/tiki/kernel-ml 查看安装方法\n1yum --enablerepo=elrepo-kernel install kernel-ml 2#使用这个看不懂的命令进入查看已经安装的内核 3egrep ^menuentry /etc/grub2.cfg | cut -f 2 -d \\\u0026#39; 10 : CentOS Linux (4.20.2-1.el7.elrepo.x86_64) 7 (Core) 21 : CentOS Linux 7 Rescue 22d9950eefb24f96aca762064cd277d2 (3.10.0-957.1.3.el7.x86_64) 32 : CentOS Linux (3.10.0-957.1.3.el7.x86_64) 7 (Core) 43 : CentOS Linux (3.10.0-693.11.6.el7.x86_64) 7 (Core) 54 : CentOS Linux (3.10.0-693.el7.x86_64) 7 (Core) 65 : CentOS Linux (0-rescue-00a62363617944e08db8db894ba6145e) 7 (Core) 我这里已经安装了4.20的内核版本了，还得切换到这个内核\n1#因为是第0个所以是0 2grub2-set-default 0 3#重启 4reboot 1//查看内核版本 2uname - r 34.20.2-1.el7.elrepo.x86_64 4#没问题 5vim /etc/sysctl.conf 6#最后一行加入 7net.core.default_qdisc = fq 8net.ipv4.tcp_congestion_control = bbr 9#wq 10sysctl -p 11#net.core.default_qdisc = fq 12#net.ipv4.tcp_congestion_control = bbr 13sysctl net.ipv4.tcp_available_congestion_control 14#net.ipv4.tcp_available_congestion_control = reno cubic bbr 15lsmod | grep bbr 16#tcp_bbr 20480 1  基本上就成功啦。\n","date":"2019-01-16","img":"","permalink":"https://helixs.github.io/posts/linux/2019-01-16-centos%E5%BC%80%E5%90%AFbbr/","series":null,"tags":["bbr","centos"],"title":"Centos开启bbr"},{"categories":["开发环境"],"content":" 我们使用idea写kotlin代码的时候有很多类型都是自己判断了，不用像java一样强制定义类型，可是当我们写了一个变量或者赋值变量的时候能看到val或者是var的类型\n 比如我们现在想要这样一个代码\n1val rect= getMatrixRectF() 默认情况下我并不知道rect是个什么类型，然后我们就打开idea的设置了\nSetting-\u0026gt;Editor-\u0026gt;Appearance-\u0026gt;show parameter name hints-\u0026gt;Configure-\u0026gt;Language=Kotlin\n全部选中即可\n","date":"2019-01-15","img":"","permalink":"https://helixs.github.io/posts/android/2019-01-15-idea%E6%98%BE%E7%A4%BAkotlin%E7%9A%84%E6%8E%A8%E6%96%AD%E7%B1%BB%E5%9E%8B/","series":null,"tags":null,"title":"Idea显示kotlin的推断类型"},{"categories":["Android开发"],"content":" 今天android项目里有个需求，一个textview中要显示最多8个字符，英文算一个，中文算两个。满满以为直接用一下这种方法判断了\n 1public static String getDisplay(String data, int maxLength) { 2 if (TextUtils.isEmpty(data)) { 3 return data; 4 } 5 if (CheckUtil.isStringLength(data) \u0026lt;= maxLength) { 6 return data; 7 } 8 int length = 0; 9 StringBuilder stringBuilder = new StringBuilder(); 10 for (int i = 0; i \u0026lt; data.length(); i++) { 11 if (length \u0026gt;= maxLength) { 12 stringBuilder.append(\u0026#34;...\u0026#34;); 13 break; 14 } 15 String temp = data.substring(i, i + 1); 16 if (temp.matches(\u0026#34;[\\u4e00-\\u9fa5]\u0026#34;)) { 17 length += 2; 18 stringBuilder.append(temp); 19 } else { 20 length += 1; 21 stringBuilder.append(temp); 22 } 23 } 24 return stringBuilder.toString(); 25 26} 27 结果测试加入了emoji表情，直接截取0-7会在部分手机上出现？等无法识别的情况，然后是查了查emoji是基于Unicode编码来的，也就是说随便一个emoji组成的字符长度最少是两位,所以我直接截取了表情的一半那肯定就是不行了，然后具体查了查编码的历史从ascii到utf-8等等，这里https://www.cnblogs.com/gavin-num1/p/5170247.html 。\n然后找到了java的api主要关于unicode有以下几个方法\n  int\tcodePointAt(int index)\n返回指定索引处的字符（Unicode 代码点）。\n   int\tcodePointBefore(int index)\n返回指定索引之前的字符（Unicode 代码点）。\n   int codePointCount(int beginIndex, int endIndex)\n返回此 String 的指定文本范围中的 Unicode 代码点数。\n   int\toffsetByCodePoints(int index, int codePointOffset)\n返回此 String 中从给定的 index 处偏移 codePointOffset 个代码点的索引。\n  我们现在截取的字符数量是8位，然后我们就找到在0到7位中的unicode编码，这样汉字和emoji就一起解决了。\n1String newString = \u0026#34;1??1??\u0026#34;; 2System.out.println(newString.substring(0, newString.offsetByCodePoints(0, newString.codePointCount(0, 7)))); 3 4//print: 1??1? 是不是比上一个代码实现的简单的多。\n","date":"2019-01-14","img":"","permalink":"https://helixs.github.io/posts/android/2019-01-14-java%E5%85%B3%E4%BA%8E%E5%88%A4%E6%96%ADemoji%E4%BD%8D%E6%95%B0%E5%92%8C%E6%88%AA%E5%8F%96%E7%9A%84%E4%B8%80%E4%BA%9B%E5%A4%84%E7%90%86/","series":null,"tags":null,"title":"Java关于判断emoji位数和截取的一些处理"},{"categories":["Android开发"],"content":"今天在android项目中导入了kotlin的支持，可是怎么运行也运行不起来\nProgram type already present: javax.annotation.CheckReturnValue  等等 包冲突了，检查不同的library的版本，然后清空缓存重试\n","date":"2018-12-26","img":"","permalink":"https://helixs.github.io/posts/android/2018-12-26-android%E9%A1%B9%E7%9B%AE%E5%BC%95%E5%85%A5kotlin%E5%8C%85%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98/","series":null,"tags":null,"title":"Android项目引入kotlin包冲突问题"},{"categories":["Android开发"],"content":"今天做项目的时候用到了Transition动画。也就是android5.0中出现的。基本的使用方式我们都知道是用TransitionName在两个activity中进行绑定。\n现在的场景是activityA中有个recyclerview，点击item的时候跳转到activityB。B中是一个类似全屏的viewpager。item中的图片元素共享的viewpager指定的Item上。并且viewpager可以动态删除item，返回的A的时候item也要同步数量。\n想想实现功能应该不难。难的地方在于两个页面的item数量不一样，共享元素view的位置可能也不一样。如果B当中已经改变了item的数量和选中的viewpager的position的位置，A那边的共享元素该如何改变呢。现在开始展现真正的轮子了。\n1、基本使用 设置两个activity的style中 android:windowContentTransitions 为true\n1 \u0026lt;style name=\u0026#34;TransparentTheme\u0026#34; parent=\u0026#34;Theme.AppCompat.Light.NoActionBar\u0026#34;\u0026gt; 2 \u0026lt;item name=\u0026#34;android:windowTranslucentNavigation\u0026#34;\u0026gt;false\u0026lt;/item\u0026gt; 3 \u0026lt;item name=\u0026#34;android:windowTranslucentStatus\u0026#34;\u0026gt;true\u0026lt;/item\u0026gt; 4 \u0026lt;item name=\u0026#34;android:windowContentTransitions\u0026#34;\u0026gt;true\u0026lt;/item\u0026gt; 5 \u0026lt;item name=\u0026#34;android:windowIsTranslucent\u0026#34;\u0026gt;false\u0026lt;/item\u0026gt; 6 \u0026lt;item name=\u0026#34;android:windowNoTitle\u0026#34;\u0026gt;true\u0026lt;/item\u0026gt; 7\u0026lt;/style\u0026gt; 共享元素关键点是绑定的view和view的TransitionName，那么我们就要给itemView设置transitionName了。这里我们使用url给item设置TransitionName，如果item的url一样那么可以自己想想，保持唯一就行了。\n1ViewCompat.setTransitionName(holder.itemView, ims.get(position).url); ViewCompat是support兼容类。不然就要写一堆判断了很是烦。\n启动activity绑定transitionView,将list和选中的item传入\n1 ActivityOptionsCompat options = 2 ActivityOptionsCompat.makeSceneTransitionAnimation(A.this, 3 holder.itemView, ViewCompat.getTransitionName(holder.itemView)); 4Intent intent = new Intent(A.this, B.class); 5intent.putExtra(B.INTENT_SELECT_POSITION, imgs.get(holder.getAdapterPosition())); 6intent.putParcelableArrayListExtra(B.INTENT_IMGS, imgs); 7ActivityCompat.startActivityForResult(A.this, intent, REQUEST_CODE_PREVIEW, options.toBundle()); 之后我们到了B的Activity，这里我们不要为viewpager的每个itemview设置transitionName，我们直接给viewpager设置transitionName，以为viewpager选中页的两边都会加载view，处理起来稍微有点麻烦，直接设置viewpager的transitionName反而方便连贯。\n1//currentItem是我从上个页面传进来的Item 2ViewCompat.setTransitionName(viewPager, currentItem.url); 3//.... 4//设置选中的item 5viewPager.setCurrentItem(i); 1@Override 2public void onBackPressed() { 3 checkFinish(RESULT_OK); 4} 5/** 6* 通过转场动画finish 7*/ 8private void checkFinish(int resultCode) { 9 Intent intent = new Intent(); 10 intent.putParcelableArrayListExtra(INTENT_IMGS, imgs); 11 setResult(resultCode, intent); 12 supportFinishAfterTransition(); 13} 2、进阶使用 基本的点击返回效果我们就搞好了，可是还是会出现动画不连贯的效果。一头雾水的搜了一下\n1//如果共享元素需要通过AsyncTask，一个Loader，或其他类似的进行数据加载在被调用的 2//Activity决定它们最终的表现，数据被分发返回到主线程之前框架可以开始过渡。 3supportPostponeEnterTransition()//暂时阻止共享元素过渡 4supportStartPostponedEnterTransition//确认元素都已经摆放完成恢复过度 因为viewpager.setCurrentItem之后UI毕竟是在默认300ms完成绘制。所以我们要等待viewpager完全展示完成才能进行过渡动画的渲染。\n1@Override 2protected void onCreate(Bundle savedInstanceState) { 3 super.onCreate(savedInstanceState); 4 supportPostponeEnterTransition(); 5 ....//更新ui 6 //监听viewpager布局树已经绘制完成 7 viewPager.getViewTreeObserver().addOnGlobalLayoutListener(new 8 ViewTreeObserver.OnGlobalLayoutListener() { 9 @Override 10 public void onGlobalLayout() { 11 viewPager.getViewTreeObserver().removeOnGlobalLayoutListener(this); 12 //释放 13 supportStartPostponedEnterTransition(); 14 } 15 }); 16} 这样我们的连贯效果就实现了。\n3、完成实现 因为我们知道B页面是带有删除和翻页功能的，所以我们就要进行页面之间切换时候的ui数据整理。我试着在onActivityResult中用supportPostponeEnterTransition和supportStartPostponedEnterTransition实现数据的变换，发现效果并没有实现，onActivityResult在过渡动画后才调用。所以还是搜索一下\n1/** 2* Called when an activity you launched with an activity transition exposes this 3* Activity through a returning activity transition, giving you the resultCode 4* and any additional data from it. This method will only be called if the activity 5* set a result code other than {@link #RESULT_CANCELED} and it supports activity 6* transitions with {@link Window#FEATURE_ACTIVITY_TRANSITIONS}. 7* 8* \u0026lt;p\u0026gt;The purpose of this function is to let the called Activity send a hint about 9* its state so that this underlying Activity can prepare to be exposed. A call to 10* this method does not guarantee that the called Activity has or will be exiting soon. 11* It only indicates that it will expose this Activity\u0026#39;s Window and it has 12* some data to pass to prepare it.\u0026lt;/p\u0026gt; 13* 14* @param resultCode The integer result code returned by the child activity 15* through its setResult(). 16* @param data An Intent, which can return result data to the caller 17* (various data can be attached to Intent \u0026#34;extras\u0026#34;). 18*/ 19public void onActivityReenter(int resultCode, Intent data) { 20 //当你使用了过度动画返回时候就会调用此方法，通过supportPostponeEnterTransition和supportStartPostponedEnterTransition可以延缓动画的发生 21//只要resultCode不是RESULT_CANCELED并且 Window#FEATURE_ACTIVITY_TRANSITIONS这个已经在theme里设置了 22 23} 我们这么干\n1@Override 2public void onActivityReenter(int resultCode, Intent data) { 3 if (resultCode == RESULT_OK \u0026amp;\u0026amp; data != null) { 4 //针对classloader回收 我这里出现了这个问题，如果没有请忽略 5 data.setExtrasClassLoader(getClass().getClassLoader()); 6 ArrayList\u0026lt;String\u0026gt; limgs = data.getParcelableArrayListExtra(B.INTENT_IMGS); 7 imgs = limgs; 8 adapter.setIms(imgs); 9 adapter.notifyDataSetChanged(); 10 supportPostponeEnterTransition(); 11 binding.recyclerview.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() { 12 @Override 13 public void onGlobalLayout() { 14 recyclerview.getViewTreeObserver().removeOnGlobalLayoutListener(this); 15 supportStartPostponedEnterTransition(); 16 } 17 }); 18 } 19 20 super.onActivityReenter(resultCode, data); 21} 满怀希望的试一试。结果懵逼，切换了还是没效果。。。==。B页面的共享viewpager的TransitionName还是原来的。我们要在返回的时候设置viewpager的TransitionName为当前选中的item的url。\nB中\n1/** 2* 通过转场动画finish 3*/ 4private void checkFinish(int resultCode) { 5 Intent intent = new Intent(); 6 setEnterShareCallback(currentItem); 7 intent.putParcelableArrayListExtra(INTENT_IMGS, imgs); 8 setResult(resultCode, intent); 9 supportFinishAfterTransition(); 10} 11 12private void setEnterShareCallback(String url) { 13//设置共享元素们的回调 14 setEnterSharedElementCallback(new SharedElementCallback() { 15 @Override 16 public void onMapSharedElements(List\u0026lt;String\u0026gt; names, Map\u0026lt;String, View\u0026gt; sharedElements) { 17 sharedElements.clear(); 18 names.clear(); 19 if (currentItem==null){ 20 return; 21 } 22 names.add(url); 23 sharedElements.put(url,viewPager); 24 } 25 }); 26} 这里具体可以参考 https://blog.csdn.net/mr_wrong1/article/details/49669275 哈哈 。可以了。不过最后一步中，感觉只需要设置viewpager的TransitionName就行了，没试过。有时间再试试吧。\n4、遇到的问题 项目加载网络图片会出现一些问题。如果使用glide的话要禁用动画加载dontAnimate。 还有部分时候会出现viewpager翻页会出现返回动画失效的问题,我们在返回的时候需要进行view的替换\n1@Override 2protected void onCreate(Bundle savedInstanceState) { 3 setExitSharedElementCallback(new SharedElementCallback() { 4 @Override 5 public void onMapSharedElements(List\u0026lt;String\u0026gt; names, Map\u0026lt;String, View\u0026gt; sharedElements) { 6 //isBack为成员变量 如果启动B页面设置为false,onActivityReenter后为true 7 if (isBack) { 8 names.clear(); 9 names.add(shareName); 10 sharedElements.clear(); 11 sharedElements.put(shareName, shareView); 12 } 13 } 14 }); 15} 16public void onActivityReenter(){ 17//更新adapter 18//....... 19recyclerview.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() { 20 @Override 21 public void onGlobalLayout() { 22 notifyCallView(data); 23 recyclerview.getViewTreeObserver().removeOnGlobalLayoutListener(this); 24 supportStartPostponedEnterTransition(); 25 } 26 }); 27} 28private void notifyCallView(Intent data) { 29 30 //遍历recyclerview.getchildCount 从B页面返回的url值 31 //..... 32 shareName = url; 33 shareView = viewHolder.itemView; 34 35} 5、Glide在共享元素动画时会gif会停止播放 我们实现了recyclerView到viewpager的转换，用glide加载gif，viewpager中并不能正常播放，把动画关了就可以，初步猜想是因为，我们在viewpager的istantiateItem中用glide直接去into了，此时共享元素动画是处于暂停状态，所以我们的gif也被迫暂停，当然我这只是猜想。可以等viewpager加载完成之后再into，或者延迟加载。\n","date":"2018-12-11","img":"","permalink":"https://helixs.github.io/posts/android/2018-12-11-android-recyclerview%E7%82%B9%E5%87%BB%E8%B7%B3%E8%BD%AC%E5%88%B0viewpager%E5%85%B1%E4%BA%AB%E5%85%83%E7%B4%A0%E5%8A%A8%E7%94%BB/","series":null,"tags":null,"title":"Android Recyclerview点击跳转到viewpager共享元素动画"},{"categories":["开发环境"],"content":"最近不知道怎么的从git上下来代码好慢，访问github没啥问题，找了一下原来是http://github.global.ssl.fastly.Net这个被我们伟大的墙把限制邪恶的资本主义限制了。\n前提是你要开代理，正常情况下ss for windows的http和socks5都是共用的1080端口，mac 版本的ng要设置http端口，这里以1080为例。网上基本上都是全局的设置\n1git config --global http.proxy http://127.0.0.1:1080 2git config --global https.proxy http://127.0.0.1:1080 果然是立竿见影，可是如果是访问内网或者国内的git仓局要么找不到要么就很慢，这个可是不行的，所以我们只能针对github进行代理\n1git config --global http.https://github.com.proxy http://127.0.0.1:1080 2git config --global https.https://github.com.proxy http://127.0.0.1:1080 上面是走http代理，下面是走sock5代理\n1git config --global http.https://github.com.proxy socks5://127.0.0.1:1080 2git config --global https.https://github.com.proxy socks5://127.0.0.1:1080 取消代理如下\n1git config --global --unset http.proxy 2git config --global --unset https.proxy 我们也可以进行再git配置文件下，默认在用户目录.gitconfig\n1#全局代理 最好不用 2#[https] 3#\tproxy = https://127.0.0.1:8118 4#[http]\t 5#\tproxy = http://127.0.0.1:8118 6#http代理，端口自己改 7[http \u0026#34;https://github.com\u0026#34;] 8\tproxy = http://127.0.0.1:8118 9[https \u0026#34;https://github.com\u0026#34;] 10\tproxy = http://127.0.0.1:8118 11#sock5代理，感觉比http快很多 可能是错觉吧 12#[http \u0026#34;https://github.com\u0026#34;] 13#\tproxy = socks5://127.0.0.1:1080 14#[https \u0026#34;https://github.com\u0026#34;] 15#\tproxy = socks5://127.0.0.1:1080 感谢 https://www.zhihu.com/question/27159393 ","date":"2018-11-30","img":"","permalink":"https://helixs.github.io/posts/linux/2018-11-30-git-%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86-%E8%A7%A3%E5%86%B3%E8%AE%BF%E9%97%AEgithub%E7%AD%89%E8%AE%BF%E9%97%AE%E8%BF%87%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98/","series":null,"tags":null,"title":"Git 配置代理 解决访问github等访问过慢的问题"},{"categories":["vps工具"],"content":"下载并编译aria2 最新版本 1wget https://github.com/aria2/aria2/releases/download/release-1.34.0/aria2-1.34.0.tar.gz 2tar -zxvf aria2-1.34.0.tar.gz 3cd aria2-1.34.0 4 #安装GNU编译器套件  5yum install gcc* 6./configure 7make 8make install 9cd src 10cd src cp aria2c /usr/bin 新建aria2.conf配置文件 1vim /etc/aria2/aria2.conf 1# 文件的保存路径(可使用绝对路径或相对路径), 默认: 当前启动位置 2dir=/home/download 3# 启用磁盘缓存, 0为禁用缓存, 需1.16以上版本, 默认:16M 4#disk-cache=32M 5# 文件预分配方式, 能有效降低磁盘碎片, 默认:prealloc 6# 预分配所需时间: none \u0026lt; falloc ? trunc \u0026lt; prealloc 7# falloc和trunc则需要文件系统和内核支持 8# NTFS建议使用falloc, EXT3/4建议trunc, MAC 下需要注释此项 9#file-allocation=trunc 10# 断点续传 11continue=true 12 13#https 14#rpc-secure=true  15rpc-certificate=/etc/letsencrypt/live/xxxxxx/fullchain.pem 16rpc-private-key=/etc/letsencrypt/live/xxxxxxx/privkey.pem 17 18## 下载连接相关 ## 19 20# 最大同时下载任务数, 运行时可修改, 默认:5 21max-concurrent-downloads=5 22# 同一服务器连接数, 添加时可指定, 默认:1 23max-connection-per-server=8 24# 最小文件分片大小, 添加时可指定, 取值范围1M -1024M, 默认:20M 25# 假定size=10M, 文件为20MiB 则使用两个来源下载; 文件为15MiB 则使用一个来源下载 26min-split-size=10M 27# 单个任务最大线程数, 添加时可指定, 默认:5 28split=16 29# 整体下载速度限制, 运行时可修改, 默认:0 30#max-overall-download-limit=0 31# 单个任务下载速度限制, 默认:0 32#max-download-limit=0 33# 整体上传速度限制, 运行时可修改, 默认:0 34#max-overall-upload-limit=0 35# 单个任务上传速度限制, 默认:0 36#max-upload-limit=0 37# 禁用IPv6, 默认:false 38disable-ipv6=true 39 40## 进度保存相关 ## 41 42# 从会话文件中读取下载任务 43input-file=/etc/aria2/aria2.session 44# 在Aria2退出时保存`错误/未完成`的下载任务到会话文件 45save-session=/etc/aria2/aria2.session 46# 定时保存会话, 0为退出时才保存, 需1.16.1以上版本, 默认:0 47save-session-interval=60 48 49## RPC相关设置 ## 50 51# 启用RPC, 默认:false 52enable-rpc=true 53# 允许所有来源, 默认:false 54rpc-allow-origin-all=true 55# 允许非外部访问, 默认:false 56rpc-listen-all=true 57# 事件轮询方式, 取值:[epoll, kqueue, port, poll, select], 不同系统默认值不同 58#event-poll=select 59# RPC监听端口, 端口被占用时可以修改, 默认:6800 60#rpc-listen-port=6800 61# 设置的RPC授权令牌, v1.18.4新增功能, 取代 --rpc-user 和 --rpc-passwd 选项 62rpc-secret=passswwswssw 63# 设置的RPC访问用户名, 此选项新版已废弃, 建议改用 --rpc-secret 选项 64#rpc-user= 65# 设置的RPC访问密码, 此选项新版已废弃, 建议改用 --rpc-secret 选项 66#rpc-passwd= 67 68## BT/PT下载相关 ## 69 70# 当下载的是一个种子(以.torrent结尾)时, 自动开始BT任务, 默认:true 71#follow-torrent=true 72# BT监听端口, 当端口被屏蔽时使用, 默认:6881-6999 73listen-port=51413 74# 单个种子最大连接数, 默认:55 75#bt-max-peers=55 76# 打开DHT功能, PT需要禁用, 默认:true 77enable-dht=true 78# 打开IPv6 DHT功能, PT需要禁用 79#enable-dht6=false 80# DHT网络监听端口, 默认:6881-6999 81#dht-listen-port=6881-6999 82# 本地节点查找, PT需要禁用, 默认:false 83#bt-enable-lpd=false 84# 种子交换, PT需要禁用, 默认:true 85enable-peer-exchange=false 86# 每个种子限速, 对少种的PT很有用, 默认:50K 87#bt-request-peer-speed-limit=50K 88# 客户端伪装, PT需要 89peer-id-prefix=-TR2770- 90user-agent=Transmission/2.77 91# 当种子的分享率达到这个数时, 自动停止做种, 0为一直做种, 默认:1.0 92seed-ratio=0 93# 强制保存会话, 即使任务已经完成, 默认:false 94# 较新的版本开启后会在任务完成后依然保留.aria2文件 95#force-save=true 96# BT校验相关, 默认:true 97#bt-hash-check-seed=true 98# 继续之前的BT任务时, 无需再次校验, 默认:false 99bt-seed-unverified=true 100# 保存磁力链接元数据为种子文件(.torrent文件), 默认:false 101bt-save-metadata=true 102#强制加密, 防迅雷必备 103#bt-require-crypto=true 104 105bt-tracker=udp://tracker.coppersurfer.tk:6969/announce,udp://tracker.internetwarriors.net:1337/announce,http://tracker.internetwarriors.net:1337/announce,udp://tracker.opentrackr.org:1337/announce,udp://9.rarbg.to:2710/announce,udp://exodus.desync.com:6969/announce,udp://tracker.vanitycore.co:6969/announce,udp://explodie.org:6969/announce,http://tracker.vanitycore.co:6969/announce,http://explodie.org:6969/announce,udp://tracker1.itzmx.com:8080/announce,http://tracker1.itzmx.com:8080/announce,udp://ipv4.tracker.harry.lu:80/announce,udp://open.stealth.si:80/announce,udp://denis.stalker.upeer.me:6969/announce,udp://tracker.torrent.eu.org:451/announce,udp://tracker.tiny-vps.com:6969/announce,udp://tracker.port443.xyz:6969/announce,udp://retracker.lanta-net.ru:2710/announce,udp://open.demonii.si:1337/announce,http://tracker.port443.xyz:6969/announce,udp://zephir.monocul.us:6969/announce,udp://tracker.iamhansen.xyz:2000/announce,udp://thetracker.org:80/announce,http://tracker.city9x.com:2710/announce,http://torrent.nwps.ws:80/announce,udp://tracker.cypherpunks.ru:6969/announce,udp://tracker.cyberia.is:6969/announce,https://tracker.fastdownload.xyz:443/announce,https://opentracker.xyz:443/announce,http://tracker.cypherpunks.ru:6969/announce,http://opentracker.xyz:80/announce,http://open.trackerlist.xyz:80/announce,udp://tracker4.itzmx.com:2710/announce,udp://tracker2.itzmx.com:6961/announce,udp://tracker.uw0.xyz:6969/announce,udp://tracker.btsync.gq:233/announce,udp://pubt.in:2710/announce,http://tracker4.itzmx.com:2710/announce,http://tracker2.itzmx.com:6961/announce,http://tracker.torrentyorg.pl:80/announce,http://tracker.btsync.gq:233/announce,http://t.nyaatracker.com:80/announce,http://retracker.mgts.by:80/announce,http://open.acgnxtracker.com:80/announce,wss://tracker.openwebtorrent.com:443/announce,wss://tracker.fastcast.nz:443/announce,wss://tracker.btorrent.xyz:443/announce,wss://ltrackr.iamhansen.xyz:443/announce,udp://tracker.swateam.org.uk:2710/announce,udp://tracker.kamigami.org:2710/announce,udp://tracker.justseed.it:1337/announce,udp://torrentclub.tech:6969/announce,udp://packages.crunchbangplusplus.org:6969/announce,udp://amigacity.xyz:6969/announce,https://1337.abcvg.info:443/announce,http://tracker.tfile.me:80/announce.php,http://tracker.tfile.me:80/announce,http://tracker.tfile.co:80/announce,http://torrentclub.tech:6969/announce,http://share.camoe.cn:8080/announce,http://private.minimafia.nl:443/announce,http://prestige.minimafia.nl:443/announce,http://peersteers.org:80/announce,http://open.acgtracker.com:1096/announce,http://amigacity.xyz:6969/announce,http://agusiq-torrents.pl:6969/announce, 测试\n1aria2c --conf-path=/etc/aria2/aria2.conf 1#配置www权限 2vim /etc/sudoers 1 #root ALL=(ALL:ALL) ALL 这行下面添加上 2www ALL=NOPASSWD:/usr/bin/aria2c, /etc/aria2/aria2.conf 以www身份运行aria2\n1 sudo -u www aria2c --conf-path=/etc/aria2/aria2.conf -D 2#或者 3su - www -c aria2c --conf-path=/etc/aria2/aria2.conf -D 配置开机自启动：\n1vim /etc/rc.local 1#在 exit 0 前面加上 2sudo -u www aria2c --conf-path=/etc/aria2/aria2.conf -D 以上教程来自https://forum.cloudreve.org/d/87/14 配置成系统服务\n1vim /etc/init.d/aria2c 2---------- 3#!/bin/sh 4### BEGIN INIT INFO 5# Provides: aria2 6# Required-Start: $remote_fs $network 7# Required-Stop: $remote_fs $network 8# Default-Start: 2 3 4 5 9# Default-Stop: 0 1 6 10# Short-Description: Aria2 Downloader 11### END INIT INFO 12case \u0026#34;$1\u0026#34; in 13start) 14 echo -n \u0026#34;Starting aria2c\u0026#34; 15 /usr/local/bin/aria2c --conf-path=/etc/aria2/aria2.conf -D 16 ;; 17stop) 18 echo -n \u0026#34;Shutting down aria2c \u0026#34; 19 killall aria2c ;; 20restart) 21 killall aria2c 22 /usr/local/bin/aria2c --conf-path=/etc/aria2/aria2.conf -D 23 ;; 24esac 25exit 26 赋予aria2c文件可执行权限\n1chmod 755 /etc/init.d/aria2c 2service aria2c start 来自https://archive.ls12.me/centos-aria2c.html 如果遇到多用户权限问题可以这样操作https://www.jianshu.com/p/955e933eb191 ","date":"2018-11-21","img":"","permalink":"https://helixs.github.io/posts/linux/2018-11-21-aria2%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/","series":null,"tags":null,"title":"Centos7 Aria2 安装配置"},{"categories":["wordpress"],"content":"最近在学习linux基础，打算搭个blog做个笔记。因为练手的需要，在瓦工上租借了一年的VPS，毕竟是双十一特价\n (PS：国内环境太差了，1Mbps还贵的不行，还要传身份证备案，当初在百度云和华为云注册了一下，隔三差五给我来个电话，发营销短信，我也是受不了了。虽然我不是做WF的事情，国内的隐私已经不是隐私了)。\n  我装的系统是centos7，vps内存就那么点，就打算使用nginx替代apache了。又得知nginx主要是用来处理静态网页比较给力，对用php开发的wordpress是天生的不支持。所以就要通过nginx将php的动态请求转发到php-fpm解析器，处理完成后再通过nginx回馈给client，大概就是这个过程。\n看看wordpress官网 的最新版本，我下载的是4.9.8版本。然后开看看这个版本的最低环境要求 :\n PHP 7.2或更高版本。 MySQL 5.6或更高版本_或_ MariaDB 版本10.0或更高版本(内存怪兽)。 HTTPS 支持(这个看自己需求了)  1、安装php 7.x 安装phpCentos7仓库默认的版本还是php5.6，所有我们要找到php的最新源。 删除老的php版本\n1$ yum remove php* 2CentOS/RHEL 7.x: 3$ rpm -Uvh https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm 4$ rpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm 5$ yum install php70w 6$ yum install php70w php70w-fpm php70w-bcmath php70w-gd php70w-mbstring php70w-mcrypt php70w-mysql 7... 8软件包：php70w-mcrypt-7.0.32-1.w7.x86_64 (webtatic) 9需要：libmcrypt.so.4()(64bit) 10... 突然mcrypt属啥玩意儿不关，主要是libmcrypt.so.4()(64bit)这个玩意儿应该就是本机缺少了这个函数库了。\n1$ yum install libmcrypt libmcrypt-devel 2没有可用软件包 libmcrypt libmcrypt-devel。 3 4#搜索一下：基本都是复制粘贴一个东西：来安装epel源 5$ yum -y install epel-release 6Loading mirror speeds from cached hostfile 7* base: mirror.fileplanet.com 8* elrepo-kernel: repos.lax-noc.com 9* extras: mirror.fileplanet.com 10* updates: mirror.fileplanet.com 11* webtatic: us-east.repo.webtatic.com 12软件包 epel-release-7-11.noarch 已安装并且是最新版本 13无须任何处理 WTF，怎么这样。再搜索都是一样的爬虫复制粘贴结果。都是指向的 华中科技大学开源镜像站 网上基本都是找的5.x的源，然后翻翻翻找了epel-release-latest.rpm源\n1$ wget http://mirrors.hust.edu.cn/epel/epel-release-latest-7.noarch.rpm 2$ rpm -ivh epel-release-latest-7.noarch.rpm 3$ yum update 4$ yum install epel-release 5#MMP:软件包 epel-release-7-11.noarch 已安装并且是最新版本 6#怪事，可能是我新手吧，不懂这些依赖关系，干脆卸载重装 7$ yum remove epel-release 8$ yum install epel-release 9#再来 10$ yum install libmcrypt libmcrypt-devel 11#靠居然可以了。 12$ rpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm 13$ yum install php70w php70w-fpm php70w-bcmath php70w-gd php70w-mbstring php70w-mcrypt php70w-mysql php组件基本安装完成。\n2、安装数据库 我选择MariaDB 和MySql差不多的用法。和php一样。MariaDB在centos7中的默认源是与MySql(5.5)一致的5.5版本，看来我们又要添加新的源了。 MariaDB做的很好，很方便的把源信息分享出来，我们选择centos7(x86_64)的版本。 新建文件MariaDB.repo或者相似的，放入/etc/yum.repos.d/下面。然后使用vi粘贴源信息，如下面\n1# MariaDB 10.1 CentOS repository list – created 2018-11-12 10:07 UTC2# http://downloads.mariadb.org/mariadb/repositories/3[mariadb] name = MariaDB4baseurl = http://yum.mariadb.org/10.1/centos7-amd645gpgkey=https://yum.mariadb.org/RPM-GPG-KEY-MariaDB6gpgcheck=1修改完成后\n1$ yum install MariaDB-server MariaDB-client 2$ systemctl start mariadb 设置数据库\n1$ mysql\\_secure\\_installation 2# Enter current password for root (enter for none): 输入当前的root密码(默认空)，直接回车 3# Set root password? [Y/n] 设置新密码，y 4# Remove anonymous users? [Y/n] 移除匿名用户，y 5# Disallow root login remotely? [Y/n] 禁止root用户远程登录，y 6# Remove test database and access to it? [Y/n] 移除测试数据库，y 7# Reload privilege tables now? [Y/n] y 8$ mysql -u ‘数据库用户’ -p 9#因为是我用的是root所以就填的root了，然后输入数据库用户的密码就是你刚才设置的 10$ CREATE DATABASE wordpress (名字随意，初始化进入wordpress的时候是要选择这个的) 11$ exit 这样我们的数据库配置基本上就完成了\n3、配置wordpress+nginx+php-fpm 1$ yum install nginx 2#(版本自己选择) 3$ weget https://wordpress.org/latest.zip 4$ unzip wordpress-xxxxx.zip 5$ mv wordpress/* /usr/share/nginx/html/ 6#我放的是默认的nginx的html目录，其他的可以自己行放入 7#配置nginx  8$vi /etc/nginx/nginx.conf 配置nginx\n1server{2 listen 80 default_server;3 listen [::]:80 default_server;4 server_name _;5 root /usr/share/nginx/html6 index index.php index.html index.htm;7 # Load configuration files for the default server block.8 include /etc/nginx/default.d/*.conf;9 location ~ \\.php$ {10 try_files $uri =404;11 fastcgi_pass 127.0.0.1:9000;#主要是这个是php-fpm的默认端口地址12 fastcgi_index index.php;13 fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;14 include fastcgi_params;15 }16}wq保存\n配置php-fpm\n1 2$ cd /etc/php-fpm.d/ 3$ vi www.conf 4#我们找到user和group，默认是apache，所以我们改成nginx，以及lisen就用默认的 5:wq 6$ systemctl restart php-fpm 7$ systemctl restart nginx 8#如果都成功了我们就打开浏览器输入ip回车，没啥问题的话我们就可以看到wordpress的初始化配置，其主要的就是配置数据库，数据库名称就是我们刚才建立的数据库名称wordpress,用户名和密码是数据库的用户名和密码，我这里用的是root密码就是自己设置的密码。 9#如果出问题请检查数据库名称是否创建，数据库名称对应是否正确，用户名密码是否正确。 10#一切就绪之后我们创建了管理员账号和密码就一切OK了。 11#玩几下的时候发现更换出题或者写入文件的时候 12#wordpress 需要访问您网页服务器的权限。 请输入您的 FTP 登录XXXX 13#晕，怎么会这样，不会真的还要我创建ftp服务吧。不行google一下 14清一色的 15#1、chmod-R777 16#2、wp-config.php里加入下面代码: 17# define(“FS_METHOD”, “direct”); 18# define(“FS_CHMOD_DIR”, 0777); 19# define(“FS_CHMOD_FILE”, 0777); 20#才不行，想一下，wordpress没有写入权限，就说明wordpress网站目录的所有者不给予运行wordpress的php-fpm权限。 21$ ll /usr/share/nginx/html/ 22#目录的所有者是root，因为对linux的权限不是很清楚，所以我以为既然启动的nginx的用户是root，启动php-fpm的用户也是root，不会出现这个问题啊。那么我们还是查看进程吧 23$ ps aux|grep nginx 24$ ps aux|grep php-fpm 25#他们的主进程用户的确是root 26#然后发现php-fpm子进程中多了很多的nginx用户，对了。我们不是在www.conf中指定用户和用户组是nginx吗，那么网站的目录的所有者是root，nginx用户子进程的确是写入root用户的目录的，所以我们把目录所有者指定给nginx 27$ chown -R nginx /usr/share/nginx/html 28#对我一个小白来说一个wordpress网站基本就搭完成了。 对我一个小白来说一个wordpress网站基本就搭完成了。\n感谢 https://blog.csdn.net/notebook034/article/details/51584993 ","date":"2018-11-12","img":"","permalink":"https://helixs.github.io/posts/linux/2018-11-12-wordpress+nginx%E6%90%AD%E5%BB%BA%E5%85%A8%E8%BF%87%E7%A8%8B/","series":null,"tags":null,"title":"WordPress+Nginx搭建全过程"},{"categories":["linux常用配置"],"content":"防火墙 启动防火墙\n1 systemctl start firewalld 关闭防火墙\n1systemctl stop firewalld 查看防火墙状态\n1systemctl status firewalld 开机禁用防火墙\n1systemctl disable firewalld 开机启用防火墙\n1systemctl enable firewalld 开放指定端口 1firewall-cmd --zone=public --add-port=80/tcp --permanent 关闭指定端口\n1firewall-cmd --zone=public --remove-port=80/tcp --permanent 重启防火墙 1firewall-cmd --reload –zone 作用域\n–add-port=80/tcp 添加端口，格式为：端口/通讯协议\n–permanent 永久生效，没有此参数重启后失效\n查看防火墙规则 1firewall-cmd --list-all 查看开放端口\n1firewall-cmd --list-ports  SSH 1vim /etc/ssh/sshd_config 找到下面 Port 大部分默认端口为22 改成你想要的端口如 1234\n保存 :wq\n1systemctl restart sshd 部分云机器上会出现下面这种错误\nJob for sshd.service failed because the control process exited with error code. See \u0026quot;systemctl status sshd.service\u0026quot; and \u0026quot;journalctl -xe\u0026quot; for details.\n执行\n1journalctl -xe 可能会出现 error: Bind to port 1234 on 0.0.0.0 failed: Permission denied. May 29 11:06:10 MyCloudServer sshd[8742]: error: Bind to port 1234 on :: failed: Permission denied.\n搜了一下是selinux安全策略搞鬼，可能是限制了ssh的端口号\n1semanage port -l | grep ssh 1#得到了限制的ssh端口号是22 果然没错 2ssh_port_t tcp 22 将端口号添加到selinux规则里面\n1semanage port -a -t ssh_port_t -p tcp 1234 2semanage port -l | grep ssh ssh_port_t tcp 1234, 22\n重启sshd\n1systemctl restart sshd 看看是不是成功了呢。\n如果找不到semanager执行下面后，在进行上面的操作\n1yum provides semanage 2yum install policycoreutils-python.x86_64 3#查询selinux是否是enable的状态 4/usr/sbin/sestatus -v ","date":"2018-10-30","img":"","permalink":"https://helixs.github.io/posts/linux/2018-10-31-centos7-%E9%98%B2%E7%81%AB%E5%A2%99%E7%AB%AF%E5%8F%A3%E9%85%8D%E7%BD%AE%E5%92%8Cssh%E7%AB%AF%E5%8F%A3%E9%85%8D%E7%BD%AE-/","series":null,"tags":null,"title":"Centos7 防火墙端口配置和SSH端口配置"},{"categories":null,"content":"","date":"0001-01-01","img":"","permalink":"https://helixs.github.io/contact/","series":null,"tags":null,"title":"联系我们"}]