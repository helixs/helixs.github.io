[{"categories":["flutter","编程生活"],"content":"公司这段时间新建了一个网站项目，因为是新项目，选择技术栈来说是比较值得探讨的问题，因为前端缺人，本身我们组又是移动应用开发为主，虽然前端也会，毕竟不是一直从事前端开发，不能那么快速将项目上线。刚好前不久Flutter2.0发布了，FlutterWeb也开启了正式之路，然后我就跟同事们说要不就用这玩意儿吧，来吃肉(填坑？)。然后大家就欣然同意。\nFlutterWeb实现原理基本上和移动应用一个道理，默认情况下都是使用的调用Canvaskit+skia引擎调用WebGL实现绘制。也可以使用html+css+canvas进行渲染，这样少了Skia引擎，会让包大小少2mb左右，不过展示的样式可能就是根据浏览器默认渲染的方式进行了，差别还是蛮大的。\n1、使用默认Canvaskit渲染方式，会在打开应用之初加载字体1秒钟内，出现中文字体乱码问题！！！关于这个问题，我们暂时智能使用html的方式进行官方目前还没有什么有效的解决方式，问题在这里https://github.com/flutter/flutter/issues/73628 出现问题的主要原因是，自绘引擎需要字体库支持，FlutterWeb 默认会使用Noto字体，因为一般电脑上都不会带有这个字体，所以会在线寻找这个字体，比如google或者一些第三方字体库网站，导致加载缓慢和乱码。当然还有办法可以解决这个问题，就是将字体放到本地资源库，比如将Noto字体作为默认字体一起打包到web网站上，下载速度就快了很多,你也可以换一些自己的中文字体(注意版权问题)，不会出现乱码情况。坏处就是还是会增加一些服务器的负担。\n 2、应用体积过大，我们大概做了十几个页面吧，打包下来最后会生成main.dart.js文件，搞下来已经7mb了，而且没办法拆分，意思就是你打开这个网站就等于加载了几乎整个应用渲染逻辑！更意味着打开网站下载js，执行js，渲染js 是你不得不面对的三道速度墙！记得如果你真的要用它，放到生产环境时候要给nginx或者其他方式实现brotli或者gzip压缩来减少传输时间！当然官方现在也没有很好的解决办法来如何拆分它！https://github.com/flutter/flutter/issues/46589 3、因为FlutterWeb是自绘引擎，默认是不支持文字选中和复制了，如果你需要文字选中和复制需要使用SelectableText ，从体验上来讲，还是有那么不太舒服哦，跟原生Web标准还是差很多。如果你的网页需要允许用户进行大量的复制操作，请谨慎尝试。\n4、如果你的网页需要提高标签值被爬的难度，那么它可能是比较好的一个办法，一堆js等着你去解析吧。\n问题待续….\n根据上面的信息，我大概确定的是它目前定位基本上和nativeApp一个级别的WebApp，也可以直接生成webApp应用给浏览器保留，所以他不合适用来做很多传统的WebPage应用了。\n","date":"2021-04-27","img":"","permalink":"https://helixs.github.io/posts/2021-04-27-flutter-web%E4%BD%BF%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BF%83%E5%BE%97%E5%92%8C%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/","series":null,"tags":null,"title":"Flutter Web使用的一些心得和一些问题"},{"categories":["闲聊"],"content":" \u0026lt;p\u0026gt; 美国人从未在他们公开的国家战略中谈论过这个话题。据说，上一任美联储主席格林斯潘就职当天，就曾告诫他的同僚：在这里（美联储）你们可以谈论一切，就是不许谈论美元。这是禁忌，美国人对这一关乎美国国家生存的话题讳莫如深。 \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; 美国人在过去40年里，找到了一种在他们看来是最好的，也最便捷的国家生存方式，那就是用金融手段从全球向美国转移财富。美国人发现自己可以不用生产其他的产品，只生产一样东西就可以致富，就可以过得比世上所有人都好，这个方式就是印刷美元。 \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; 从罗马帝国到大英帝国，基本上都是以一种相似的方式完成帝国积累财富、消耗财富的过程。这种方式是什么呢？就是占领别国的领土，掠夺别国的资源，奴役别国的人民。这就是经典的殖民帝国模式。但是两次世界大战的教训，使美国意识到，必须避免重蹈古典帝国模式的覆辙。因为一次大战德国向老牌殖民帝国挑战，想要获取自己的生存空间，结果失败了。20多年后德国再度崛起，再次向老牌殖民帝国发起挑战，又再度失败了。美国毫无疑问记取了这个历史教训：如果一个国家的崛起，一定要从老牌殖民帝国那里虎口夺食的话，就不可避免地会发生战争，而其结果只能是两败俱伤，最后徒使他人得利。美国就是两次大战最大的获利者。 \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; “布雷顿森林体系”的实质：全世界的货币锁定美元，而美元锁定黄金。美国政府向全世界承诺，每35美元可以兑换一盎司黄金，那个时候的美国可以说是志得意满，因为这个时候的美国有世界上最大的黄金储备，世界上80%的黄金都捏在美国人手里，与此同时，美国还拥有世界上最强大的生产能力和军事机器。 \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; 没有足够多的黄金你就不能印足够多的美元！因为你对全世界有承诺，你是全世界的基准货币，你必须保持美元的稳定。这使美国陷入了空前的窘境。 1\u0026lt;b\u0026gt;\u0026lt;i\u0026gt;971年8月15日，当时的美国总统尼克松宣布：美元跟黄金脱钩。这一失信之举意味着美国可以不受黄金的羁绊，随意加印美元了。\u0026lt;/i\u0026gt;\u0026lt;/b\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; 半年后，研究报告《黄金非货币化的影响》出炉。这份具有良知的报告中提醒美国政府，美元跟黄金脱钩，在短时间内对美国有好处，因为美国可以在全世界还没回过神来时多印钞票，用没有黄金背书的纸币去占全世界的便宜。但长期看，这对美国和全世界都决不是什么好事，尤其对美国，无疑是饮鸩止渴。 \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; 而美国政府俨然如醍醐灌顶，大彻大悟！他们根本不理会作者迈克尔·赫德森的警告，对报告反其意而用之。既然这么干短期对美国有好处，干吗不把它变成一个长期的好处，让美国人永久享用呢？当然，这首先需要与黄金脱钩后完全变成一张绿纸的美元，在全世界面前，仍然保持它的信用。这就意味着美元必须保持它的霸权地位。\u0026lt;b\u0026gt;\u0026lt;i\u0026gt;怎样才能保持美元的霸权地位呢？美国政府认为最重要的是两根支柱，一根是美国强大的科技创新力。另一根是美国强大的军事实力。\u0026lt;/i\u0026gt;\u0026lt;/b\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; 但美国人知道，与黄金脱钩后的美元，最好与世界上最重要的大宗商品挂钩，才能确保美元的地位稳如磐石。机会很快就来了。1973年的10月6日，第四次中东战争爆发。一开始，\u0026lt;a class=\u0026quot; wrap external\u0026quot; href=\u0026quot;https://link.zhihu.com/?target=https%3A//www.baidu.com/s%3Fwd%3D%25E5%259F%2583%25E5%258F%258A%25E4%25BA%25BA%26tn%3D44039180_cpr%26fenlei%3Dmv6quAkxTZn0IZRqIHckPjm4nH00T1Y3nvcknhnsP1mvrHDvuW0s0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3EPH6zrHfzP16kPWfkrjDdPW0d\u0026quot; target=\u0026quot;_blank\u0026quot; rel=\u0026quot;nofollow noopener noreferrer\u0026quot; data-za-detail-view-id=\u0026quot;1043\u0026quot;\u0026gt;埃及人\u0026lt;/a\u0026gt;和叙利亚人两线出击，打了\u0026lt;a class=\u0026quot; wrap external\u0026quot; href=\u0026quot;https://link.zhihu.com/?target=https%3A//www.baidu.com/s%3Fwd%3D%25E4%25BB%25A5%25E8%2589%25B2%25E5%2588%2597%26tn%3D44039180_cpr%26fenlei%3Dmv6quAkxTZn0IZRqIHckPjm4nH00T1Y3nvcknhnsP1mvrHDvuW0s0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3EPH6zrHfzP16kPWfkrjDdPW0d\u0026quot; target=\u0026quot;_blank\u0026quot; rel=\u0026quot;nofollow noopener noreferrer\u0026quot; data-za-detail-view-id=\u0026quot;1043\u0026quot;\u0026gt;以色列\u0026lt;/a\u0026gt;一个措手不及，但不久后战况逆转，\u0026lt;a class=\u0026quot; wrap external\u0026quot; href=\u0026quot;https://link.zhihu.com/?target=https%3A//www.baidu.com/s%3Fwd%3D%25E4%25BB%25A5%25E8%2589%25B2%25E5%2588%2597%26tn%3D44039180_cpr%26fenlei%3Dmv6quAkxTZn0IZRqIHckPjm4nH00T1Y3nvcknhnsP1mvrHDvuW0s0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3EPH6zrHfzP16kPWfkrjDdPW0d\u0026quot; target=\u0026quot;_blank\u0026quot; rel=\u0026quot;nofollow noopener noreferrer\u0026quot; data-za-detail-view-id=\u0026quot;1043\u0026quot;\u0026gt;以色列\u0026lt;/a\u0026gt;反占上风。这让阿拉伯世界非常郁闷。坐拥石油的阿拉伯人决定，在战场上得不到的东西，就从其他地方去获得。于是，欧佩克——国际石油输出国组织——决定用石油做武器，抬高油价打击西方。这个办法果然比战争来得更有效，很快西方就承受不住了。 \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; 这时，美国当时的财政部长西蒙秘密地飞到了沙特，去见沙特的石油大臣，也是首任欧佩克秘书长，告诉他：你们想把油价打多高我们不管， 但是要想不让美国人与你们为敌，你们必须接受一个条件，就是\u0026lt;b\u0026gt;\u0026lt;i\u0026gt;全球的石油交易用美元结算\u0026lt;/i\u0026gt;\u0026lt;/b\u0026gt;。这位沙特的石油大臣与整个世界一样，对美国人这一招棋的深远机心并不了然，于是就一口答应了美国人的要求，从此，全世界的石油交易与美元挂钩，而美元的信用也就在此后40年里，牢牢地与全球的能源需求挂上了钩。 \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; 走到这一步，美国人设计出的这个新型帝国渐渐开始显现出轮廓，这就是人类帝国史上从未出现过的金融殖民帝国。美国人发现，比起当年德国人虎口夺食去争取一个国家的生存空间这种愚蠢做法来，更高明的办法，应该是通过让世人几乎觉察不到的方式，乖乖地让他们把手中财富交出来，而又不制造仇恨。要达此目的，没有比金融殖民更好的办法了，这办法可以把全世界都纳入美国的金融体系中，然后，像拧开自来水水龙头一样让财富滚滚流入美国人的口袋。 \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; 美国人用比较优势理论把全世界分成了两块，一块是美国，美国人认为它的优势就在于生产美元；另一块是全世界。全世界的优势在哪儿呢？比如，中国人，你的比较优势就在于你有大量的廉价劳动力。由美国人作为一方，全世界作为另一方，由美国人负责生产美元，而全世界负责生产用美元交换的产品，这就是美国人主导的全球产业大分工的本质，从此，全球化浪潮席卷全球。 \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; 美国用自己的金融体系，把全世界与美国紧紧捆绑在一起，这种由美国向世界输出美元，而世界向美国提供产品的交易模式，其结果就是全球财富快速向美国集中，这也就是美国在1990年前的200多年里，GDP最高时才不过达到7万亿美元，而在最近的短短20年里，GDP居然翻了一番，达到14万亿的根本原因。当然，美国人比全世界都清楚，用这种方式聚敛的财富，仅仅靠全球产业大分工是不够的，甚至再加上石油与美元挂钩也还不够，还需要一个非常强有力的手段，如果没有这个手段，美国不足以从世人手中掠走那么多的财富，而这个手段就是天下第一的军事实力。 \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; \u0026lt;b\u0026gt;\u0026lt;i\u0026gt;美国人为什么要打伊拉克战争？答曰：为了石油。\u0026lt;/i\u0026gt;\u0026lt;/b\u0026gt;那么，接下来的问题是：为什么美国占领伊拉克后，却不从伊拉克免费拉走一桶石油？当美国打下伊拉克时，首先出现的是什么情况？全球油价飙升。油价飙升，交易又以美元结算，意味着什么呢？意味着油价的飙升拉高了全球的美元需求，也就是说，\u0026lt;b\u0026gt;\u0026lt;i\u0026gt;美国人通过战争打出了全球的美元需求\u0026lt;/i\u0026gt;\u0026lt;/b\u0026gt;。打伊拉克战争之前，一桶石油38美元，打完了之后接近150美元，等于一场战争把美元的需求打高了近三倍。这样一来，美国政府就能以给全世界提供流动性的名义，开动印钞机，印刷更多的美元，而美国政府不是慈善家，不会白白把美元给你，你必须拿你的产品去换，从而再一次加入实物换绿纸的游戏。此时美国政府的印钞行为可以说名正言顺。更多的美元流到了其他国家的手里，流到了产油国的手里，也流到了需要购买石油的国家手里。 \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; 这么多美元攥在这些国家手里能干什么呢？除了作为财富的符号让人开心外，就是变为废纸的前景让人担心，因为美元正以日新月异的速度在贬值，天天在贬值，天天都在变成废纸，这个时候\u0026lt;b\u0026gt;\u0026lt;i\u0026gt;你唯一的选择，就是美国人早就为你准备好的选择：购买美国的国债。\u0026lt;/i\u0026gt;\u0026lt;/b\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; 购买美国国债使巨量的美元回流美国，也使美国成了全世界最大的债务国。那么，美国为什么需要让流向全世界的美元，再以购买美国国债的方式回流美国呢？一个几乎没有储蓄率的美国，必须始终保持资本项目的顺差，而这个顺差的额度在2001年前后的时候，大约是每年7000亿美元左右，也就是说，需要每天净流入美国20亿美元。因此，美国需要大量的世界资本回流美国，大部分美国人刷卡透支的好日子才能为继， \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; 为了保持资本项下的顺差，美国会不惜动用战争手段，去打坏别国、别的地区的投资环境，像驱赶羊群一样，把美元驱赶回美国。所以说，表面上看，两次伊拉克战争都和石油有关，但实际上主要是和美元有关。因为只要在产油区打仗，油价就会上升，美元的需求也就会随之上升。如此一来，美国人就可以开动印钞机，印更多的美元，从全球换回更多的实物财富，道理就这么简单。 \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; 美国打科索沃的真正动机到底是什么？这场战争发生的时间是1999年3月，但耐人寻味的是，1999年1月1日，发生了另一个重大事件：欧元正式启动。当时欧元和美元的汇率是1∶1.07，\u0026lt;b\u0026gt;\u0026lt;i\u0026gt;欧元作为一种全新的国际结算货币，一上来就对美元霸权地位构成了挑战和威胁。\u0026lt;/i\u0026gt;\u0026lt;/b\u0026gt;仅仅两个月后，科索沃战争打响。战争还没结束，世人便发现，深受战争创伤的，不光是南联盟，还有欧元。有欧盟各国空军做帮手的72天的狂轰滥炸，其最重要的结果，不光是米洛舍维奇政权的垮台，还有欧元与美元汇率的倒挂，由1欧元兑换1.07美元，变为0.82美元兑换1欧元，欧元跌幅达30%。由此可以看出，美国人打科索沃战争是“项庄舞剑，意在‘欧元’”。 \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; 结果，战争一打响，7000多亿热钱中有4000多亿立刻从欧洲抽逃，其中2000多亿去了美国，直接支持了美国已经连续90多个月的经济繁荣。美国历史上还从来没有过如此漫长的经济增长期。 \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; 另外的2000多亿则去了香港，香港怎么可能在短时间内消化这么多钱？显然是那些投资人或投机家，看好中国内地市场，想拿香港做跳板，进入中国内地。让人备感蹊跷的是，恰在这个时候不早不晚发生了一件震惊世界的事情，美国人用5枚精确制导炸弹，“误炸”了中国驻南联盟大使馆。一个星期之后，滞留香港的2000多亿热钱从香港抽逃，最后去了哪儿呢？又去了美国，4000多亿热钱全部流到了美国，去支持美国已经连续90多个月的经济繁荣。 \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; “9·11”发生之后两个月不到，美国就打响了阿富汗战争，这完全不符合美国打一场局部战争的战争准备规律。1980年之后，美国人连打了四场战争，除阿富汗战争之外另外的三场战争，美国人的战争准备时间都在半年左右，这意味着美国打一场局部战争需要半年的准备，但是阿富汗战争却是个例外，不到两个月就仓促打响。 \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; 因为这个时候正是“9·11”发生之后不久，大量的资金开始撤离美国。因为全球的投资人突然对全世界最安全的投资环境——美国产生了疑虑。美国是全球的金融中心，纽约是美国的金融中心，而华尔街是纽约的中心，世贸大厦则是中心的中心。现在，这个中心的中心居然让恐怖分子给撞毁了，谁还敢对你的投资环境保持信心呢？于是，从这时起，据说有三四千亿美元撤离了美国，前面提到美国每年需要吸纳大约7000多亿美元的净流入，这个时候有三四千亿美元撤离美国，而这一年还有几个月的日子要过，没有钱怎么行？所以美国迫切需要一场战争，需要用一场战争，打回全世界投资人对美国的信心。 \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; 果然如此，当阿富汗战争打响之后，巡航导弹一落在阿富汗的土地上，道琼斯指数就在短期下探后很快回升，华尔街一片叫好，随着战况进展顺利，大量撤离的资金又陆续回到了美国，这场战争重新打回了全世界对美国投资环境的信心。 \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; \u0026lt;b\u0026gt;美国人向全世界展示的现代战争理念是，如果我的投资环境不好而短期内又无法改变的话，那我就用战争把其他地方打得更坏，反衬出美国相对的好。你不是认为我的投资环境不安全吗？那我就打一场战争给你看，美国仍然是最强大的，美国人想打谁就打谁，你要觉得美国的投资环境不安全，还有别的地方比我更不安全，那个地方还在发生战争。这就是美国的军事力量如何为它的金融大战略服务。\u0026lt;/b\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; 过去，美国人喜欢说，当世界上什么地方出现麻烦，美国总统的第一反应就是：我们的航空母舰在哪里？现在这种说法正在逐渐成为过去时。当互联网把全球连成一个整体，网上交易、网上支付已成家常便饭，随便敲几下键盘，成百亿、上千亿甚至数万亿的美元，就可以在瞬间完成转移或者是抽逃时，这种几乎以光速运行的资本流动，是每小时以三四十节的速度航行的航空母舰无法跟上的。即便是以超音速飞行的舰载机，也同样跟不上。 \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; 为此，五角大楼对其军事力量提出了新的要求：尽快建立“全球快速打击系统”。这一系统要求美军的军事打击能力，能比航母为代表的传统军事手段更快捷地打击地球上任何目标，打击时限也一再缩短，从号称一小时打遍全球，缩短到28分钟打遍全球。意义就在于，它基本上可以跟上资本流动的速度了。 \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; 做出上述一系列（军事开支）压缩之举的同时，我们会看到五角大楼的另一些耐人寻味的举措：比如说建立空天司令部，比如说建立全球第一支网军，又比如说全球第一架空天飞机的试飞，再比如说正在研发的5倍于音速的巡航导弹……所有这些，又都在向我们传递与前述信息相反的信息，那就是五角大楼比以往任何时候都更注重美军的速度——从部署的速度到打击的速度，而这一切，都与资本的流速和流向有关，因为\u0026lt;b\u0026gt;美国人心里最清楚：\u0026lt;i\u0026gt;今天的美国是一个建立在纸币上的帝国。要让这个帝国不垮塌，就必须保持美元的霸权，现在，要做到这一点，除了军事手段，美国人手上似乎已没有其他什么管用的家伙了。\u0026lt;/i\u0026gt;\u0026lt;/b\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; \u0026amp;nbsp; \u0026lt;/p\u0026gt;  ","date":"2021-04-19","img":"","permalink":"https://helixs.github.io/posts/2021-04-19-%E7%BE%8E%E5%9B%BD%E5%8F%91%E5%8A%A8%E4%BC%8A%E6%8B%89%E5%85%8B%E6%88%98%E4%BA%89%E7%9A%84%E4%B8%80%E7%A7%8D%E7%8C%9C%E6%83%B3/","series":null,"tags":null,"title":"美国发动伊拉克战争的一种猜想"},{"categories":["数据库","编程生活"],"content":"启动远程连接\n红色部分是用户名和远程登录的密码，和本地密码不同。\n ","date":"2021-04-02","img":"","permalink":"https://helixs.github.io/posts/2021-04-02-mariadb%E5%AE%89%E8%A3%85%E8%AE%BE%E7%BD%AEroot%E5%AF%86%E7%A0%81/","series":null,"tags":null,"title":"Mariadb安装设置root密码"},{"categories":["数据结构和算法"],"content":"跟hashMap的区别就是所有node节点增加了after和before属性 形成了双向链表，通过牺牲空间来保证有序性。\n","date":"2021-03-30","img":"","permalink":"https://helixs.github.io/posts/2021-03-30-linkedhashmap%E5%9B%BE%E8%A7%A3/","series":null,"tags":null,"title":"LinkedHashMap图解"},{"categories":["LeetCode","数据结构和算法","编程生活"],"content":" 链接：https://leetcode-cn.com/problems/two-sum\n我的第一想法 双循环\n再看看大神\n 看到没，循环只有一次，通过每次预推断补数，就直接下个循环判断有没有就行了。\n","date":"2021-03-26","img":"","permalink":"https://helixs.github.io/posts/2021-03-26-leetcode%E4%B9%8B%E5%9C%A8%E6%95%B0%E7%BB%84%E4%B8%AD%E8%AE%A1%E7%AE%97%E6%9F%90%E4%B8%AA%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%92%8C%E7%AD%89%E4%BA%8E%E7%9B%AE%E6%A0%87%E5%80%BC/","series":null,"tags":null,"title":"LeetCode之在数组中计算某个两个数和等于目标值"},{"categories":["Android开发","编程生活"],"content":"进行Android开发我们经常遇到一些依赖冲突，以及库版本号不一致导致出现各种问题。往往就下面这张图只是看到了你所有的依赖项，并不知道这些依赖都是从哪里来的，除非你进去一个个查看pow.xml那么蠢了。\n                       看了半天也不知道是从哪里依赖的。\n有个简单的方法，打开gradle工具，找到项目下如app模块-\u0026gt;Tasks-\u0026gt;help-\u0026gt;dependencies-\u0026gt;双击                         那么他会执行 :app:dependencies命令,会打印出依赖项及子依赖项\n                      往上说的那些什么插件的都是老方法了，新版的studio没办法直观反映\n还有别的一些方法可以试一试https://blog.csdn.net/songjianzaina/article/details/98175098 ","date":"2021-02-19","img":"","permalink":"https://helixs.github.io/posts/2021-02-19-androidstudio%E9%80%9A%E8%BF%87gradle%E6%9F%A5%E7%9C%8B%E7%AC%AC%E4%B8%89%E6%96%B9%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB/","series":null,"tags":["android","gradle"],"title":"AndroidStudio通过Gradle查看第三方依赖关系"},{"categories":["图像及视频资料","百科资料库"],"content":"本人对图像和视频知识方面基本上是个小白，饶有兴致的看看资料，把觉得有用的东西记录下来，资料均为网上收集。\n视频技术的实践介绍：图像、视频、编解码器（av1、vp9、h265）等（ffmpeg编码） 有多语言翻译。https://github.com/leandromoreira/digital_video_introduction 拜耳阵列\nhttps://www.cnblogs.com/morikokyuro/p/13256701.html https://zh.wikipedia.org/wiki/%E6%8B%9C%E7%88%BE%E6%BF%BE%E8%89%B2%E9%8F%A1 RGB和YUV关系和区别\nhttps://blog.csdn.net/asahinokawa/article/details/80596655 https://www.cnblogs.com/yunlambert/p/11234971.html https://www.cnblogs.com/justkong/p/6570914.html YUV 420 444 421 422 如何理解\nhttps://blog.csdn.net/xueyushenzhou/article/details/40817949 视频编码中的I/P/B帧\nhttps://www.cnblogs.com/yongdaimi/p/10676309.html https://blog.csdn.net/abcjennifer/article/details/6577934 ","date":"2021-02-09","img":"","permalink":"https://helixs.github.io/posts/2021-02-09-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E5%9B%BE%E5%83%8F%E5%8F%8A%E8%89%B2%E5%BD%A9%E7%94%9F%E6%88%90%E5%8E%9F%E7%90%86/","series":null,"tags":null,"title":"计算机中图像视频及色彩生成原理"},{"categories":[],"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution  Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\n Blockquote with attribution  Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.— Rob Pike1 Tables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\n   Name Age     Bob 27   Alice 23    Inline Markdown within tables    Italics Bold Code     italics bold code    Code Blocks Code block with backticks 1\u0026lt;!doctype html\u0026gt; 2\u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; 3\u0026lt;head\u0026gt; 4 \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; 5 \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; 6\u0026lt;/head\u0026gt; 7\u0026lt;body\u0026gt; 8 \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; 9\u0026lt;/body\u0026gt; 10\u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1\u0026lt;!doctype html\u0026gt; 2\u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; 3\u0026lt;head\u0026gt; 4 \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; 5 \u0026lt;title\u0026gt;Another Example HTML5 Document\u0026lt;/title\u0026gt; 6\u0026lt;/head\u0026gt; 7\u0026lt;body\u0026gt; 8 \u0026lt;p\u0026gt;A looooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooong text\u0026lt;/p\u0026gt; 9\u0026lt;/body\u0026gt; 10\u0026lt;/html\u0026gt; List Types Ordered List  First item Second item Third item  Unordered List  List item Another item And another item  Nested List  Fruit  Apple Orange Banana   Dairy  Milk Cheese    TODO List  Done WIP  Other Elements — abbr, sub, sup, kbd, mark GIFis a bitmap image format.\nH2O\nXn+ Yn= ZnPress CTRL+ALT+Deleteto end the session.\nMost salamandersare nocturnal, and hunt for insects, worms, and other small creatures.\n  The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","date":"2020-11-09","img":"https://helixs.github.io/images/markdown.png","permalink":"https://helixs.github.io/posts/markdown-syntax/","series":["Manual"],"tags":["Markdown","CSS","HTML"],"title":"Markdown Syntax Guide"},{"categories":["Android开发"],"content":"有这么一个需求，一个列表要满足一个条件\n1、列表少于等于5条，列表的高度跟随item的数量变化而变化\n2、如果超过5条，按照最大5条的高度显示，并支持滚动\n所以基本的由于item高度不能定死，所以支持设置recyclerView高度是wrap_content\n然后具体操作看了下源码，大部分计算都是在LayoutManager中，找到这里\n主要是通过这个方法测量子控件叠加的高度，方法居然给我是私有的，没办法继承，不然我就直接控制循环数量了。转而求其次，实现setMeasuredDimension方法\n哈哈，是不是超级简单，具体用法\n ","date":"2020-05-08","img":"","permalink":"https://helixs.github.io/posts/2020-05-08-android_recyclerview%E8%AE%BE%E7%BD%AE%E6%9C%80%E5%A4%A7%E6%95%B0%E9%87%8F%E9%AB%98%E5%BA%A6/","series":null,"tags":null,"title":"Android_RecyclerView设置最大数量高度"},{"categories":["Android开发","源码分析","编程生活"],"content":"Retrofit是原Square大神JakeWharton面向Android和Java平台的http客户端。\n那么我们常用的Retrofit+Okhttp的关系是什么呢？其实Retrofit需要依赖Okhttp，就如同Okhttp依赖OkIO一样，Retrofit当使用Http请求时候方面了我们的结构化配置。\nOkhttp：\nAndroid为我们提供了两种HTTP交互的方式：HttpURLConnection和Apache HTTP Client（ Android 6.0——API 23已经不支持该方式了 ），虽然两者都支持HTTPS，流的上传和下载，配置超时IPv6和连接池，已足够满足我们各种HTTP请求的需求。但更高效的使用HTTP可以让我们的应用运行更快、更节省流量。这就诞生了Okhttp及Retrofit等HTTP库。OKHttp是一款高效的HTTP库，支持连接同一地址的链接共享同一个socket，通过连接池来减小响应延迟，还有透明的GZIP压缩，请求缓存等优势。OkHttp存在以下的特点：\n 支持HTTP2/SPDY socket自动选择最好路线，并支持自动重连 拥有自动维护的socket连接池，减少握手次数 拥有队列线程池，轻松写并发 拥有Interceptors轻松处理请求与响应（比如透明GZIP压缩,LOGGING） 基于Headers的缓存策略  Retrofit:retrofit就是对okhttp做了一层封装。把网络请求都交给给了Okhttp，我们只需要通过简单的配置就能使用retrofit来进行网络请求了。Retrofit框架存在的优势：\n Retrofit使用注解方式，大大简化了我们的URL拼写形式，而且注解含义一目了然，简单易懂； Retrofit使用简单，结构层次分明，每一步都能清晰的表达出之所以要使用的寓意； Retrofit支持同步和异步执行，使得请求变得异常简单，只要调用enqueue/execute即可完成； Retrofit更大自由度的支持我们自定义的业务逻辑，如自定义Converters。 Retrofit支持多种文件解析(Gson,Json,XML,Protobuf) Retrofit支持RxJava  我们来看如何使用\n基于com.squareup.retrofit2:retrofit:2.8.1.\n看到没，是不是很方便呢，我们只需配置一个baseUrl，放置一个接口配置清单，我们就可以进行简单的网络请求了。\n分析源码\n下面这张图是Retrofit常用依赖包\n    adapter和converter根据自己实际情况进行调整\n看看retrofit的东西，哟，不是很多，说明我们看它更加容易\n                http下面都是一堆注解，什么http方法 HEAD QUERY 等等非常丰富，retrofit运行过程中会反射获取这些类型再进行合理的封装。\n看看Retrofit中的成员变量\nRetrofit的Builder模式初始化\n在1和2中我们看到了使用平台\nPlatform里面的东西其实不多，就是Callback的执行器和一些跟JAVA8特性相关，跟Retrofit核心关系不是很大。\ncreateSerivce\n这里面用到了动态代理模式，可以学习一下。\n下面我们就来看看ServiceMethod是怎么获取的\n1、RequestFactory\n2、HttpServiceMethod\n我们生成了RequestFactory后就马上调用了 HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory);\n在1中createCallAdapter最终遍历callAdapaterFactorys 获取合适的Adapter ，比如获取的是DefautCallFactory\n 最终不管是Call对象还是RxJava的Obserable对象都通过它获取了，进入最后的调用过程，拿默认的ExecutorCallbackCall来说\n它们最终都会进入这里，调用OkhttpCall\n Retrofit用了丰富的工厂用来动态的获取不同的CallAdapter和RequestConvert，ResponseConvert。代理模式生成Api实现类。反射在这里用的恰到好处。\n ","date":"2020-04-26","img":"","permalink":"https://helixs.github.io/posts/2020-04-26-android%E6%BA%90%E7%A0%81%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8Bretrofit/","series":null,"tags":null,"title":"Android源码一步一步分析系列之Retrofit"},{"categories":["源码分析"],"content":"终于来到了最后一个拦截器，主要是通过上一个拦截器建立起来的连接通道通过交换机进行数据 包装发送 和 接受解包。\n 写入请求 Header 如果请求头的 Expect: 100-continue 时，只发送请求头 根据返回的结果判断是否继续请求流程 写入请求体，完成请求 得到响应头，构建初步响应 构建响应体，完成最终响应 返回响应  下一篇就开始看看Sink和RequestBody及ResponseBody\n","date":"2020-04-10","img":"","permalink":"https://helixs.github.io/posts/2020-04-10-android%E6%BA%90%E7%A0%81%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8Bokhttp6-callserverinterceptor/","series":null,"tags":null,"title":"Android源码一步一步分析系列之OkHttp(6)——CallServerInterceptor"},{"categories":["源码分析"],"content":"ConnectInterceptor拦截器里面的东西不多，主要是调用了连接池里面的东西。\n为什么需要这个拦截器，当我们每次发送一次Http请求的时候，如果每次都进行TCP3次握手，耗费的时间和精力是很多的。\n在Http1.1中通过增加了head字段Connection和Keep-Alive来告诉服务器保持一个常在连接通道，那么后面很多的request请求在这个时间范围内都可以用这个连接进行发送。\n这个拦截器就是来干这个事的。\n我们下面来看看\n进入newExchange\n进入find\n进入findHealthyConnection\n进入findConnection\n进入RealConnectionPool.transmitterAcquirePooledConnection\n进入RealConnectionPool.isEligible\nisEligible返回后进入 Transmitter.acquireConnectionNoEvents(connection);\n告一段落\n 在findConnection方法后面，会有一个put方法把创建新的连接加入到连接池connectionPool中，进入put方法\n 连接池的代码较多，主要就是复用连接，创建连接，保存连接，移除连接的操作。\n ","date":"2020-04-10","img":"","permalink":"https://helixs.github.io/posts/2020-04-10-android%E6%BA%90%E7%A0%81%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8Bokhttp5-connectinterceptor/","series":null,"tags":null,"title":"Android源码一步一步分析系列之OkHttp(5)——ConnectInterceptor"},{"categories":["源码分析"],"content":"CacheInterceptor主要是处理缓存的拦截器，其实他不是自己的一些什么缓存机制。基本上还是根据http的缓存协议基础上，进行缓存本地化的改造操作。\n我们要了解缓存就必须理解Http缓存协议—彻底弄懂HTTP缓存机制及原理如果大家对缓存协议不清楚，最好看一下上面的内容，Okhttp缓存就是根据它的协议进行开发的，没有太大的改造。\nCacheInterceptor流程\n\u0026lt;pre class=\u0026quot;EnlighterJSRAW\u0026quot; data-enlighter-language=\u0026quot;java\u0026quot; data-enlighter-theme=\u0026quot;atomic\u0026quot;\u0026gt;/*\r  Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the \u0026ldquo;License\u0026rdquo;); you may not use this file except in compliance with the License. You may obtain a copy of the License at *  http://www.apache.org/licenses/LICENSE-2.0\r   *\n Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \u0026ldquo;AS IS\u0026rdquo; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. */ package com.rta.rts.login.ui;  import java.io.IOException;\nimport javax.annotation.Nullable;\nimport okhttp3.Headers; import okhttp3.Interceptor; import okhttp3.Protocol; import okhttp3.Request; import okhttp3.Response; import okhttp3.internal.Internal; import okhttp3.internal.Util; import okhttp3.internal.cache.CacheRequest; import okhttp3.internal.cache.CacheStrategy; import okhttp3.internal.cache.InternalCache; import okhttp3.internal.http.ExchangeCodec; import okhttp3.internal.http.HttpHeaders; import okhttp3.internal.http.HttpMethod; import okhttp3.internal.http.RealResponseBody; import okio.Buffer; import okio.BufferedSink; import okio.BufferedSource; import okio.Okio; import okio.Sink; import okio.Source; import okio.Timeout;\nimport static java.net.HttpURLConnection.HTTP_NOT_MODIFIED; import static java.util.concurrent.TimeUnit.MILLISECONDS; import static okhttp3.internal.Util.closeQuietly; import static okhttp3.internal.Util.discard;\n/** Serves requests from the cache and writes responses to the cache. */ public final class CacheInterceptor implements Interceptor { final @Nullable InternalCache cache;\npublic CacheInterceptor(@Nullable InternalCache cache) { this.cache = cache; }\n@Override public Response intercept(Chain chain) throws IOException { //1. 读取候选缓存； //根据request得到cache中缓存的response Response cacheCandidate = cache != null ? cache.get(chain.request()) : null;\nlong now = System.currentTimeMillis();\r//2. 创建缓存策略（强制缓存，对比缓存等策略)；\r//request判断缓存的策略，是否要使用了网络，缓存或两者都使用\rCacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();\rRequest networkRequest = strategy.networkRequest;\rResponse cacheResponse = strategy.cacheResponse;\rif (cache != null) {\rcache.trackResponse(strategy);\r}\rif (cacheCandidate != null \u0026amp;\u0026amp; cacheResponse == null) {\rcloseQuietly(cacheCandidate.body()); // The cache candidate wasn't applicable. Close it.\r}\r// If we're forbidden from using the network and the cache is insufficient, fail.\r//3根据策略，不使用网络，缓存又没有直接报错；\rif (networkRequest == null \u0026amp;\u0026amp; cacheResponse == null) {\rreturn new Response.Builder()\r.request(chain.request())\r.protocol(Protocol.HTTP_1_1)\r.code(504)\r.message(\u0026quot;Unsatisfiable Request (only-if-cached)\u0026quot;)\r.body(Util.EMPTY_RESPONSE)\r.sentRequestAtMillis(-1L)\r.receivedResponseAtMillis(System.currentTimeMillis())\r.build();\r}\r// If we don't need the network, we're done.\r// 4. 根据策略，不使用网络，有缓存就直接返回；\rif (networkRequest == null) {\rreturn cacheResponse.newBuilder()\r.cacheResponse(stripBody(cacheResponse))\r.build();\r}\rResponse networkResponse = null;\rtry {\r// 5. 前面个都没有返回，读取网络结果（跑下一个拦截器）；\r//\rnetworkResponse = chain.proceed(networkRequest);\r} finally {\r// If we're crashing on I/O or otherwise, don't leak the cache body.\rif (networkResponse == null \u0026amp;\u0026amp; cacheCandidate != null) {\rcloseQuietly(cacheCandidate.body());\r}\r}\r//6. 接收到的网络结果，如果是code 304, 使用缓存，返回缓存结果（对比缓存）\r// If we have a cache response too, then we're doing a conditional get.\r//// 如果本地已经存在cacheResponse，那么让它和网络得到的networkResponse做比较，决定是否来更新缓存的cacheResponse\rif (cacheResponse != null) {\rif (networkResponse.code() == HTTP_NOT_MODIFIED) {\rResponse response = cacheResponse.newBuilder()\r.headers(combine(cacheResponse.headers(), networkResponse.headers()))\r.sentRequestAtMillis(networkResponse.sentRequestAtMillis())\r.receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())\r.cacheResponse(stripBody(cacheResponse))\r.networkResponse(stripBody(networkResponse))\r.build();\rnetworkResponse.body().close();\r// Update the cache after combining headers but before stripping the\r// Content-Encoding header (as performed by initContentStream()).\rcache.trackConditionalCacheHit();\rcache.update(cacheResponse, response);\rreturn response;\r} else {\rcloseQuietly(cacheResponse.body());\r}\r}\r//7. 读取网络结果；\rResponse response = networkResponse.newBuilder()\r.cacheResponse(stripBody(cacheResponse))\r.networkResponse(stripBody(networkResponse))\r.build();\r//8. 对数据进行缓存；\rif (cache != null) {\rif (HttpHeaders.hasBody(response) \u0026amp;\u0026amp; CacheStrategy.isCacheable(response, networkRequest)) {\r// Offer this request to the cache.\r//// 缓存未经缓存过的response\rCacheRequest cacheRequest = cache.put(response);\rreturn cacheWritingResponse(cacheRequest, response);\r}\r//9. 返回网络读取的结果。\rif (HttpMethod.invalidatesCache(networkRequest.method())) {\rtry {\rcache.remove(networkRequest);\r} catch (IOException ignored) {\r// The cache cannot be written.\r}\r}\r}\rreturn response;\r }\nprivate static Response stripBody(Response response) { return response != null \u0026amp;\u0026amp; response.body() != null ? response.newBuilder().body(null).build() : response; }\n/**\n Returns a new source that writes bytes to {@code cacheRequest} as they are read by the source consumer. This is careful to discard bytes left over when the stream is closed; otherwise we may never exhaust the source stream and therefore not complete the cached response. */ private Response cacheWritingResponse(final CacheRequest cacheRequest, Response response) throws IOException { // Some apps return a null body; for compatibility we treat that like a null cache request. if (cacheRequest == null) return response; Sink cacheBodyUnbuffered = cacheRequest.body(); if (cacheBodyUnbuffered == null) return response;  final BufferedSource source = response.body().source();\rfinal BufferedSink cacheBody = Okio.buffer(cacheBodyUnbuffered);\rSource cacheWritingSource = new Source() {\rboolean cacheRequestClosed;\r@Override public long read(Buffer sink, long byteCount) throws IOException {\rlong bytesRead;\rtry {\rbytesRead = source.read(sink, byteCount);\r} catch (IOException e) {\rif (!cacheRequestClosed) {\rcacheRequestClosed = true;\rcacheRequest.abort(); // Failed to write a complete cache response.\r}\rthrow e;\r}\rif (bytesRead == -1) {\rif (!cacheRequestClosed) {\rcacheRequestClosed = true;\rcacheBody.close(); // The cache response is complete!\r}\rreturn -1;\r}\rsink.copyTo(cacheBody.buffer(), sink.size() - bytesRead, bytesRead);\rcacheBody.emitCompleteSegments();\rreturn bytesRead;\r}\r@Override public Timeout timeout() {\rreturn source.timeout();\r}\r@Override public void close() throws IOException {\rif (!cacheRequestClosed\r\u0026amp;\u0026amp; !discard(this, ExchangeCodec.DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {\rcacheRequestClosed = true;\rcacheRequest.abort();\r}\rsource.close();\r}\r};\rString contentType = response.header(\u0026quot;Content-Type\u0026quot;);\rlong contentLength = response.body().contentLength();\rreturn response.newBuilder()\r.body(new RealResponseBody(contentType, contentLength, Okio.buffer(cacheWritingSource)))\r.build();\r }\n/** Combines cached headers with a network headers as defined by RFC 7234, 4.3.4. */ private static Headers combine(Headers cachedHeaders, Headers networkHeaders) { Headers.Builder result = new Headers.Builder();\nfor (int i = 0, size = cachedHeaders.size(); i \u0026amp;lt; size; i++) {\rString fieldName = cachedHeaders.name(i);\rString value = cachedHeaders.value(i);\rif (\u0026quot;Warning\u0026quot;.equalsIgnoreCase(fieldName) \u0026amp;\u0026amp; value.startsWith(\u0026quot;1\u0026quot;)) {\rcontinue; // Drop 100-level freshness warnings.\r}\rif (isContentSpecificHeader(fieldName)\r|| !isEndToEnd(fieldName)\r|| networkHeaders.get(fieldName) == null) {\rInternal.instance.addLenient(result, fieldName, value);\r}\r}\rfor (int i = 0, size = networkHeaders.size(); i \u0026amp;lt; size; i++) {\rString fieldName = networkHeaders.name(i);\rif (!isContentSpecificHeader(fieldName) \u0026amp;\u0026amp; isEndToEnd(fieldName)) {\rInternal.instance.addLenient(result, fieldName, networkHeaders.value(i));\r}\r}\rreturn result.build();\r }\n/**\n Returns true if {@code fieldName} is an end-to-end HTTP header, as defined by RFC 2616, 13.5.1. */ static boolean isEndToEnd(String fieldName) { return !\u0026ldquo;Connection\u0026rdquo;.equalsIgnoreCase(fieldName) \u0026amp;\u0026amp; !\u0026ldquo;Keep-Alive\u0026rdquo;.equalsIgnoreCase(fieldName) \u0026amp;\u0026amp; !\u0026ldquo;Proxy-Authenticate\u0026rdquo;.equalsIgnoreCase(fieldName) \u0026amp;\u0026amp; !\u0026ldquo;Proxy-Authorization\u0026rdquo;.equalsIgnoreCase(fieldName) \u0026amp;\u0026amp; !\u0026ldquo;TE\u0026rdquo;.equalsIgnoreCase(fieldName) \u0026amp;\u0026amp; !\u0026ldquo;Trailers\u0026rdquo;.equalsIgnoreCase(fieldName) \u0026amp;\u0026amp; !\u0026ldquo;Transfer-Encoding\u0026rdquo;.equalsIgnoreCase(fieldName) \u0026amp;\u0026amp; !\u0026ldquo;Upgrade\u0026rdquo;.equalsIgnoreCase(fieldName); }  /**\n Returns true if {@code fieldName} is content specific and therefore should always be used from cached headers. */ static boolean isContentSpecificHeader(String fieldName) { return \u0026ldquo;Content-Length\u0026rdquo;.equalsIgnoreCase(fieldName) || \u0026ldquo;Content-Encoding\u0026rdquo;.equalsIgnoreCase(fieldName) || \u0026ldquo;Content-Type\u0026rdquo;.equalsIgnoreCase(fieldName); } }   \u0026lt;p\u0026gt;\r\u0026amp;nbsp;\r\u0026lt;/p\u0026gt;\r ","date":"2020-04-09","img":"","permalink":"https://helixs.github.io/posts/2020-04-09-android%E6%BA%90%E7%A0%81%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8Bokhttp3-cacheinterceptor/","series":null,"tags":null,"title":"Android源码一步一步分析系列之OkHttp(4)——CacheInterceptor"},{"categories":["源码分析"],"content":"了解更多请看\nAndroid源码一步一步分析系列之OkHttp(1)——揭开面纱Android源码一步一步分析系列之OkHttp(2)——RetryAndFollowUpInterceptor BridgeInterceptor这个拦截器类容比较简单 主要是包装head和处理压缩数据的\n ","date":"2020-04-07","img":"","permalink":"https://helixs.github.io/posts/2020-04-07-android%E6%BA%90%E7%A0%81%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8Bokhttp3-bridgeinterceptor/","series":null,"tags":null,"title":"Android源码一步一步分析系列之OkHttp(3)——BridgeInterceptor"},{"categories":["LeetCode"],"content":"来源https://leetcode-cn.com/problems/rotate-matrix-lcci/ 解题思路 这里的N*N矩阵就会一个二维数组，并且行数=列数。操作旋转90度。我们发现一个很有意思的规律\n转换后，现数据列数=总行数-原数据行数-1 ，现数据行数=原数据列数直接上代码吧\n总的来说，注意一下深拷贝的问题，其实还是很简单啦。\n ","date":"2020-04-07","img":"","permalink":"https://helixs.github.io/posts/2020-04-07-%E6%AF%8F%E6%97%A5%E4%B8%80%E7%AF%87leetcode%E4%B9%8B-%E7%9F%A9%E9%98%B5/","series":null,"tags":null,"title":"每日一篇leetcode之-矩阵旋转"},{"categories":["源码分析"],"content":"可以看一下上一篇文章\nAndroid源码一步一步分析系列之OkHttp(1)——揭开面纱   RetryAndFollowUpInterceptor拦截器是满足一定条件下用来处理失败重试和重定向的一些操作。\n ","date":"2020-04-07","img":"","permalink":"https://helixs.github.io/posts/2020-04-07-android%E6%BA%90%E7%A0%81%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8Bokhttp2-retryandfollowupinterceptor/","series":null,"tags":null,"title":"Android源码一步一步分析系列之OkHttp(2)——RetryAndFollowUpInterceptor"},{"categories":["源码分析"],"content":"说来很惭愧，做了这么多年Android没有仔仔细细的看过Okhttp源代码，空余时间都在学习些周边的技术。现在按照新手方式看一步写一步。\nOkHttp就是一种HTTP客户端连接，它有如下特性：\n HTTP/2多路复用Socket到同一个主机，共享链接。 采用连接池技术，可以有效的减少Http链接数量。 无缝集成GZIP压缩技术。 支持Response Cache，避免重复请求。 域名多IP支持。  OkHttp会自动管理HTTP连接的生命周期：\n 操作Response.body().string()等类型的API，OkHttp会自动将该HTTP连接加入到ConnectionPool中或者直接释放连接 如果采用stream方式操作流，则需要自己手动关闭，否则会发生HTTP连接泄漏（OkHttp通过WeakReference机制，尽最大努力管理这些泄漏的HTTP连接） OkHttp不读取Resonse#Head#Keep-Alive属性来决定该HTTP连接是否能复用，而是直接加入到ConnectionPool进行复用 当从ConnectionPool中获取HTTP连接的时候，OkHttp发现该HTTP连接已经失效，则关闭该连接，并且重新选择一个HTTP连接进行复用  GET 请求 基于3.14版本，最新的4.x版本全部都使用了kotlin编写。实在话，kotlin是门好语言，不过看代码还是java比较舒服\nOkHttpClient\n开启一个同步请求 开启一个异步请求  ","date":"2020-04-02","img":"","permalink":"https://helixs.github.io/posts/2020-04-02-android%E6%BA%90%E7%A0%81%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8Bokhttp1-%E6%8F%AD%E5%BC%80%E9%9D%A2%E7%BA%B1/","series":null,"tags":null,"title":"Android源码一步一步分析系列之OkHttp(1)——揭开面纱"},{"categories":["Android开发"],"content":"Android 4.4（API 级别 19）引入了存储访问框架 (SAF)。借助 SAF，用户可轻松在其所有首选文档存储提供程序中浏览并打开文档、图像及其他文件。用户可通过易用的标准界面，以统一方式在所有应用和提供程序中浏览文件，以及访问最近使用的文件。\n云存储服务或本地存储服务可实现封装其服务的 ``DocumentsProvider ，进而参与此生态系统。只需几行代码，便可将需要访问提供程序文档的客户端应用与 SAF 进行集成。\n简单的来说，不需要自己主动读取sdcard的媒体和文档，系统给你统一的UI，统一的选择器，让你获取资料。\nSAF 包含以下内容：\n 文档提供程序 — 一种内容提供程序，可让存储服务（如 Google Drive）显示其管理的文件。文档提供程序以 ``DocumentsProvider 类的子类形式实现。文档提供程序的架构基于传统的文件层次结构，但其实际的数据存储方式由您决定。Android 平台包含若干内置文档提供程序，如 Downloads、Images 和 Videos。 客户端应用 — 一种自定义应用，它会调用 [ACTION\\_OPEN\\_DOCUMENT][2] 或 ACTION_CREATE_DOCUMENT ACTION_OPEN_DOCUMENT_TREE这三种Intent的Action,来实现打开，创建文档，以及打开文档树。 选择器 — 一种系统界面，可让用户访问所有满足客户端应用搜索条件的文档提供程序内的文档。           左边是我们的客户端， 中间SystemUI 选择器， 右边是我们的文档提供程序 就是实现了_DocumentsProvider 的提供方_\n在 Android 4.3 及更低版本中，如果您想让应用从其他应用中检索文件，则该应用必须调用 [ACTION_PICK][4] 或 ACTION_GET_CONTENT 等 Intent。然后，用户必须选择一个要从中选取文件的应用，并且所选应用必须提供用户界面，以便用户浏览和选取可用文件。\n在 Android 4.4 及更高版本中，您还可选择使用 ``ACTION_OPEN_DOCUMENT Intent，此 Intent 会显示由系统控制的选择器界面，以便用户浏览其他应用提供的所有文件。借助此界面，用户便可从任何受支持的应用中选取文件。\n[ACTION\\_OPEN\\_DOCUMENT][2] 并非用于代替 ACTION_GET_CONTENT 。您应根据应用需求选择所使用的 Intent：\n 如果您只想让应用读取/导入数据，请使用 ``ACTION_GET_CONTENT 。使用此方法时，应用会导入数据（如图片文件）的副本。 如果您想让应用获得对文档提供程序所拥有文档的长期、持续性访问权限，请使用 ``ACTION_OPEN_DOCUMENT 。例如，照片编辑应用可让用户编辑存储在文档提供程序中的图像。    SAF 所围绕的内容提供程序是 ``DocumentsProvider 类的一个子类。在文档提供程序内，数据结构采用传统的文件层次结构：    每个文档提供程序都会报告一个或多个“根目录”（探索文档树的起点）。每个根目录都有唯一的 ``COLUMN_ROOT_ID ，并且指向表示该根目录下内容的文档（目录）。根目录采用动态设计，以支持多个帐户、临时 USB 存储设备或用户登录/注销等用例。 每个根目录下都有一个文档。该文档指向 1 至 N 个文档，其中每个文档又可指向 1 至 N 个文档。 每个存储后端都会使用唯一的 ``COLUMN_DOCUMENT_ID 引用各个文件和目录，从而将其显示出来。文档 ID 必须具有唯一性，且一经发出便不得更改，因为它们用于所有设备重启过程中的 URI 持久授权。 文档可以是可打开的文件（具有特定的 MIME类型）或包含附加文档的目录（具有 ``MIME_TYPE_DIR MIME 类型）。 如 [COLUMN_FLAGS][9] 所述，每个文档可拥有不同功能。例如，FLAG_SUPPORTS_WRITE 、[FLAG\\_SUPPORTS\\_DELETE][11] 和 FLAG_SUPPORTS_THUMBNAIL 。多个目录中可包含相同的 ``COLUMN_DOCUMENT_ID 。  下面是常用的操作类\n                       DocumentsContacts：协议类，规范了客户端app和DocumentProvider之间的交互，其子类Root和Document就代表了我们之前介绍的文件结构中的根和文档。该类同时定义了文档的操作，例如删除，新建，重命名等。 DocumentFile : 辅助操作类，直接使用DocumentsContact类比较麻烦，也不符合大家的操作习惯。因此google推出了DocumentFile类来帮助大家进行文档操作，该类的api和File类较为接近。其三个子类，TreeDocumentFile代表了一个文档树，SingleDocumentFile仅仅代表单个文档。RawDocumentFile比较特殊，它代表的是一个普通的文件，而非SAF框架的Document uri DocumentProvider : 文档提供者，它的各个子类真正提供了文档的内容，例如我们访问外置sd卡，就是其子类ExternalStorageProvider提供的内容。它是真正的数据处理者，我们通过DocumentsContacts发出的各个文件操作，都将由它来实际完成。 PickActivity,OpenExternalDirectoryActivity : DocumentUi提供的页面，可以显示文档树，以及文档操作授权页面。  以下代码段使用 ``ACTION_OPEN_DOCUMENT 来搜索包含图片文件的文档提供程序：\n启动\n 当应用触发 ``ACTION_OPEN_DOCUMENT Intent 时，该 Intent 会启动选择器，以显示所有匹配的文档提供程序。 在 Intent 中添加 ``CATEGORY_OPENABLE 类别可对结果进行过滤，从而只显示可打开的文档（如图片文件）。 intent.setType(\u0026quot;image/*\u0026quot;) 语句可做进一步过滤，从而只显示 MIME 数据类型为图像的文档。  使用比较简单，我们直接构建了一个Intent请求，并调用startActivityForResult方法，请求打开DocumentUi界面，让它提供一个打开文档的视图给我们。我们可以通过设置EXTRA_ALLOW_MULTIPLE来支持多选，其他一些可以选择的EXTRA字段，可以在DocumentsContract类中自行查找。\n 返回结果\n当用户在选择器中选择文档后，系统会调用 [onActivityResult()][14]。`resultData` 参数包含指向所选文档的 URI。您可以使用 getData() 提取该 URI。获得 URI 后，您可以用它来检索用户所需文档。例如：\n// The ACTION_OPEN_DOCUMENT intent was sent with the request code // READ_REQUEST_CODE. If the request code seen here doesn't match, it's the // response to some other intent, and the code below shouldn't run at all. if (requestCode == READ_REQUEST_CODE \u0026amp;\u0026amp; resultCode == Activity.RESULT_OK) { // The document selected by the user won't be returned in the intent. // Instead, a URI to that document will be contained in the return intent // provided to this method as a parameter. // Pull that URI using resultData.getData(). resultData?.data?.also { uri -\u0026amp;gt; Log.i(TAG, \u0026quot;Uri: $uri\u0026quot;) dumpImageMetaData(uri) } }  }\u0026lt;p id=\u0026quot;metadata\u0026quot;\u0026gt; \u0026lt;strong\u0026gt;检查文档元数据\u0026lt;/strong\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; 获得文档的 URI 后，您可以访问该文档的元数据。以下代码段用于获取 URI 所指定文档的元数据，并将其记入日志： \u0026lt;/p\u0026gt; \u0026lt;pre class=\u0026quot;EnlighterJSRAW\u0026quot; data-enlighter-language=\u0026quot;kotlin\u0026quot;\u0026gt;fun dumpImageMetaData(uri: Uri) { // The query, since it only applies to a single document, will only return // one row. There's no need to filter, sort, or select fields, since we want // all fields for one document. val cursor: Cursor? = contentResolver.query( uri, null, null, null, null, null) cursor?.use { // moveToFirst() returns false if the cursor has 0 rows. Very handy for // \u0026quot;if there's anything to look at, look at it\u0026quot; conditionals. if (it.moveToFirst()) { // Note it's called \u0026quot;Display Name\u0026quot;. This is // provider-specific, and might not necessarily be the file name. //开打开的文档必须支持OpenableColumns的列 val displayName: String = it.getString(it.getColumnIndex(OpenableColumns.DISPLAY_NAME)) Log.i(TAG, \u0026quot;Display Name: $displayName\u0026quot;) val sizeIndex: Int = it.getColumnIndex(OpenableColumns.SIZE) // If the size is unknown, the value stored is null. But since an // int can't be null in Java, the behavior is implementation-specific, // which is just a fancy term for \u0026quot;unpredictable\u0026quot;. So as // a rule, check if it's null before assigning to an int. This will // happen often: The storage API allows for remote files, whose // size might not be locally known. val size: String = if (!it.isNull(sizeIndex)) { // Technically the column stores an int, but cursor.getString() // will do the conversion automatically. it.getString(sizeIndex) } else { \u0026quot;Unknown\u0026quot; } Log.i(TAG, \u0026quot;Size: $size\u0026quot;) } }  }\u0026lt;p id=\u0026quot;open-client\u0026quot;\u0026gt; \u0026lt;strong\u0026gt;打开文档\u0026lt;/strong\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; 获得文档的 URI 后，您可以打开文档，或随意对其执行任何其他操作。 \u0026lt;/p\u0026gt; \u0026lt;pre class=\u0026quot;EnlighterJSRAW\u0026quot; data-enlighter-language=\u0026quot;java\u0026quot;\u0026gt;//以下为直接从该uri中获取InputSteam，并读取出文本的内容的操作，这个是纯粹的java流操作，大家应该已经很熟悉了  //我就不多解释了。另外这里也可以直接使用OutputSteam，向文档中写入数据。 BufferedReader br = null; try { InputStream is = getContentResolver().openInputStream(uri); br = new BufferedReader(new InputStreamReader(is)); String line; sb.append(\u0026quot;\\r\\n content : \u0026ldquo;); while((line = br.readLine())!=null){ sb.append(line); } showToast(sb.toString()); } catch (IOException e) { e.printStackTrace(); }finally { closeSafe(br); }\n\u0026lt;pre class=\u0026quot;EnlighterJSRAW\u0026quot; data-enlighter-language=\u0026quot;kotlin\u0026quot;\u0026gt;@Throws(IOException::class)  private fun getBitmapFromUri(uri: Uri): Bitmap { val parcelFileDescriptor: ParcelFileDescriptor = contentResolver.openFileDescriptor(uri, \u0026ldquo;r\u0026rdquo;) val fileDescriptor: FileDescriptor = parcelFileDescriptor.fileDescriptor //val fileOutputStream =FileOutputStream(fd.getFileDescriptor()); val image: Bitmap = BitmapFactory.decodeFileDescriptor(fileDescriptor) parcelFileDescriptor.close() return image }\u0026lt;p id=\u0026quot;%E8%8E%B7%E5%8F%96-inputstream\u0026quot;\u0026gt; 获取 InputStream \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; 以下示例展示了如何从 URI 中获取 \u0026lt;a href=\u0026quot;https://developer.android.com/reference/java/io/InputStream?hl=zh-cn\u0026quot;\u0026gt;InputStream\u0026lt;/a\u0026gt;。在此代码段中，系统会将文件行读取到字符串中： \u0026lt;/p\u0026gt; \u0026lt;pre class=\u0026quot;EnlighterJSRAW\u0026quot; data-enlighter-language=\u0026quot;kotlin\u0026quot;\u0026gt;@Throws(IOException::class)  private fun readTextFromUri(uri: Uri): String { val stringBuilder = StringBuilder() contentResolver.openInputStream(uri)?.use { inputStream -\u0026gt; BufferedReader(InputStreamReader(inputStream)).use { reader -\u0026gt; var line: String? = reader.readLine() while (line != null) { stringBuilder.append(line) line = reader.readLine() } } } return stringBuilder.toString() }\u0026lt;p\u0026gt; ACTION_OPEN_DOCUMENT_TREE \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; 上面我们说到了如何打开文档，这个ACTION可以让我们直接打开文档树。类比的话，上面的Action相当于打开一个文件，这个相当于打开一个文件夹，这样大家就知道它们的区别在哪里了。我们依旧看一下示例。 \u0026lt;/p\u0026gt; \u0026lt;pre class=\u0026quot;EnlighterJSRAW\u0026quot; data-enlighter-language=\u0026quot;kotlin\u0026quot;\u0026gt;val intent = Intent(Intent.ACTION_OPEN_DOCUMENT_TREE)  \u0026hellip;\u0026hellip;\u0026lt;pre class=\u0026quot;EnlighterJSRAW\u0026quot; data-enlighter-language=\u0026quot;kotlin\u0026quot;\u0026gt;private fun handleTreeAction(data: Intent) { val treeUri: Uri = data.data //授予打开的文档树永久性的读写权限 val takeFlags: Int = (intent.getFlags() and (Intent.FLAG_GRANT_READ_URI_PERMISSION or Intent.FLAG_GRANT_WRITE_URI_PERMISSION)) getContentResolver().takePersistableUriPermission(uri, takeFlags) //使用DocumentFile构建一个根文档，之后的操作可以在该文档上进行 mRoot = DocumentFile.fromTreeUri(this, treeUri) //显示结果toast showToast(\u0026quot; open tree uri $treeUri\u0026quot;) }\u0026lt;/pre\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt; 对于我们打开的文档树，系统会赋予我们对该文档树下所有文档的读写权限，因此我们可以自由的使用我们上面介绍的输入输出流或者文件的方式来进行读写，该授权会一直保留到用户重启设备。 \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; 但是有时候，我们需要能够永久性的访问这些文件的权限，而不是重启就需要重新授权，因此我们使用了takePersistableUriPermission方法来保留系统对我们的uri的授权，即使设备重启也不影响。 \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; 我们可能保存了应用最近访问的 URI，但它们可能不再有效 — 另一个应用可能已删除或修改了文档。 因此，应该调用 getContentResolver().takePersistableUriPermission() 以检查有无最新数据。 \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; 拿到了根目录的uri,我们就可用使用DocumentFile辅助类来方便的进行创建，删除文件等操作了，我们之后介绍。 \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;pre class=\u0026quot;EnlighterJSRAW\u0026quot; data-enlighter-language=\u0026quot;kotlin\u0026quot;\u0026gt;// Here are some examples of how you might call this method.  // The first parameter is the MIME type, and the second parameter is the name // of the file you are creating: // // createFile(\u0026ldquo;text/plain\u0026rdquo;, \u0026ldquo;foobar.txt\u0026rdquo;); // createFile(\u0026ldquo;image/png\u0026rdquo;, \u0026ldquo;mypicture.png\u0026rdquo;);\n// Unique request code. private const val WRITE_REQUEST_CODE: Int = 43 \u0026hellip; private fun createFile(mimeType: String, fileName: String) { val intent = Intent(Intent.ACTION_CREATE_DOCUMENT).apply { // Filter to only show results that can be \u0026ldquo;opened\u0026rdquo;, such as // a file (as opposed to a list of contacts or timezones). addCategory(Intent.CATEGORY_OPENABLE)\n // Create a file with the requested MIME type. type = mimeType putExtra(Intent.EXTRA_TITLE, fileName) } startActivityForResult(intent, WRITE_REQUEST_CODE)  }\u0026lt;p\u0026gt; 创建新文档后，您可以在 \u0026lt;a href=\u0026quot;https://developer.android.com/reference/android/app/Activity?hl=zh-cn#onActivityResult(int,%20int,%20android.content.Intent)\u0026quot;\u0026gt;onActivityResult()\u0026lt;/a\u0026gt; 中获取该文档的 URI，以便继续向其写入内容。 \u0026lt;/p\u0026gt;  您可以随时使用 SAF 编辑文本文档。以下代码段会触发 [ACTION\\_OPEN\\_DOCUMENT][2] Intent 并使用 CATEGORY_OPENABLE 类别，从而只显示可打开的文档。它会进一步过滤，从而只显示文本文件：\n  当应用打开文件进行读取或写入时，系统会为其提供针对该文件的 URI 授权，有效期直至用户设备重启。但假定您的应用是图像编辑应用，而且您希望用户能直接从应用中访问其编辑的最后 5 张图像。如果用户的设备已重启，则您必须让用户回到系统选择器以查找这些文件，而这显然不是理想的做法。\n为防止出现此情况，您可以保留系统向应用授予的权限。实际上，您的应用是“获取”了系统提供的 URI 持久授权。如此一来，用户便可通过您的应用持续访问文件，即使设备已重启也不受影响：\n还有最后一个步骤。应用最近访问的 URI 可能不再有效，原因是另一个应用可能删除或修改了文档。因此，您应始终调用 getContentResolver().takePersistableUriPermission()，以检查有无最新数据。\n文件操作\n上面我们提到的三个Action中，ACTION_OPEN_DOCUMENT和ACTION_CREATE_DOCUMENT会返回给我们一个文件对应的uri，而ACTION_OPEN_TREE_CODE返回给我们的则是一个文件夹对应的uri，但是之前我们学习的只是使用输入输出流来读取或者写入文件的内容，如果我们需要对文件执行删除，重命名或者复制等操作要怎么办呢？\n答案就是使用google给我们提供的DocumentsContact以及帮助类DocumentFile,我们可以利用它来方便快捷的完成上述那些文件操作。\nDocumentFile类介绍 DocumentFile是google为了方便大家使用SAF进行文件操作，而推出的帮助类。它的api和java的File类比较接近，更符合一般用户的习惯，且内部实质都是使用了DocumentsContact类的方法来对文件进行操作。也就是说，我们也可以完全不使用DocumentFile而是使用DocumentsContact来完成SAF框架提供的文件操作，DocumentFile提供了三个静态工厂方法来创建自身。\n fromSingleUri,该方法需要传入一个SAF返回的指向单个文件的uri,我们的ACTION_OPEN_DOCUMENT,ACTION_CREATE_DOCUMENT返回的uri就是该类型，其对应的实现类为SingleDocumentFile，代表的是单个的文件。 fromTreeUri，该方法传入指向文件夹的uri,我们的ACTION_OPEN_TREE返回的就是该类型，其对应的实现类为TreeDocumentFile，代表的是一个文件夹。 fromFile，该方法传入普通的File类，是对file类的一个模拟，我们这里不讨论。  DocumentFile提供了一系列操作文件的便捷方法，主要部分下面表格\n                 创建文件夹和文件，并写入数据\n1，根据ACTION_OPEN_TREE返回的文档树uri,创建一个代表它的DocumentFile\n2，在该目录下，查找名为handleCreateDocument的子目录。\n3，如果未找到，则使用DocumentFile的createDirectory方法创建该子目录。\n4，在该目录下，使用createFile方法创建文件。注意，如果存在重名文件，则该方法会创建一个 原文件名(n)的文件。\n 如果您获得了文档的 URI，并且文档的 [Document.COLUMN_FLAGS][9] 包含 SUPPORTS_DELETE ，则便可删除该文档。\n删除文件夹的操作如下，注意该操作会删除文件夹下所有的文件和文件夹本身，而不像java的File类删除文件夹一样，需要用户手动遍历删除。当然它的内部实现其实也是利用java的File类，遍历文件夹删除，最后删除自身，原理都是一样的，只是写法不同。\n实际上也是调用的下面\n删除文件的操作，则只要uri来源于单个文件，并使用DocumentFile.fromTreeUri构造DocumentFile类，其他完成一样即可，这里就不多说了。\n重命名文件和文件夹\n该操作主要是使用了DocumentsContract类的rename方法来完成操作，因为DocumentFile类的delete方法不支持删除单个文件。需要注意的点如下：\n1，这里的uri需要是SAF返回给我们的单个文件的uri\n2，重命名的文件和原文件必须要在同一个文件夹下，重命名的文件名称指定路径是无效的。\n重命名文件夹的操作，除了可以可以使用我们上面的重命名文件的DocumentsContract类外，还可以使用DocumentFile类的方法来完成。\n遍历文件夹下所有文件\n1，根据ACTION_OPEN_TREE返回的文档树uri,创建一个代表它的DocumentFile。\n2，直接调用DocumentFile的listFiles方法，即可返回其包含的所有子文档，注意子文档即可以是文件，也可以是文件夹。\n授予权限 1，通过之前的分析，我们已经知道，通过ACTION_OPEN_DOCUMENT以及ACTION_CREATE_DOCUMENT拿到的单个文件是有读写权限的；而通过ACTION_OPEN_TREE拿到的整个文件夹也是有读写权限的。\n2，现在假设我们有一个需求，要在外置sd卡/DCIM/Text目录下，创建一个1.txt的文件，并向其写入文本，那么我们应该怎么做呢？看了之前的创建文件夹和文件以及写入文件一章，你可能会觉得很简单。不就是先调用ACTION_OPEN_TREE打开sd卡根目录，等用户选择后，我们拿到它的Document uri，之后还不是就是套路了。\n3，但是且慢，ACTION_OPEN_TREE打开的DocumentUi界面，用户是可以选择目录的，用户要是没有选择sd卡根目录而是其他目录，甚至选择了内部存储，那我们的文件写的位置就完全不确定了，这不符合需求啊，那怎么办呢？\n4，办法当然也是有的，经过搜索源码，发现授权访问外置sd卡根目录的方法竟然不在SAF框架相关中，而是存在StorageManager相关中，可以说是很坑爹了。其实例代码如下：\n其实现过程分为以下几步：\n1，获取存储管理服务。\n2，获取并遍历所有存储器。\n3，找到Removable（外置sd卡,usb存储等）类型的已经装载好的存储器。\n4，调用StorageVolume的createAccessIntent方法产生一个inent，之后请求DocumentUi对其进行授权，注意该方法的参数为空表示对整个目录进行授权。\n我们来看一些授权界面，看起来和普通的权限弹框类似，我们选择确定后，权限就被授予了。\n我们在来看一些后继的处理，可以看到，也是直接获取sd卡根目录的Uri,之后赋予它永久性的访问权限。然后我们就可以用之前介绍的文件操作来对它进行我们任意操作了，为了方便，我们获取可以把该uri保存下来。\n所以不一定非要使用READ_EXTERNAL_STORAGE||WRITE_EXTERNAL_STORAGE这两个权限进行目录访问。\n1，SAF框架不仅可以操作外置sd卡，也可以操作其他存储空间。\n2，使用SAF框架操作时，不需要额外的权限，例如使用它操作external storage时，并不需要我们申请WRITE_EXTERNAL_STORAGE权限。\n","date":"2020-03-30","img":"","permalink":"https://helixs.github.io/posts/2020-03-30-android-saf%E5%82%A8%E5%AD%98%E8%AE%BF%E9%97%AE%E6%A1%86%E6%9E%B6/","series":null,"tags":null,"title":"Android SAF储存访问框架"},{"categories":["LeetCode"],"content":"一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。给定一个预约请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。\n注意：本题相对原题稍作改动\n 示例 1：\n输入： [1,2,3,1]\n输出： 4\n解释： 选择 1 号预约和 3 号预约，总时长 = 1 + 3 = 4。\n示例 2：\n输入： [2,7,9,3,1]\n输出： 12\n解释： 选择 1 号预约、 3 号预约和 5 号预约，总时长 = 2 + 9 + 1 = 12。\n示例 3：\n输入： [2,1,4,5,3,1,1,3]\n输出： 12\n解释： 选择 1 号预约、 3 号预约、 5 号预约和 8 号预约，总时长 = 2 + 4 + 3 + 3 = 12。\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/the-masseuse-lcci \n这辈子还没进过按摩房呢，真想去体验一次。\n这个题的要求是\n1、在数组中只不能取出相邻的两个时长。\n2、尽量求出最大值\n技巧：我们不能按照暴力方法，毕竟太麻烦，不能取相邻两个就相当于中间隔了1个或者2个，当然不可能间隔3个，那就是亏了。\n ","date":"2020-03-24","img":"","permalink":"https://helixs.github.io/posts/2020-03-24-%E6%AF%8F%E6%97%A5%E4%B8%80%E7%AF%87leetcode%E4%B9%8B-%E6%8C%89%E6%91%A9%E5%B8%88/","series":null,"tags":null,"title":"每日一篇leetcode之-按摩师"},{"categories":["LeetCode"],"content":"给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。\n设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。\n**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n示例 1:\n输入:\n输出:\n解释:\n示例 2:\n输入:\n输出:\n解释:\n示例 3:\n输入:\n输出:\n解释:\n来自leetcode https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/ 分析：\n1、[p1…..pn]为连续的交易日价格数组\n2、必须买入在接下来的任意一天卖出，不可同时持有股票。\n3、可以任意多次购买，但不能违背要求2\n4、利润最大化\n分析这张图\n              可以看一下利润最大化只能是将所有的爬坡阶段加起来，中间下坡就是亏钱，所以不考虑。\n ","date":"2020-03-19","img":"","permalink":"https://helixs.github.io/posts/2020-03-19-%E6%AF%8F%E6%97%A5%E4%B8%80%E7%AF%87leetcode%E4%B9%8B-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-ii/","series":null,"tags":null,"title":"每日一篇leetcode之-买卖股票的最佳时机 II"},{"categories":["LeetCode"],"content":"给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。\n在构造过程中，请注意区分大小写。比如 \u0026quot;Aa\u0026quot; 不能当做一个回文字符串。\n注意:\n假设字符串的长度不会超过 1010。\n示例 1:\n题目来源 https://leetcode-cn.com/problems/longest-palindrome/ 开始解题，以来就直接想到了Hash表，表节点直接表示字符数量，要求是英文字母大小写，就是26*2=52个空间节点。上代码：\n这个方法很像我前两天写的hash表拼接单词每日一篇leetcode之-拼写单词下面是官方的答案 感觉一般般\n ","date":"2020-03-19","img":"","permalink":"https://helixs.github.io/posts/2020-03-19-%E6%AF%8F%E6%97%A5%E4%B8%80%E7%AF%87leetcode%E4%B9%8B-2/","series":null,"tags":null,"title":"每日一篇leetcode之-最长回文串"},{"categories":["LeetCode"],"content":"矩形以列表 [x1, y1, x2, y2] 的形式表示，其中 (x1, y1) 为左下角的坐标，(x2, y2) 是右上角的坐标。\n如果相交的面积为正，则称两矩形重叠。需要明确的是，只在角或边接触的两个矩形不构成重叠。\n给出两个矩形，判断它们是否重叠并返回结果。\n 示例 1：\n输入：rec1 = [0,0,2,2], rec2 = [1,1,3,3]\n输出：true\n示例 2：\n输入：rec1 = [0,0,1,1], rec2 = [1,0,2,1]\n输出：false\n_ _\n提示：\n两个矩形 rec1 和 rec2 都以含有四个整数的列表的形式给出。\n矩形中的所有坐标都处于 -10^9 和 10^9 之间。\nx 轴默认指向右，y 轴默认指向上。\n你可以仅考虑矩形是正放的情况。\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/rectangle-overlap \n未参考的解答思路 花了一个草图来想象两个矩形\n            矩形A1 矩形A2，按照A2不动的标准来跟A1作比较，如果两个不想交就说明需要满足两个XY方向条件\n[A1(x1)≤A2(x0)||A1(x0)≥A2(x1)]\u0026amp;\u0026amp;[A1(y1)≤A2(y0)||A1(y0)≥A2(y1)]\n计算了半天发现错了，因为不必满足所有条件，因为满足其中一个就行了，画蛇添足\nA1(x1)≤A2(x0)||\nA1(x0)≥A2(x1)||\nA1(y1)≤A2(y0)||\nA1(y0)≥A2(y1)\n确定上下左右四个方向就行了，着实很简单\n  官方还有一种解法，就是判断相交区域，A1跟A2如果相交就有min(A1(x1),A2(x1))\u0026gt;max(A1(x0),A2(x0))，Y方向同理，不过这次条件必须同时满足，理解起来还是要麻烦一些，可以看图理解\n  ","date":"2020-03-18","img":"","permalink":"https://helixs.github.io/posts/2020-03-18-%E6%AF%8F%E6%97%A5%E4%B8%80%E7%AF%87leetcode%E4%B9%8B/","series":null,"tags":null,"title":"每日一篇leetcode之-矩形重叠"},{"categories":["LeetCode"],"content":"给你一份『词汇表』（字符串数组） words 和一张『字母表』（字符串） chars。\n假如你可以用 chars 中的『字母』（字符）拼写出 words 中的某个『单词』（字符串），那么我们就认为你掌握了这个单词。\n注意：每次拼写时，chars 中的每个字母都只能用一次。\n返回词汇表 words 中你掌握的所有单词的 长度之和。\n 示例 1：\n输入：words = [“cat”,”bt”,”hat”,”tree”], chars = “atach”\n输出：6\n解释：\n可以形成字符串 “cat” 和 “hat”，所以答案是 3 + 3 = 6。\n示例 2：\n输入：words = [“hello”,”world”,”leetcode”], chars = “welldonehoneyr”\n输出：10\n解释：\n可以形成字符串 “hello” 和 “world”，所以答案是 5 + 5 = 10。\n_ _\n提示：\n1 \u0026lt;= words.length \u0026lt;= 1000\n1 \u0026lt;= words[i].length, chars.length \u0026lt;= 100\n所有字符串中都仅包含小写英文字母\n通过次数21,660提交次数31,246\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/find-words-that-can-be-formed-by-characters \n解答\n   ","date":"2020-03-17","img":"","permalink":"https://helixs.github.io/posts/2020-03-17-%E6%AF%8F%E6%97%A5%E4%B8%80%E7%AF%87leetcode%E4%B9%8B%E6%8B%BC%E5%86%99%E5%8D%95%E8%AF%8D/","series":null,"tags":null,"title":"每日一篇leetcode之-拼写单词"},{"categories":["数据结构和算法"],"content":"查找二叉树（Binary Sort Tree 二叉排序树）的基本定义 1、若查找树的左子树非空，则其左子树上的各个节点值均小于根节点的值\n2、若查找树的右子树非空，则其右子树上的各个节点值均大于根节点的值\n3、查找树的左右子树各是一棵查找树。\n查找 查找就是比较大小 没啥好说的\n插入 1、如果相同键值的节点已在查找二叉树中，则不插入\n2、如果查找二叉树为空树，则以新节点为查找二叉树\n3、将要插入的节点与即将插入的父节点作比较，确定左右子节点插入\n删除 1、如果要删除的节点是叶子节点就直接删除\n2、如果删除的节点只有一个子节点，那么就直接连接子节点，然后删除\n3、若要删除的节点P有两个子节点，则在其左子树上，用中序遍历需找最大的节点S，用节点S的值代替节点P的值，然后删除节点S，节点S必属于上述1,2情况之1(\n 找出左子树中最大或者右子树中最小的值val 将当前节点的值替换为val 在左子树或者右子树中找到val删除  )\n","date":"2020-03-16","img":"","permalink":"https://helixs.github.io/posts/2020-03-16-%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A72/","series":null,"tags":null,"title":"树和二叉树基本特性(2)"},{"categories":["数据结构和算法"],"content":"树的基本概念就不介绍了，直接上干活\n概念：  1、树的总结点数为n，总度数为k，那么n=k+1\n因为度数就相当于子节点的个数，根节点就是那个+1\n节点的度：一个节点有几个子节点就是有几度。树的读：所有节点中，有几个节点有分叉，就相当于树的度。例题.在一棵度为3的树中，有2个度为3的节点，1个度为2的节点，则有_x_个度为0的节点。求x。_\n解：树的度为3，就相当于3个有分叉的节点，其他都是叶子节点，因为n=k+1。\n得到n=3*2+2*1+0*x =\u0026gt;n=9\n9-2-1=6 x = 6\n2、二叉树的重要特性\n1、在二叉树的第i层上，最多有2^(i-1)个节点（i≥1）；\n2、深度为k的二叉树最多有(2^k)-1个节点(i≥1)；\n3、对任何一颗二叉树，如果其叶子结点数为N0，度为2的节点数为N2，则N0=N2+1；\n4、具有n个结点的完全二叉树的深度为floor(log2n) + 1\n5、如果对一棵有n个结点的完全二叉树（其深度为floor(log2n) + 1 ）的结点按层序编号，则对任一结点i（1≤i≤n）有：\n（1） 如果i = 1，则结点i是二叉树的根，无双亲；如果i \u0026gt; 1，则其双亲PARENT(i)是结点 floor((i)/2)\n（2）如果2i \u0026gt; n，则结点i无左孩子；否则其左孩子LCHILD(i)是结点2i\n（3）如果2i + 1 \u0026gt; n，则结点i无右孩子；否则其右孩子RCHILD(i)是结点2i + 1\nfloor向下取整 二叉树通常作为数据结构应用，典型用法是对节点定义一个标记函数，将一些值与每个节点相关系。这样标记的二叉树就可以实现二叉搜索树和二叉堆，并应用于高效率的搜索和排序。\n例题：一个具有767个节点的完全二叉树，其叶子结点个数为_X_个。 求X\n根据上面第三点 对任何一颗二叉树，如果其叶子结点数为N0，度为2的节点数为N2，则N0=N2+1；\nN = N0 + (N2 +1)=2N2+1\n767 = 2N2+1\nN2 = 383\nX = N2+1 = 383+1 = 384\n二叉树的遍历             前序1，2，4，5，7，8，3，6\n中序4，2，7，8，5，1，3，6\n后序4，8，7，5，2，6，3，1\n","date":"2020-03-16","img":"","permalink":"https://helixs.github.io/posts/2020-03-16-%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A71/","series":null,"tags":null,"title":"树和二叉树基本特性(1)"},{"categories":["数据库"],"content":"Navicat是比较好的数据库管理软件，可是真的好贵啊，公司企业那些一直在用付费很正常，普通用户也不是一直用，所以很划不来。不过还是要支持正版。\n下载Navicat https://www.navicat.com.cn/products  最新版本已经是15了，下载完成后安装，记得安装目录就行\n下载激活工具 Navicat Software – Patch/Keygen 原始链接(可能出现网站不稳定的情况)\n根据浪儿提供的地址 https://www.lanzous.com/b0bkap39e 5p9d如果下载不了请关闭杀毒软件，或者信任。当然我也不知道有没有毒。哈哈\n断网 1、 打开激活工具，默认选中了Backup和Host，然后选择Navicat的版本，之后点击patch。\n弹窗选择框到Navicat安装目录选中navicat.exe完成\n              2、选中你的协议和products(mysql啊orancle等等)\n3、点击Generate生成激活码，复制激活码\n4、打开navicat，输入激活码，弹窗则手动，复制requestCode\n5、打开激活工具粘贴到requestCode，点击Generate生成ActivationCode，复制\n6、打开navicat粘上去，激活成功\n可以看看下面这个教程\nhttps://juejin.im/post/5d8081b0e51d4561d54dea19  本博客不提供任何文件下载服务，链接资源均搜集子网上，如果出现侵权行为，请关闭此页面。  ","date":"2020-03-12","img":"","permalink":"https://helixs.github.io/posts/2020-03-12-navicat%E5%90%84%E7%89%88%E6%9C%AC%E5%8C%85%E6%8B%AC15%E9%80%9A%E7%94%A8%E6%BF%80%E6%B4%BB%E6%95%99%E7%A8%8B/","series":null,"tags":null,"title":"Navicat各版本(包括15)通用激活教程"},{"categories":["数据库"],"content":"初始密码的问题 安装MariaDb后按照网上说的什么mysql -u root -p 根本进不去啊，要输入密码，直接回车也不行。下面可以解决\nroot用户远程访问数据库 root用户默认值只允许localhost，所以需要修改root用户的访问权限，不然在会拒绝连接。\n默认是3306端口号，记得开启端口，如果是云服务器记得配置3306的安全组\n还有如果是本地的防火墙可以参考centos7 防火墙端口配置和SSH端口配置 做完之后登录mysql -u root -p.表示所有ip可以进来，password表示root用户远程登录的密码，不是原来的密码，记得设置。然后就可以啦\n navicat安装教程 Navicat各版本(包括15)通用激活教程 ","date":"2020-03-11","img":"","permalink":"https://helixs.github.io/posts/2020-03-11-%E5%AE%89%E8%A3%85mariadb%E8%AE%BE%E7%BD%AE%E5%88%9D%E5%A7%8B%E5%AF%86%E7%A0%81/","series":null,"tags":null,"title":"安装mariadb设置初始密码及配置"},{"categories":["Android开发","kotlin"],"content":"我们的app经常有需求下载文件等，还有就是下载安装。\n1、下载文件的方式 1,很多三方框架都有文件上传下载功能，可以借助三方框架(比如Volley,OkHttp,或者还有个很不错的库OKdownload,不过这个库比较重量级，我们只做简单的下载就不太需要啦)\n2,也可以开启一个线程去下载,（可以用IntentService）\n3，最简单的一种方式：Android SDK 其实给我们提供了下载类DownloadManager,只需要简单的配置项设置，就能轻松实现下载功能。\nDownloadManager 是SDK 自带的，大概流程如下：\n（1）创建一个Request,进行简单的配置（下载地址，和文件保存地址等）\n（2）下载完成后，系统会发送一个下载完成的广播，我们需要监听广播。\n（3）监听到下载完成的广播后，根据id查找下载的apk文件\n（4）在代码中执行apk安装。\nActivity中使用\n简单的使用就是这些，有问题可以评论哦\n","date":"2020-03-11","img":"","permalink":"https://helixs.github.io/posts/2020-03-11-android%E8%B0%83%E7%94%A8downloadmanager%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%E5%8F%8A%E5%AE%89%E8%A3%85apk%E5%85%BC%E5%AE%B9678/","series":null,"tags":["DownloadManager"],"title":"Android调用DownloadManager下载文件及安装apk，兼容6、7、8+"},{"categories":["linux常用配置"],"content":"更新系统软件后，非正常关机，出现了\n couldn't find an input interrupt dev/sda1 contains a file system with errors, check forced. Inodes that were part of a corrupted orphan linked list found. /dev/sda1: UNEXPECTED INCONSISTENCY: RUN fsck MANUALLY. (i.e., without -a or -p options) fsck exited with status code 4 The root filesystem on /dev/sda1 requires a manual fsck BusyBox v1.22.1 (Ubuntu 1:1.22.0-19ubuntuu2) built-in shell (ash) Enter 'help' for a list of built-in commands. (initramfs)_  键入fsck -f /dev/sda1以检查/修复您的文件系统。","date":"2020-02-29","img":"","permalink":"https://helixs.github.io/posts/2020-02-29-ubuntu%E5%BC%80%E6%9C%BA%E9%94%99%E8%AF%AF-couldnt-find-an-input-interrupt-dev-sda1-contains-a-file-system-with-errors/","series":null,"tags":null,"title":"Ubuntu开机错误 Couldn’t Find an Input Interrupt /Dev/Sda1 Contains a File System With Errors"},{"categories":["Android开发"],"content":"大多数简单的Android应用我们都是直接startActivity启动和finish完成销毁。慢慢我们根据应用的各个场景及跳转复杂度开始使用了lanchMode诸如singleTask singleTop，NewTask等等。用是用了，但是用的是不清不楚不明不白，倘若面试疑问就是一脸懵逼。今天着重看看Task栈和finishAffinity的用法，不过在这之前还是找找启动模式的一些资料，先到网上翻阅，看看人们是怎么说的。\nActivity 启动模式和任务栈 任务栈（tasks-and-back-stack） 创建任务栈 在两种情况下，有可能会创建一个新的任务栈：\n（1）以 FLAG_ACTIVITY_NEW_TASK 方式启动一个 activity；\n（2）在 AndroidManifest.xml 中配置了 android:taskAffinity。\n如果我们使用 startActivity 启动一个 Activity，没有添加任何 flag 时，新启动的 Activity 会与调用 startActivity 的 Activity 位于同一个任务栈中；在默认情况下，应用内的所有 Activity 都会被存放在以包名命名的任务栈中。\n当我们以 FLAG_ACTIVITY_NEW_TASK 方式启动一个 Activity 时，如果某个任务栈里已经有该 Activity 了，那么会将该任务栈从后台切换到前台，也即从停止状态切换到活跃状态，否则先创建一个新的任务栈，将创建一个 Activity 实例，将该实例作为 Root Activity（任务栈最底部的 Activity）。\n如果在当前的任务栈中，按照FLAG_ACTIVITY_NEW_TASK启动当前根Activity是无法启动的。如果同样方式启动android:taskAffinity一致但是Activity不一样也不会启动新的任务栈，而是在当前任务栈启动一个新的Activity。 西门笔者试了一下，在默认的lanchMode下，如果要使用FLAG_ACTIVITY_NEW_TASK切换任务栈或者创建新的任务栈要同时满足两个需求，1、当且仅当当前任务栈的RootActivityandroid:taskAffinity和被启动的Activity的android:taskAffinity不一致2、如果要切换在后台的任务栈，需要满足被启动的Acitivity在其他某个任务栈的作为Root节点，不过相应的，你看看在没有魔改的android系统的多任务栏切换是不是多了那么多个taskAffinity窗口呢，哈哈~~~所以看看微信小程序是不是也是动态生成的小程序的任务栈。不过，如果同时也添加了 Intent.FLAG_ACTIVITY_MULTIPLE_TASK 属性，那么系统会无条件创建一个新的任务栈。\n如果要启动的 Activity 配置了 android:taskAffinity，那么系统会将该 Activity 放到对应的任务栈中。\n销毁任务栈  当我们从最近任务中移除对应的任务时，该任务栈也会被移除。从 Android 5.x 起，重启后任务栈可以被恢复。（see[持久化的任务栈][持久化的任务栈]） 当任务栈中已经没有 Activity 时，该任务栈会被自动销毁。 当系统内存较少时，任务栈也有可能被移除，只保留重建该任务栈需要的信息。  当任务栈被销毁时，之前在任务栈中的 Activity 关联的服务会触发 onTaskStopped() 回调，可以决定是否要结束服务；如果在 AndroidManifest.xml 设置 android:stopWithTask=\u0026quot;true\u0026quot;（默认 false），则不会接收到该回调，同时服务会自动被销毁。不过在 Android 4.4 上，由于存在 bug（参 Issue 104308和 Issue 63618），即使没有设置 android:stopWithTask=\u0026quot;true\u0026quot;，当任务栈被销毁时，对应的服务也会被销毁。\n当任务栈是正常销毁的（比如通过最近历史销毁），Activity 的 onDestroy 会被调用，然而如果是被异常结束（如通过第三方应用结束），则 onDestroy 不会被调用。\n恢复任务栈 有四种情况下会恢复一个任务栈，\n 通过最近运行历史启动一个任务栈； 以 FLAG_ACTIVITY_NEW_TASK 且非 FLAG_ACTIVITY_MULTIPLE_TASK 方式运行一个已经运行过的 Activity； if the taskAffinity for the activity being started ties it to another task if the launch mode for the activity being started ties it to another task  使用 flag 实现 Activity 实例的复用 默认情况下，启动一个 Activity 时，会创建一个新的实例，要改变这种行为，可以使用 flag 或者启动模式。\n FLAG_ACTIVITY_REORDER_TO_FRONT：如果某任务栈中存在要启动的 Activity 的实例，则将其调整到栈顶。调整到栈顶的过程中不会清除其上的实例。（其实就是调换启动的acitivity顺序，ABCD-\u0026gt;FLAG_ACTIVITY_REORDER_TO_FRONT-\u0026gt;B=ACDB）当然，启动这个activity没有此实例创建时，就会正常启动onCreate。如果已经添加了 FLAG_ACTIVITY_CLEAR_TOP，则该 flag 会被忽略。 FLAG_ACTIVITY_CLEAR_TASK：如果某任务栈中存在要启动的 Activity，则将该 Activity 之外的其他 Activity 清除，将其作为 Root Activity。一般与 FLAG_ACTIVITY_NEW_TASK 组合使用（单独使用没啥效果。在一起使用的时候，如果当前只有一个任务栈，那么就会清除当前的任务栈所有的Activity，就算被启动的Activity在当前其中已经有了也会清除，然后启动新的Activity作为Root节点，栈本身没有被清理。如果其他任务栈当中含有要启动的Activity，就会清理其它任务栈，创建新的Activity，但是不会清除当前的任务栈。清空当前task栈，然后在一个新的task栈中启动activity，但是并不是一定会在一个新的task栈中启动activity。如果系统为该activity找到一个极具亲和力（taskAffinity的值相等）的task栈，就不会在新的task栈中启动Activity。———-换而言之，如果taskAffinity是一样的，那么就可能清空与被启动的taskAffinity一样的Root栈所在的task们）。如果想要每次启动该 Activity 时都具有该行为，可以设置 android:clearTaskOnLaunch=\u0026quot;true\u0026quot;。 FLAG_ACTIVITY_RESET_TASK_IF_NEEDED：如果某任务栈中已经存在该 Activity 了，则启动该 Activity 或者位于其上方合适的 Activity（触发[Reparenting Tasks][Reparenting Tasks]）。比如存在 A 启动 B，此时以 FLAG_ACTIVITY_RESET_TASK_IF_NEEDED 方式启动 A，则会显示 B；如果使用的是 FLAG_ACTIVITY_CLEAR_TASK，则显示的是 A。一般，桌面启动器启动一个 Activity 时，使用的就是 FLAG_ACTIVITY_NEW_TASK 和 FLAG_ACTIVITY_RESET_TASK_IF_NEEDED。(    对于合适的 Activity，有如下要求：\n（1）该 Activity 不是以 FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET 方式启动。\n（2）该 Activity 不是位于某个以 FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET 方式启动的 Activity 之上。\n比如：存在任务栈中存在 A – B – C – D，C 是以 FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET 方式启动的，此时如果我们以 FLAG_ACTIVITY_RESET_TASK_IF_NEEDED 方式启动 A 或 B，都会显示的是 B。\nReparenting Tasks 一个 Activity 实例所属的任务栈可以被改变。\n通过配置 android:allowTaskReparenting=\u0026quot;true\u0026quot;，我们可以实现一个特殊的效果。例如，如果应用 B 启动了 A 的一个 Activity，接着回到桌面，如果这时我们访问 A 的默认 Activity，会出现被调用的 Activity。也即该 Activity 实例从 B 的某个任务栈中转移到 A 的某个任务栈（包括新建的）中，并作为要显示的 Activity。默认情况下（没有特别指定所属的任务栈）， 启动一个 Activity 时，如果存在设置了 android:allowTaskReparenting=\u0026quot;true\u0026quot; 的 Activity，并且其他任务栈中找到了对应的实例，就将其挪到应用默认的任务栈中。\n自动销毁的 Activity 在某些情况下，我们想要在离开某些 Activity 时，将其销毁。除了可以使用 finish 来完成，还可以使用 android:noHistory 或 FLAG_ACTIVITY_NO_HISTORY 来实现。对于这类 Activity，是不能使用 startActivityForResult() 来启动的。\nandroid:finishOnTaskLaunch 也会自动销毁 Activity，不过是在重新会到该 Activity 的时候才销毁旧的 Activity。\nalwaysRetainTaskState 默认情况下，如果一个任务栈超过一定的时间没有访问（30分钟以上），那么下次访问就会回到 Root Activity。如果不希望出现这种情况，可以给 Root Activity 设置 android:alwaysRetainTaskState=\u0026quot;true\u0026quot;。\n不显示最近历史记录的 Activity 同样的，可以通过 android:excludeFromRecents=\u0026quot;true\u0026quot; 或者 FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS 来设置，不过只适用于 Root Activity。\n持久化的任务栈 默认情况下，当任务栈被销毁后，如果从最近任务中访问该任务栈，则只会显示任务栈里的 Root Activity。5.x 起，应用可以为 Activity 配置独立的持久化数据，用于在重建任务栈时恢复原来的执行状态。在进行任务栈重建时，会先执行以下方法对应的单参数版本，然后执行该方法：\n publicvoidonRestoreInstanceState(BundlesavedInstanceState, PersistableBundlepersistentState); publicvoidonSaveInstanceState(BundleoutState, PersistableBundleoutPersistentState); 需要注意的是 PersistableBundle 中 不能存放Parcelable 或 Serializable 类型的数据。\n而至于恢复到哪个 Activity，则取决与 Root Activity 的 persistableMode:\n persistNever：重启不持久化。 persistRootOnly：默认，只持久化 Root Activity。 persistAcrossReboots：持久化所有设置了 persistAcrossReboots 并且不是以 FLAG_CLEAR_TASK_WHEN_RESET 启动的 Activity。  Document 5.x 起，Android 还支持一种称为 Document 的启动模式。这种模式有点类似浏览器的多标签页，比如用户打开了多个文档，每个文档都有独立的上下文，反映在最近运行任务列表里，每一个文档都有一个独立的项。\n使用方法有两种： （1）设置 android:documentLaunchMode：\n always：总是在新 document 中启动； intoExisting：由同一个类、启动意图的 Uri 相同的，都放到同一个 document 中。 never：该 Activity 不以新 document 的形式启动。 none：默认，只有当使用 flags 声明要以新 document 方式启动才会以新 document 方式启动。  （2）设置 flags：\n FLAG_ACTIVITY_NEW_DOCUMENT：效果与 intoExisting相似，如果要效果类似 always，则还应该设置 Intent.FLAG_ACTIVITY_MULTIPLE_TASK。  默认情况下，系统不会自动去除 document，如果需要自动去除 document，可以在 Root Activity 上使用 android:maxRecents 设置最多要保留的 document 数量，系统会自动应用 LRU 算法来确定要保留哪些 document。默认情况下，android:maxRecents 的值为 16。另外，还可以设置 android:autoRemoveFromRecents=\u0026quot;true\u0026quot;，这样当 Root Activity 退出时，document 就会被清除。如果要手动清除，也可以使用 finishAndRemoveTask()（see [与任务栈操作有关的其他方法][与任务栈操作有关的其他方法]）。\n启动模式与返回值的情况  ","date":"2019-12-16","img":"","permalink":"https://helixs.github.io/posts/2019-12-16-android%E5%AF%B9finishaffinity%E7%9A%84%E7%AE%80%E5%8D%95%E8%AE%A4%E8%AF%86/","series":null,"tags":["启动模式"],"title":"Android对finishAffinity的简单认识"},{"categories":["Android开发","编程生活"],"content":"MaterialButton和MaterialCardView的都新增了边框属性，我们没必要为了一个边框写那么多shape，一旦多了谁着得住。\n1、在使用MaterialButton注意一点是它必须设置android:textAppearance属性，不然会崩溃 This component requires that you specify a valid TextAppearance attribute. Update your app theme to inherit from Theme.MaterialComponents (or a descendant)它会检查textApearance属性，解决方式有两种如下:\n1、添加它就好\n2、application或activity或控件的theme继承自Theme.MaterialComponents.xxxx,使type能够找到这个属性，如\n其实想了想，也许以后MaterialComponents的text相关组件都会进行这种操作吧。\n2、在使用MaterialButton时候可能遇到背景颜色不能充满控件的问题。 如果按照以前默认的方式添加背景颜色，我们发现背景颜色不能充满上下编剧，我们对比使用appcompatButton\n      1、从上面的图片可以看出它们的背景颜色不一样。MaterialButton是不受android:background控制的，官方建议我们设置app:backgroundHint来进行背景的更改。\n2、AppCompatButton如果设置了android:background会覆盖上下左右的间距，MaterialButton则不会\n3、MaterialButton设置了app:backgroundHint左右是没有间距的，而上下有。AppCompatButton设置了app:backgroundHint是上下左右都有间距\n找到原因https://github.com/material-components/material-components-android/blob/master/docs/components/MaterialButton.md#attributes Note: MaterialButton is visually different from Button and AppCompatButton. One of the main differences is that AppCompatButton has a 4dp inset on the left and right sides, whereas MaterialButton does not. To add an inset to match AppCompatButton, set android:insetLeft and android:insetRight on the button to 4dp, or change the spacing on the button’s parent layout.\n反正AppCompatButton左右留了4个dp的占位，而MaterialButton没有。\n试验\n通过设置上下左右inset控制button绘制的范围，背景颜色也能控制。那么我们就解决了这个问题了\n    方案：\n设置insetTop和insetBottom为0dp","date":"2019-11-28","img":"","permalink":"https://helixs.github.io/posts/2019-11-28-android-materialbutton%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/","series":null,"tags":["matrialButton"],"title":"Android MaterialButton的一些问题"},{"categories":["Android开发","java"],"content":" 作为一个普通的Android开发者来说，平常布布控件和各种框架的情况下，接触线程的地方少之又少，更别提线程池了。以前基础差，做项目的时候牵扯到异步操作的时候呢都是直接Thread+handler根本没考虑后果，做完事就行。面试的时候就是被按在地上一顿摩擦。\n在alibaba开发手册上，这样写到：\n【强制】新建线程时，必须通过线程池提供（AsyncTask 或者ThreadPoolExecutor或者其他形式自定义的线程池），不允许在应用中自行显式创建线程。\n_ 说明：使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。另外创建匿名线程不便于后续的资源使用分析，对性能分析等会造成困扰。_\n所以我们在进阶开发的时候特别涉及到大量数据操作的时候很有必要使用线程池来管理我们的线程任务。\n线程池创建 Android中常用的线程池都是通过对ThreadPoolExecutor进行不同配置来实现的，下面是它的构造方法\n corePoolSize线程池中核心线程的数量 maximumPoolSize 线程池中最大线程数量（其中包括了核心线程） keepAliveTime当线程数大于核心时，这是多余的空闲线程在终止之前等待新任务的最长时间，也就是非核心线程的超时时长，当系统中非核心线程闲置时间超过keepAliveTime之后，则会被回收。如果ThreadPoolExecutor的allowCoreThreadTimeOut属性设置为true，则该参数也表示核心线程的超时时长 unitkeepAliveTime 的时间单位多数情况下按照秒和毫秒来做 workQueueBlockingQueue的实现类 在执行任务之前用于保留任务的队列。该队列将仅保存由ThreadPoolExecutor.execute方法提交的 Runnable任务。这也是我们这片文章的重点内容 threadFactory线程池在创建线程的工厂类，如果不传入默认会有一个Executors.defaultThreadFactory() handler拒绝策略，当线程无法执行新任务时（一般是由于线程池中的线程数量已经达到最大数或者线程池关闭导致的），默认情况下，当线程池无法处理新线程时，会抛出一个RejectedExecutionException。  了解到了它的构造方法后我们来捋一捋，看一下ThreadPoolExecutor.execute方法\nctl是AtomicInteger类型，(里面保存了当前线程池中有效线程数量count和当前线程池运行的状态runState，count的增减同步，保证每次get的时候数量是最新的，所谓的原子性。每次我们都只用get的值，里面是用位运算符关联两个值的。位运算我一脸懵逼反正它保存了两个值了)。如果当前运行的线程的数量小于核心线程数量(就是我们在构造方法传入的corePoolSize)，那么就正常添加并执行任务。如果没有添加成功，就继续检查当前线程池的运行状态，如果还是在运行中，那么尝试通过blockingQueue的offer方法(记住只有offer方法，后面讲的那么这个线程池没用上)把Runnable放到任务队列中（后续核心线程如果有任务完成，那么就从这个队列中使用take方法取出Runnable放入到核心线程去执行任务）。如果加入成功到队列中，检查线程池状态，如果线程池在运行，那么就删除添加的Runnable，如果一切成功就抛出RejectedExecutionException。后面都看得懂就不解释了。\n过程如下\n execute一个线程之后，如果线程池中的线程数未达到核心线程数，则会立马启用一个核心线程去执行。 execute一个线程之后，如果线程池中的线程数已经达到核心线程数，且workQueue未满，则将新线程放入workQueue中等待执行。 execute一个线程之后，如果线程池中的线程数已经达到核心线程数但未超过非核心线程数，且workQueue已满，则开启一个非核心线程来执行任务。 execute一个线程之后，如果线程池中的线程数已经超过非核心线程数，则拒绝执行该任务。   BlockingQueue 下面引入网上对BlockingQueue的主要方法的解释\n\u0026lt;td align=\u0026quot;center\u0026quot;\u0026gt; \u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;抛出异常\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td align=\u0026quot;center\u0026quot;\u0026gt; \u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;特殊值\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td align=\u0026quot;center\u0026quot;\u0026gt; \u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;阻塞\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td align=\u0026quot;center\u0026quot;\u0026gt; \u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;超时\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt; \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; \u0026lt;a href=\u0026quot;http://blog.csdn.net/itm_hadf/article/details/7538083\u0026quot; rel=\u0026quot;nofollow\u0026quot; data-token=\u0026quot;d84ab2ded6a50457642e83b0a8a699b4\u0026quot;\u0026gt;\u0026lt;code\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;strong\u0026gt;add(e)\u0026lt;/strong\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; \u0026lt;a href=\u0026quot;http://blog.csdn.net/itm_hadf/article/details/7538083\u0026quot; rel=\u0026quot;nofollow\u0026quot; data-token=\u0026quot;d84ab2ded6a50457642e83b0a8a699b4\u0026quot;\u0026gt;\u0026lt;code\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;strong\u0026gt;offer(e)\u0026lt;/strong\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; \u0026lt;a href=\u0026quot;http://blog.csdn.net/itm_hadf/article/details/7538083\u0026quot; rel=\u0026quot;nofollow\u0026quot; data-token=\u0026quot;d84ab2ded6a50457642e83b0a8a699b4\u0026quot;\u0026gt;\u0026lt;code\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;strong\u0026gt;put(e)\u0026lt;/strong\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; \u0026lt;a href=\u0026quot;http://blog.csdn.net/itm_hadf/article/details/7538083\u0026quot; rel=\u0026quot;nofollow\u0026quot; data-token=\u0026quot;d84ab2ded6a50457642e83b0a8a699b4\u0026quot;\u0026gt;\u0026lt;code\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;strong\u0026gt;offer(e, time, unit)\u0026lt;/strong\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; \u0026lt;a href=\u0026quot;http://blog.csdn.net/itm_hadf/article/details/7538083\u0026quot; rel=\u0026quot;nofollow\u0026quot; data-token=\u0026quot;d84ab2ded6a50457642e83b0a8a699b4\u0026quot;\u0026gt;\u0026lt;code\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;strong\u0026gt;remove()\u0026lt;/strong\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; \u0026lt;a href=\u0026quot;http://blog.csdn.net/itm_hadf/article/details/7538083\u0026quot; rel=\u0026quot;nofollow\u0026quot; data-token=\u0026quot;d84ab2ded6a50457642e83b0a8a699b4\u0026quot;\u0026gt;\u0026lt;code\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;strong\u0026gt;poll()\u0026lt;/strong\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; \u0026lt;a href=\u0026quot;http://blog.csdn.net/itm_hadf/article/details/7538083\u0026quot; rel=\u0026quot;nofollow\u0026quot; data-token=\u0026quot;d84ab2ded6a50457642e83b0a8a699b4\u0026quot;\u0026gt;\u0026lt;code\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;strong\u0026gt;take()\u0026lt;/strong\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; \u0026lt;a href=\u0026quot;http://blog.csdn.net/itm_hadf/article/details/7538083\u0026quot; rel=\u0026quot;nofollow\u0026quot; data-token=\u0026quot;d84ab2ded6a50457642e83b0a8a699b4\u0026quot;\u0026gt;\u0026lt;code\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;strong\u0026gt;poll(time, unit)\u0026lt;/strong\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; \u0026lt;a href=\u0026quot;http://blog.csdn.net/itm_hadf/article/details/7538083\u0026quot; rel=\u0026quot;nofollow\u0026quot; data-token=\u0026quot;d84ab2ded6a50457642e83b0a8a699b4\u0026quot;\u0026gt;\u0026lt;code\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;strong\u0026gt;element()\u0026lt;/strong\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; \u0026lt;a href=\u0026quot;http://blog.csdn.net/itm_hadf/article/details/7538083\u0026quot; rel=\u0026quot;nofollow\u0026quot; data-token=\u0026quot;d84ab2ded6a50457642e83b0a8a699b4\u0026quot;\u0026gt;\u0026lt;code\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;strong\u0026gt;peek()\u0026lt;/strong\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; \u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;不可用\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; \u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;不可用\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt; \u0026lt;/td\u0026gt;    add(anObject):把anObject加到BlockingQueue里,即如果BlockingQueue可以容纳,则返回true,否则IllegalStateException(“Deque full”); offer(anObject):表示如果可能的话,将anObject加到BlockingQueue里,即如果BlockingQueue可以容纳,则返回true,否则返回false. put(anObject):把anObject加到BlockingQueue里,如果BlockQueue没有空间,则调用此方法的线程被阻断直到BlockingQueue里面有空间再继续. poll(time):取走BlockingQueue里排在首位的对象,若不能立即取出,则可以等time参数规定的时间,取不到时返回null take():取走BlockingQueue里排在首位的对象,若BlockingQueue为空,阻断进入等待状态直到Blocking有新的对象被加入为止  其中：BlockingQueue 不接受null 元素。试图add、put 或offer 一个null 元素时，某些实现会抛出NullPointerException。null 被用作指示poll 操作失败的警戒值。\n 它是一个特殊的队列，当我们从BlockingQueue中取数据时，如果BlockingQueue是空的，则取数据的操作会进入到阻塞状态，当BlockingQueue中有了新数据时，这个取数据的操作又会被重新唤醒。同理，如果BlockingQueue中的数据已经满了，往BlockingQueue中存数据的操作又会进入阻塞状态，直到BlockingQueue中又有新的空间，存数据的操作又会被冲洗唤醒。BlockingQueue有多种不同的实现类，下面我举几个例子来说一下：\nArrayBlockingQueue：这个表示一个规定了大小的BlockingQueue，ArrayBlockingQueue的构造函数接受一个int类型的数据，该数据表示BlockingQueue的大小，存储在ArrayBlockingQueue中的元素按照FIFO（先进先出）的方式来进行存取。一个由数组支持的有界阻塞队列。在读写操作上都需要锁住整个容器，内部还保存着两个整形变量，分别标识着队列的头部和尾部在数组中的位置。\nLinkedBlockingQueue：这个表示一个大小不确定的BlockingQueue，在LinkedBlockingQueue的构造方法中可以传一个int类型的数据，这样创建出来的LinkedBlockingQueue是有大小的，也可以不传，不传的话，LinkedBlockingQueue的大小就为Integer.MAX_VALUE。数据的队列是按照链表的形式排列的，一个node指定下一个node。\nPriorityBlockingQueue：这个队列和LinkedBlockingQueue类似，不同的是PriorityBlockingQueue中的元素不是按照FIFO来排序的，而是按照元素的Comparator来决定存取顺序的（这个功能也反映了存入PriorityBlockingQueue中的数据必须实现了Comparator接口）。\nSynchronousQueue：这个是同步Queue，属于线程安全的BlockingQueue的一种，在SynchronousQueue中，生产者线程的插入操作必须要等待消费者线程的移除操作，Synchronous内部没有数据缓存空间，因此我们无法对SynchronousQueue进行读取或者遍历其中的数据，元素只有在你试图取走的时候才有可能存在。我们可以理解为生产者和消费者互相等待，等到对方之后然后再一起离开。所以无论怎么样，队列里面只能最多有一个短暂的元素。\n我们自己用主要都是ArrayBlockingQueue和LinkedBlockingQueue 它们的组要特点：\n   queue 阻塞与否 是否有界 线程安全保障 适用场景 注意事项     ArrayBlockingQueue 阻塞 有界 一把全局锁 生产消费模型，平衡两边处理速度 用于存储队列元素的存储空间是预先分配的，使用过程中内存开销较小（无须动态申请存储空间）   LinkedBlockingQueue 阻塞 可配置 存取采用2把锁 生产消费模型，平衡两边处理速度 无界的时候注意内存溢出问题，用于存储队列元素的存储空间是在其使用过程中动态分配的，因此它可能会增加JVM垃圾回收的负担。    内存方面  ArrayBlockingQueue\n用于存储队列元素的存储空间是预先分配的，使用过程中内存开销较小（无须动态申请存储空间） LinkedBlockingQueue\n用于存储队列元素的存储空间是在其使用过程中动态分配的，因此它可能会增加JVM垃圾回收的负担。  有界无界  ArrayBlockingQueue\n有界，适合已知最大存储容量的场景 LinkedBlockingQueue\n可有界可以无界  Executors 我们找到Executors的创建线程池的默认工具类\n其中这4个静态方法是用的最多的，在Alibaba开发手册上讲到\n【强制】线程池不允许使用Executors 去创建，而是通过ThreadPoolExecutor 的方\n式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。\n说明：\nExecutors 返回的线程池对象的弊端如下：\n FixedThreadPool 和SingleThreadPool ： 允许的请求队列长度为\nInteger.MAX_VALUE，可能会堆积大量的请求，从而导致OOM； CachedThreadPool 和ScheduledThreadPool ： 允许的创建线程数量为\nInteger.MAX_VALUE，可能会创建大量的线程，从而导致OOM。  你厉害听你的就行了。\nCp一段线程池相关方法：\n1.shutDown() 关闭线程池，不影响已经提交的任务\n2.shutDownNow() 关闭线程池，并尝试去终止正在执行的线程\n3.allowCoreThreadTimeOut(boolean value) 允许核心线程闲置超时时被回收\n4.submit一般情况下我们使用execute来提交任务，但是有时候可能也会用到submit，使用submit的好处是submit有返回值。使用submit时我们可以通过实现Callable接口来实现异步任务。在call方法中执行异步任务，返回值即为该任务的返回值。Future是返回结果，返回它的isDone属性表示异步任务执行成功！future的get方法是阻塞的，如果已经执行完毕则不会。\n  ","date":"2019-09-27","img":"","permalink":"https://helixs.github.io/posts/2019-09-27-java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%ADsynchronousqueuelinkedblockingqueue%E5%92%8Carrayblockingqueue/","series":null,"tags":null,"title":"Java线程池中SynchronousQueue、LinkedBlockingQueue和ArrayBlockingQueue"},{"categories":["kotlin"],"content":"inline内联函数可以说是kotlin的一个高级特性了，不过在C++其实早就实现了，而java不支持内联函数，不过在jvm运行的时候会有一定的内联优化。\n为什么需要内联 处理器调用一个函数的步骤如下：\n  保留当前执行栈的信息\n  为被调用的函数分配栈区\n  初始化被调用函数中的参数、内部变量\n  执行被调用函数并返回\n  销毁被调用函数的执行栈\n  取出第一步保存的信息并恢复，然后继续执行\n  从这个流程中可以看到，所谓函数调用的开销主要是当前执行栈的保存与恢复、被调用函数栈区的分配与销毁两部分的开销。\n调用函数是一个入栈出栈的过程，意味着需要内存的开销和释放。增加了机器运行的负担，而使用内联函数就在编译器级别，将函数中的代码，直接放入调用函数的地方。这样就减少了一个入栈和出栈的过程，还是很不错的吧。不过相应的，编译后所生成的字节码的长度肯定是要变大的。我们可以根据一定的场景进行内联。\ninline 先来看看kotlin自带的inline函数\n然后我们试试\n然后我们Decompile转为java代码\n我们可以看到main方法中调用printTexts方法已经直接将函数代码放入到了main方法里。\n不过在定义printTexts方法的时候编译器提示了\nexpected performance impact of inlining is insignificant. Inlining works best for functions with parameters of functional types\n刻意将普通方法加入inline并不会给性能带来多少的优化，反而会带来更多的字节码。建议将参数为函数形式的方法使用inline可以提高性能。\n转为java\n我们不加入inline内联实际上调用了printTexts方法中的Function1的回调函数。\n然后在printTexts方法前面加入inline后再看看\n参数为函数类型的函数使用inline的确可以提高性能，避免进入callback回调地狱。其实普通的方法不使用inline的情况下jvm也会帮我们实现部分的，如果需要的话那么你也可以强制使用Inline也没关系。\nnoinline 通过上面的代码我们看到，默认情况下内联函数的的参数如果是函数的话，那么参数函数也是被内联的\n如果函数参数在内联函数的方法体内被其他非内联函数调用,就会报错.\n我们可以加入noinline\n正常，转java\n我们可以看到参数函数不会被内联，而是转为callback了，那么就能正常调用非inline的函数了。\ncrossinline 我们来看一看下面的代码\n答案是不会执行，除非使用的是return@printTexts 。默认内联函数lambda参数中return是可以进行调用函数处return的，因为已经和调用处函数融为一体了。\n我们可以在block参数前加入crossinline来防止printTexts局部return\nreified 其实我个人认为这个reified才是内联函数中最牛逼的玩意儿。在java中我们的泛型在运行时都是一堆object，被擦除了没啥卵用。\n我们来试试哈\n这个操作在java中可能实现吗，答案是不可能的。但是在kotlin中通过inline和reified就可以实现\n这样我们就可以获取到泛型信息了，运行时的哦，困扰我多年的问题终于有办法了。比如我现在直接传入泛型而不用传入class就可以知道T是什么类型了。在java时候还要使用一堆头疼的反射等。其实inline的时候相当于就是吧T类型的class作为一个参数传进来了，还是蛮强大的。看看java代码\n我们可以用来干嘛？\n是不是很强大？也可以通过is和as的方式强转T。so fun。\n","date":"2019-09-11","img":"","permalink":"https://helixs.github.io/posts/2019-09-11-kotlin%E7%89%B9%E6%80%A7%E4%B9%8Binline%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/","series":null,"tags":null,"title":"Kotlin特性之inline内联函数"},{"categories":["数据结构和算法"],"content":"冒泡排序为什么叫冒泡排序 -_- 我们都是宅农，应该都用锅烧过开水，或用来做饭或用来烧汤，不过我在小时候还烧过猪食。等水温达到一定程度，水就开始出了一点泡泡。\n气泡有两个来源：\n1、在水沸腾之前出现的气泡，主要是水中溶解的气体（氮气、氧气等），随着温度升高，它们在水中的溶解度下降，于是析出了气泡\n2、等水沸腾之后大部分气泡就是沸腾产生的水蒸汽了气泡越来越大。\n上浮的过程中气泡会变大主要原因是：pV=nRT，于是气体的体积和压强成反比。水面以下越深，压强就越大，所以上浮的过程是压强减小的过程，也就是体积增大的过程。\n冒泡排序就是差不多这样解释啦。不过这里面还差了一个循环的意思。\n最简单的实现方式 在要排序的一组数中，对当前还未排好序的范围内的全部数，自上而下对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。即：每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。\n这个就是最简单冒泡排序实现办法。时间复杂度=O（n^2）也就是n*n。\n优化 如果对于一个本身有序的序列，或则序列后面一大部分都是有序的序列，上面的算法就会浪费很多的时间开销，这里设置一个标志flag，如果这一趟发生了交换，则为true，否则为false。明显如果有一趟没有发生交换，说明排序已经完成。最好时间复杂度O(n) 最坏O(n^2)\n进一步优化 比如，现在有一个包含1000个数的数组，仅前面100个无序，后面900个都已排好序且都大于前面100个数字，那么在第一趟遍历后，最后发生交换的位置必定小于100，且这个位置之后的数据必定已经有序了，也就是这个位置以后的数据不需要再排序了，于是记录下这位置，第二次只要从数组头部遍历到这个位置就可以了。如果是对于上面的冒泡排序算法2来说，虽然也只排序100次，但是前面的100次排序每次都要对后面的900个数据进行比较，而对于现在的排序算法3，只需要有一次比较后面的900个数据，之后就会设置尾边界，保证后面的900个数据不再被排序。\n那么第三种其实就是最优解啦。\n","date":"2019-09-02","img":"","permalink":"https://helixs.github.io/posts/2019-09-02-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E4%BC%98%E5%8C%96/","series":null,"tags":null,"title":"冒泡排序的概念和优化"},{"categories":["flutter"],"content":" ","date":"2019-08-20","img":"","permalink":"https://helixs.github.io/posts/2019-08-20-flutter-sliverappbar/","series":null,"tags":null,"title":"Flutter SliverAppBar"},{"categories":["Android开发","编程生活"],"content":"前几日，我去外面试了试面试。找找新工作看看有没有合适的。前面基本上很顺利，没有什么特别的难度和问题，本以为可以满怀信心的入职，结果被泼了一盆冷水。被问到关于GC机制的问题，GC算法有哪些，规则如何等等，我懵逼了，我只知道GC是垃圾回收，在内存不够的时候会触发它，然后回收没有引用的内存。然后它是如何实现的可真没有仔细研究过。书到用时方恨少，事非经过不知难。\n在很多年前我们在运行android程序的时候，时不时的会卡顿，我当时不以为然。排除线程和代码相关的情况下多半都与触发了GC有关西。了解才知道，在触发GC线程的时候，其它线程会进行等待，包括UI线程，UI线程卡顿了，那么我们肯定就会卡了。\n可以看看jvm运行时内存分配哪些对象会被回收？ 对于寄存器、栈和本地方法区，他们都是跟随着当前线程走的，线程走完也就消亡了，所以不许要GC去触碰它。\n而GC的主要对象是Java堆，这个地方跟线程的生命周期没有直接关联，就算你方法走完，new的对象也不会马上消失，直到GC的时候才有可能回收它。次要对象就是方法区的常量或者类等，毕竟这个一般也不会大到哪里去。\n对象存活的依据 1、引用计数法  原理：给对象添加一个引用计数器，每当有地方引用时计数器加 1，引用失效时减 1。当该对象引用为 0 时，判定对象失效 优点：实现简单，判定效率高 缺点：很难解决对象之间循环引用的问题  如果 class A,classB都持有对方的引用那么就不可能回收了！。\n \u0026lt;ol\u0026gt; \u0026lt;li\u0026gt; 判断对象是否覆盖了 finalize() 方法 \u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; \u0026lt;p\u0026gt; 如果覆盖了 finalize() 方法，那么将 finalize() 放到 F-Queue 队列中 \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; 如果未覆盖该方法，则直接回收 \u0026lt;/p\u0026gt; \u0026lt;ol start=\u0026quot;2\u0026quot;\u0026gt; \u0026lt;li\u0026gt; 执行 F-Queue 队列中的 finalize() 方法\u0026lt;br /\u0026gt; 由虚拟机自动建立一个优先级较低的线程去执行 F-Queue 中的 finalize() 方法，这里的执行只是触发这些方法并不保证会等待它执行完毕。如果 finalize() 方法作了耗时操作，虚拟机会停止执行并将该对象清除。 \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; 对象销毁或重生\u0026lt;br /\u0026gt; \u0026lt;strong\u0026gt;在 finalize() 方法中，将 this 赋值给某一个引用，那么该对象就重生了。如果没有引用，该对象会被回收\u0026lt;/strong\u0026gt;。 \u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;h5\u0026gt; 方法区的内存回收 \u0026lt;/h5\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt; 废弃的常量：\u0026lt;br /\u0026gt; 当前系统中没有任何对象引用常量池中的该常量，则是废弃常量 \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; 废弃的类判断规则：\u0026lt;br /\u0026gt; 该类所有实例都被回收；\u0026lt;br /\u0026gt; 加载该类的 ClassLoader 已经被回收；\u0026lt;br /\u0026gt; 该类对应的 Class 对象没有引用，也无法通过反射访问该类的方法。 \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;h4\u0026gt; 算法 \u0026lt;/h4\u0026gt; \u0026lt;p\u0026gt; 最基础的收集算法是\u0026amp;#8221;标记 \u0026amp;#8211; 清除\u0026amp;#8221;算法，之所以说它是最基础的是因为它逻辑简单、使用简便，而且后续的收集算法大多基于这种算法的不足而优化的。 \u0026lt;/p\u0026gt; \u0026lt;h5\u0026gt; 1. 标记 \u0026amp;#8211; 清除算法 \u0026lt;/h5\u0026gt; \u0026lt;p\u0026gt; 标记 \u0026amp;#8211; 清除算法分为两个阶段： \u0026lt;/p\u0026gt; \u0026lt;ol\u0026gt; \u0026lt;li\u0026gt; 标记阶段：标记的过程就是前面的可达性分析法执行的过程。首先遍历所有 GC Roots 对象，对从 GC Roots 对象可达的对象都打上一个可达标识。这个可达标识一般记录在对象 header 中（一个对象一般包括对象头、实例数据、对齐填充三个部分），表示该对象可以被 GC Roots 访问。 \u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; \u0026lt;p\u0026gt; \u0026lt;img loading=\u0026quot;lazy\u0026quot; class=\u0026quot;alignleft size-full wp-image-328\u0026quot; src=\u0026quot;https://xmcf.me/wp-content/uploads/2019/07/6762021-18c73d39d1889f60.png\u0026quot; alt=\u0026quot;\u0026quot; width=\u0026quot;660\u0026quot; height=\u0026quot;291\u0026quot; srcset=\u0026quot;https://xmcf.me/wp-content/uploads/2019/07/6762021-18c73d39d1889f60.png 660w, https://xmcf.me/wp-content/uploads/2019/07/6762021-18c73d39d1889f60-300x132.png 300w, https://xmcf.me/wp-content/uploads/2019/07/6762021-18c73d39d1889f60-430x190.png 430w\u0026quot; sizes=\u0026quot;(max-width: 660px) 100vw, 660px\u0026quot; /\u0026gt; \u0026lt;/p\u0026gt;          可以看到，上图 B、E、F、G、J、K 对象是可达对象，所以这些对象的对象头中就会记录可达信息。\n 清除阶段：清除阶段是对堆内存进行遍历，通过读取这些对象的 header 信息来获取对象是否标记可达。如果未标记则表示这些对象没有引用，就可以进行回收。          标记 – 清除算法主要不足有两个：\n 效率问题：标记和清除都需要遍历，效率不高； 空间问题：标记清除后会产生大量不连续的内存水平，空间碎片太多会导致大内存对象无法生成而频繁进行 GC。  2. 复制算法 为了解决效率问题，复制算法出现了。\n 原理：将可用内存按容量大小分为大小相等的两块，每次只使用其中一块。当这一块内存使用完毕，就将存活的对象复制到另一块上，然后再把这一块所有的对象一次性清理掉。 图解：          先将内存区域分为大小相等的两块，只使用其中一块，并标记可达对象。\n        当一块内存使用完毕以后，将其中的可达对象复制到另一块，然后再一次性清除原理的内存空间。\n 优点：简答高效，内存相对整齐 缺点：\n1.将内存分为一半，代价略高。\n2.如果对象存活率高，需要复制的对象比较多，产生效率问题。 优化：\n在新生代中，由于大量的对象都是”朝生夕死”，也就是说一次垃圾收集后存活对象较少，因此我们可以把内存划分为三块：Eden、Survior1、Survior2，大小比例为 8:1:1。分配内存时只使用 Eden + Survior1，当这里的内存将满时，JVM 会出发一次 MinorGC，清除掉废弃对象，并将存活对象复制到另一块 Survior2 中。那么接下来就使用 Eden + Survior2 进行内存分配。通过这种方式只需浪费 10% 的内存空间即可实现复制清除算法，同时避免了内存碎片的问题。  3. 标记 – 整理算法  原理：标记过程与 “标记 – 清除” 算法相同，但后续不是直接对可回收对象进行清理，而是让所有存活对象都向一端移动，然后直接清理掉一端边界外的内存。                         优点：无需复制，保证效率。内存规整。 缺点：效率不如复制算法。  \u0026lt;p\u0026gt; 在了解了以上三种 GC 算法以后，作一个简单的排行： \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; \u0026lt;strong\u0026gt;效率：\u0026lt;/strong\u0026gt;复制算法 \u0026gt; 标记 \u0026amp;#8211; 整理算法 \u0026gt; 标记 \u0026amp;#8211; 清除 算法（标记 \u0026amp;#8211; 清除会产生内存碎片，需要大内存时会出发新一轮 GC）。 \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; \u0026lt;strong\u0026gt;内存规整率：\u0026lt;/strong\u0026gt;复制算法 = 标记 \u0026amp;#8211; 整理 \u0026gt; 标记 \u0026amp;#8211; 清除。 \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; \u0026lt;strong\u0026gt;内存利用率：\u0026lt;/strong\u0026gt;标记 \u0026amp;#8211; 整理算法 = 标记 \u0026amp;#8211; 清除算法 \u0026gt; 复制算法。 \u0026lt;/p\u0026gt;   \u0026lt;p\u0026gt; 当前商业虚拟机的垃圾收集都采用 \u0026amp;#8220;分代收集\u0026amp;#8221; 算法，这种相当于结合以上几种算法进行结合。 \u0026lt;/p\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt; 原理：把 Java 堆分为新生代和老年代，根据各个对象的年代采用最合适的收集算法。\u0026lt;br /\u0026gt; 针对新生代的对象，采取灵活比例的复制算法，只需要复制少量存活对象就可以完成收集。\u0026lt;br /\u0026gt; 针对老年代的对象，因为这些对象存活率高，没有额外空间进行分配担保，必须使用 标记 \u0026amp;#8211; 清除 或 标记 \u0026amp;#8211; 整理 算法。 \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt;  \u0026lt;div\u0026gt; \u0026lt;p\u0026gt; 几乎所有新生成的对象首先都是放在年轻代的。新生代内存按照8:1:1的比例分为一个Eden区和两个Survivor(Survivor0,Survivor1)区。大部分对象在Eden区中生成。当新对象生成，Eden Space申请失败（因为空间不足等），则会发起一次GC(Scavenge GC)。回收时先将Eden区存活对象复制到一个Survivor0区，然后清空Eden区，当这个Survivor0区也存放满了时，则将Eden区和Survivor0区存活对象复制到另一个Survivor1区，然后清空Eden和这个Survivor0区，此时Survivor0区是空的，然后将Survivor0区和Survivor1区交换，即保持Survivor1区为空， 如此往复。当Survivor1区不足以存放 Eden和Survivor0的存活对象时，就将存活对象直接存放到老年代。当对象在Survivor区躲过一次GC的话，其对象年龄便会加1，默认情况下，如果对象年龄达到15岁，就会移动到老年代中。若是老年代也满了就会触发一次Full GC，也就是新生代、老年代都进行回收。新生代大小可以由-Xmn来控制，也可以用-XX:SurvivorRatio来控制Eden和Survivor的比例。 \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; 老年代:\u0026lt;i\u0026gt;\u0026lt;b\u0026gt;Old Generation\u0026lt;/b\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p\u0026gt; 在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。内存比新生代也大很多(大概比例是1:2)，当老年代内存满时触发Major GC即Full GC，Full GC发生频率比较低，老年代对象存活时间比较长，存活率标记高。一般来说，大对象会被直接分配到老年代。所谓的大对象是指需要大量连续存储空间的对象，最常见的一种大对象就是大数组。比如： byte[] data = new byte[4*1024*1024] 这种一般会直接在老年代分配存储空间。 当然分配的规则并不是百分之百固定的，这要取决于当前使用的是哪种垃圾收集器组合和JVM的相关参数。 \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; 永久代 or 元空间 \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; 用于存放静态文件（class类、方法）和常量等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如Hibernate 等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。对永久代的回收主要回收两部分内容：废弃常量和无用的类。 \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; 永久代空间在Java SE8特性中已经被移除。取而代之的是元空间（MetaSpace）。因此不会再出现“java.lang.OutOfMemoryError: PermGen error”错误。 \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; \u0026amp;nbsp; \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ","date":"2019-07-30","img":"","permalink":"https://helixs.github.io/posts/2019-07-30-java-gc%E7%AE%80%E5%8D%95%E8%AE%A4%E8%AF%86/","series":null,"tags":null,"title":"Java GC简单认识"},{"categories":["Android开发","编程生活"],"content":"前几日，我去外面试了试面试。找找新工作看看有没有合适的。前面基本上很顺利，没有什么特别的难度和问题，本以为可以满怀信心的入职，结果被泼了一盆冷水。被问到关于GC机制的问题，GC算法有哪些，规则如何等等，我懵逼了，我只知道GC是垃圾回收，在内存不够的时候会触发它，然后回收没有引用的内存。然后它是如何实现的可真没有仔细研究过。书到用时方恨少，事非经过不知难。\n在很多年前我们在运行android程序的时候，时不时的会卡顿，我当时不以为然。排除线程和代码相关的情况下多半都与触发了GC有关西。了解才知道，在触发GC线程的时候，其它线程会进行等待，包括UI线程，UI线程卡顿了，那么我们肯定就会卡了。\njvm运行时内存分配 1、栈 英文stack，运行于RAM之上。stack最主要的特征即是先进后出。栈内存上面有一个指针，和C语言的指针差不多，指针的加减直接影响栈内存的创建和释放。当载入一个新方法的时候，指针+，方法执行完毕，指针-。这是一种特别快、特别有效的数据保存方式，仅次于寄存器。创建程序时，Java编译器必须准确地知道堆栈内保存的所有数据的“长度”以及“存在时间”。这是由于它必须生成相应的代码，以便移动指针。\n 每个线程包含一个栈区，栈中只保存基本数据类型的数据和自定义对象的引用(不是对象)，对象都存放在堆区中。 每个栈中的数据(原始类型和对象引用)都是私有的，其他栈不能访问。 栈分为3个部分：基本数据类型的变量区、执行环境上下文、操作指令区(存放操作指令)。  栈是存放线程调用方法时存储局部变量表，操作，方法出口等与方法执行相关的信息，Java栈所占内存的大小由Xss来调节，方法调用层次太多会撑爆这个区域即_StackOverflowError。_\nps:这让我想起了递归，如果递归层级过多，不进行尾递归优化那么方法一直在载入没有执行完毕，那么一记StackOverflowError送给你\n程序计数器（ProgramCounter）寄存器 是cpu的一部分，离cpu最近，速度也最快。每个线程启动的时候，都会创建一个寄存器，保存正在执行jvm指令的地址和下一步指令的地址。寄存器的内容总是指向下一条将被执行指令的地址，这里的地址可以是一个本地指针，也可以是在方法区中相对应于该方法起始指令的偏移量。\nps:想想为什么需要保存啊，不是直接执行就行了么。NONONO，现在程序都是多线程运行的，cpu要同时执行多条命令呀！这句话说的也不对，多线程是个假象，就算是32核64线程也是假象，cpu短时间内会在不同线程之间切换运行指令，造成一种同时运行多任务的假象，不过假象很有效，足以骗过我们愚蠢的人类。所以任务切来切去不找个地方保存下一步需要执行的地方，我回过神来就会迷失方向了。\n本地方法栈(也叫本地方法区) Nativemethodstack(本地方法栈)：保存native方法进入区域的地址。\n方法区 method（方法区）又叫静态区，存放所有的①类（class），②静态变量（static变量），③静态方法，④常量和⑤成员方法。\n1.又叫静态区，跟堆一样，被所有的线程共享。\n2.方法区中存放的都是在整个程序中永远唯一的元素。这也是方法区被所有的线程共享的原因。\n（顺便展开静态变量和常量的区别： 静态变量本质是变量，是整个类所有对象共享的一个变量，其值一旦改变对这个类的所有对象都有影响；常量一旦赋值后不能修改其引用，其中基本数据类型的常量不能修改其值。）\nJava里面是没有静态变量这个概念的，不信你自己在某个成员方法里面定义一个static int i = 0；Java里只有静态成员变量。它属于类的属性。至于他放哪里？楼上说的是静态区。我不知道到底有没有这个翻译。但是深入JVM里是翻译为方法区的。虚拟机的体系结构：①Java栈，② 堆，③PC寄存器，④方法区，⑤本地方法栈，⑥运行常量池。而方法区保存的就是一个类的模板，堆是放类的实例（即对象）的。栈是一般来用来函数计算的。随便找本计算机底层的书都知道了。栈里的数据，函数执行完就不会存储了。这就是为什么局部变量每一次都是一样的。就算给他加一后，下次执行函数的时候还是原来的样子。\n方法区的大小由-XX:PermSize和-XX:MaxPermSize来调节，类太多有可能撑爆永久代。静态变量或常量也有可能撑爆方法区。\n 方法区的位置有三种情况：\njava7之前，方法区位于永久代(PermGen)，永久代和堆相互隔离，永久代的大小在启动JVM时可以设置一个固定值，不可变； java7中，存储在永久代的部分数据就已经转移到Java Heap或者Native memory。但永久代仍存在于JDK 1.7中，并没有完全移除，譬如符号引用(Symbols)转移到了native memory；字符串常量池(interned strings)转移到了Java heap；类的静态变量(class statics)转移到了Java heap。 java8中，取消永久代，方法存放于元空间(Metaspace)，元空间仍然与堆不相连，但与堆共享物理内存，逻辑上可认为在堆中  Native memory：本地内存，也称为C-Heap，是供JVM自身进程使用的。当Java Heap空间不足时会触发GC，但Native memory空间不够却不会触发GC。\n为什么移除永久代？\n1、字符串存在永久代中，容易出现性能问题和内存溢出。\n2、永久代大小不容易确定，PermSize指定太小容易造成永久代OOM\n3、永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。\n4、Oracle 可能会将HotSpot 与 JRockit 合二为一。\n堆 类的对象放在heap（堆）中，所有的类对象都是通过new方法创建，创建后，在stack（栈）会创建类对象的引用（内存地址）。\n一种常规用途的内存池（也在RAM（随机存取存储器 ）区域），其中保存了Java对象。和栈不同：“内存堆”或“堆”最吸引人的地方在于编译器不必知道要从堆里分配多少存储空间，也不必知道存储的数据要在堆里停留多长的时间。因此，用堆保存数据时会得到更大的灵活性。要求创建一个对象时，只需用new命令编辑相应的代码即可。执行这些代码时，会在堆里自动进行数据的保存。当然，为达到这种灵活性，必然会付出一定的代价：在堆里分配存储空间时会花掉更长的时间。\nJVM将所有对象的实例（即用new创建的对象）（对应于对象的引用（引用就是内存地址））的内存都分配在堆上，堆所占内存的大小由-Xmx指令和-Xms指令来调节。\n运行常量池 这儿的“静态”是指“位于固定位置”。程序运行期间，静态存储的数据将随时等候调用。可用static关键字指出一个对象的特定元素是静态的。但Java对象本身永远都不会置入静态存储空间。\n这个区域属于方法区。该区域存放类和接口的常量，除此之外，它还存放成员变量和成员方法的所有引用。当一个成员变量或者成员方法被引用的时候，JVM就通过运行常量池中的这些引用来查找成员变量和成员方法在内存中的的实际地址。\n举个例子 命令 java AppMain\n        系统收到了我们发出的指令，启动了一个Java虚拟机进程，这个进程首先从classpath中找到AppMain.class文件，读取这个文件中的二进制数据，然后把Appmain类的类信息存放到运行时数据区的方法区中。这一过程称为AppMain类的加载过程。\n接着，JVM定位到方法区中AppMain类的Main()方法的字节码，开始执行它的指令。这个main()方法的第一条语句就是：\nSample test1 = new Sample(“测试1”);\n语句很简单啦，就是让JVM创建一个Sample实例，并且呢，使引用变量test1引用这个实例。貌似小case一桩哦，就让我们来跟踪一下JVM，看看它究竟是怎么来执行这个任务的：\n1、Java虚拟机一看，不就是建立一个Sample类的实例吗，简单，于是就直奔方法区（方法区存放已经加载的类的相关信息，如类、静态变量和常量）而去，先找到Sample类的类型信息再说。结果呢，嘿嘿，没找到@@，这会儿的方法区里还没有Sample类呢（即Sample类的类信息还没有进入方法区中）。可JVM也不是一根筋的笨蛋，于是，它发扬“自己动手，丰衣足食”的作风，立马加载了Sample类， 把Sample类的相关信息存放在了方法区中。\n2、Sample类的相关信息加载完成后。Java虚拟机做的第一件事情就是在堆中为一个新的Sample类的实例分配内存，这个Sample类的实例持有着指向方法区的Sample类的类型信息的引用（Java中引用就是内存地址）。这里所说的引用，实际上指的是Sample类的类型信息在方法区中的内存地址，其实，就是有点类似于C语言里的指针啦~~，而这个地址呢，就存放了在Sample类的实例的数据区中。\n3、在JVM中的一个进程中，每个线程都会拥有一个方法调用栈，用来跟踪线程运行中一系列的方法调用过程，栈中的每一个元素被称为栈帧，每当线程调用一个方法的时候就会向方法栈中压入一个新栈帧。这里的帧用来存储方法的参数、局部变量和运算过程中的临时数据。OK，原理讲完了，就让我们来继续我们的跟踪行动！位于“=”前的test1是一个在main()方法中定义的变量，可见，它是一个局部变量，因此，test1这个局部变量会被JVM添加到执行main()方法的主线程的Java方法调用栈中。而“=”将把这个test1变量指向堆区中的Sample实例，也就是说，test1这个局部变量持有指向Sample类的实例的引用（即内存地址）。\n接下来，JVM将继续执行后续指令，在堆区里继续创建另一个Sample类的实例，然后依次执行它们的printName()方法。当JVM执行test1.printName()方法时，JVM根据局部变量test1持有的引用，定位到堆中的Sample类的实例，再根据Sample类的实例持有的引用，定位到方法区中Sample类的类型信息（包括①类，②静态变量，③静态方法，④常量和⑤成员方法），从而获取printName()成员方法的字节码，接着执行printName()成员方法包含的指令。\n","date":"2019-07-29","img":"","permalink":"https://helixs.github.io/posts/2019-07-29-java-gc%E7%9A%84%E7%AE%80%E5%8D%95%E8%AE%A4%E8%AF%86/","series":null,"tags":null,"title":"Jvm运行时内存分配"},{"categories":["Android开发","linux常用配置"],"content":" 转载请注明出处https://xmcf.me/?p=314 我们做app开发的时候，往往需要对应用信息安全做考虑。通过charles fiddler抓取http包是很随意的事情，https中间人也是很容易。所以做一个信任所有证书的商业应用来说是很low。\n拿android开发为例，如果考虑安全，必须进行证书锁定。如，通过network_security_config文件进行锁定。通过digest摘要来验证证书，而不用将证书放入到apk中，具体的不多说。\n下面是X509公钥证书的格式标准，另外还有中间机构和根证书就不说明了\n公钥证书的信息大概就是这些，在window的chrome我们可以随时到处证书就像这样\n两个格式的主要区别：\n虽然他们保存文件的的后缀都是cer区别就是der是保存的二进制文件，看不到里面的内容。\n而base64编码实际上是pem格式的证书。开头—–BEGIN CERTIFICATE—– 结尾 —–END CERTIFICATE—–\n他们最终包含的信息都是一样的，注意的是base64可以用文本编辑内容，不过不要随意修改多一个少一个空格也是不好的。\n保存完后我们就要通过openssl进行获取证书公钥的摘要了\nopenssl登场\n因为我用的win10系统装了个linux内核还是蛮舒服的\n其大概过程是，1、让openssl安装x509公钥的标准读取证书信息 ，-pubkey 读取公钥 2、通过pkey -pukey 读取密钥信息通过-outform 按照der格式保存密钥信息 3、dgst按照sha256 进行hash计算得到了2进制数据 4、将二进制信息通过base64编码。最终就是我们所需要的信息了，我们得到的信息是通过hash计算不可逆的，所以保证了一定的安全性。\nandroid项目通过\n ","date":"2019-07-23","img":"","permalink":"https://helixs.github.io/posts/2019-07-23-%E9%80%9A%E8%BF%87openssl%E8%8E%B7%E5%8F%96%E8%AF%81%E4%B9%A6%E6%91%98%E8%A6%81%E4%BF%A1%E6%81%AF/","series":null,"tags":null,"title":"通过openssl获取证书摘要信息"},{"categories":["flutter"],"content":"转载请注明出处https://xmcf.me/?p=312  前些天使用Flutter的dio库进行post请求。说来也怪。服务器只允许使用application/x-www-form-urlencoded方式接收数据，data数据格式大概如下。\ndataArr=[{“type”:”file”,”path”:”xxxx/wsdsd.txt”}]想了想用json不就行了么。form好麻烦。奈何你只是服务者。直接用dio库进行请求，contentType设置为application/x-www-form-urlencoded。就像这样\n请求失败了，服务器接收数据格式错误。怎么查文档也不行，只能看dio源代码入手。找到RequestOptions看看他是如何做data编码的，找到DefaultTransformer.transformRequest(RequestOptions options)\n再找到 Transformer.urlEncodeMap(data)\n得到的结果是\n晕，我也没时间看它错在哪里了，看来做好的办法就是自己进行encode编码了，也就是除了key=value之间的=号其他都要进行url编码，毕竟=才是唯一标准，看来dio库也是有bug的。顺便提一下，flutter的log居然从来不打双引号或者单引号，String看起来真麻烦。\n按照刚才的例子直接改成\n这样就可以了。\n —-坑一直很多，需要一步一步的填。\n","date":"2019-07-22","img":"","permalink":"https://helixs.github.io/posts/2019-07-22-flutter-dio%E8%BF%9B%E8%A1%8Capplication-x-www-form-urlencoded%E8%AF%B7%E6%B1%82%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/","series":null,"tags":null,"title":"Flutter.dio进行application/X-Www-Form-Urlencoded请求注意事项"},{"categories":["Android开发"],"content":"转载请注明出处https://xmcf.me/?p=309 今天测试提示了bug，在文件上传的时候会有进度显示，可是每次都会显示200%。找了半天也没有找到具体的问题所在。所以，我就从上传触发点入手了。\n原代码如下按道理来说这样执行都没啥问题的，不过它居然执行了两次。没办法了，去看Okhttp的源码，还是被我找到了\n上面是第一次，下面是第二次\n看看Okio.buffer中是什么\n 执行顺序大概是\n第一次\u0026gt;\nHttpLoggingInterceptor.intercept-\u0026gt;MultipartBody.writeTo(BufferedSink)=\u0026gt;writeOrCountBytes(BufferedSink)=\u0026gt;PartBody.writeTo(BufferedSink)=\u0026gt;我们实现的writeTo(BufferedSink)\n第二次\u0026gt;\nCallServerInterceptor.intercept-\n MultipartBody.writeTo(BufferedSink)=\u0026gt;writeOrCountBytes(BufferedSink)=\u0026gt;PartBody.writeTo(BufferedSink)=\u0026gt;我们实现的writeTo(BufferedSink)\n 除了调用的地方，其他后续操作都一样，不一样的主要就是一个是writeTo(Buffer)一个是writeTo(RealBufferedSink)\n看看BufferedSink｛\n子类为Buffer和RealBufferedSink\n｝\n再看看RealBufferedSink{\n}\n由此可知，Buffer和RealBufferedSink都是BufferedSink的实现类，RealBufferedSink中拥有Buffer成员,write的时候真正也是调用的Buffer.write。\n所以我们可以通过判断BufferedSink的两个子类型来判断进行过滤。修改后的代码为\n测试一下好了。数据的Request和Response都会进入Okhttp的拦截器过滤和观察我们的数据，执行读取操作。除了我们自己添加的log拦截，默认还有自带的拦截器，他们会形成一个任务链模式。有人说直接把Httplog的等级改成Head那是很蠢的做法，那你还观察什么数据呢。或者自定义Log拦截器，把MultipartBody类型的日志过滤掉，这才是正确的做法，毕竟logcat里面弹出一堆乱码也是很烦的一件事。\n 转载请注明出处https://xmcf.me/?p=309 ","date":"2019-07-19","img":"","permalink":"https://helixs.github.io/posts/2019-07-19-okhttp%E5%8D%95%E4%B8%80%E8%AF%B7%E6%B1%82requestbody%E6%89%A7%E8%A1%8C%E4%B8%A4%E6%AC%A1writeto%E7%9A%84%E9%97%AE%E9%A2%98/","series":null,"tags":null,"title":"OkHttp单一请求RequestBody执行两次writeTo的问题"},{"categories":["linux常用配置"],"content":"数据流重导向3个方式发送的文件或者设备上\n 标准输入　（stdin） ：代码为 0 ，使用 \u0026lt;(指定标准输入文件或者设备) 或 \u0026laquo;(后面跟上内容如字符串可以结束输入) ； 标准输出　（stdout）：代码为 1 ，使用 \u0026gt;(覆盖输出设备或文件的数据) 或 \u0026raquo;(累加输出设备或文件的数据)； 标准错误输出（stderr）：代码为 2 ，使用 2\u0026gt; 或 2\u0026raquo; ；(和标准输出一样，只不过是错误信息)  错误输出数据和正确输出一样，只需在后面跟上2\u0026gt;或者2\u0026raquo;\n\u0026amp;\u0026amp;和||跟编程代码中的与和或很像\n管道命令 cut主要的用途是将同一行里面的数据按照规定的字符进行拆分，有点像java中的String.split。\ncut是取出一行一行中我们想要的,那么grep就是过滤一行一行的的数据，过滤包含或者不包含的数据\n sort  sort 是很有趣的指令，他可以帮我们进行排序，而且可以依据不同的数据型态来排序喔！ 例如数字与文字的排序就不一样。此外，排序的字符与语系的编码有关，因此， 如果您需要排序时，建议使用 LANG=C 来让语系统一，数据排序比较好一些。\n wc  如果我想要知道 /etc/man_db.conf 这个文件里面有多少字？多少行？多少字符的话， 可以怎么做呢？其实可以利用 wc 这个指令来达成喔！他可以帮我们计算输出的讯息的整体数据！\n uniq   tee  会将数据流整个传送给文件或设备，因此我们除非去读取该文件或设备， 否则就无法继续利用这个数据流。万一我想要将这个数据流的处理过程中将某段讯息存下来，应该怎么做？ 利用 tee 就可以啰～\ntee 会同时将数据流分送到文件去与屏幕 （screen）；而输出到屏幕的，其实就是 stdout ，那就可以让下个指令继续处理喔！\ntee 可以让 standard output 转存一份到文件内并将同样的数据继续送到屏幕去处理！ 这样除了可以让我们同时分析一份数据并记录下来之外，还可以作为处理一份数据的中间暂存盘记录之用！\n tr  tr 可以用来删除一段讯息当中的文字，或者是进行文字讯息的替换！\n其实这个指令也可以写在“正则表达式”里头！因为他也是由正则表达式的方式来取代数据的！ 以上面的例子来说，使用 [] 可以设置一串字呢！也常常用来取代文件中的怪异符号！ 例如上面第三个例子当中，可以去除 DOS 文件留下来的 ^M 这个断行的符号！这东西相当的有用！相信处理 Linux \u0026amp; Windows 系统中的人们最麻烦的一件事就是这个事情啦！亦即是 DOS 下面会自动的在每行行尾加入 ^M 这个断行符号！这个时候除了以前讲过的 dos2unix 之外，我们也可以使用这个 tr 来将 ^M 去除！ ^M 可以使用 \\r 来代替之！\n col  虽然 col 有他特殊的用途，不过，很多时候，他可以用来简单的处理将 [tab] 按键取代成为空白键！ 例如上面的例子当中，如果使用 cat -A 则 [tab] 会以 ^I 来表示。 但经过 col -x 的处理，则会将 [tab] 取代成为对等的空白键！\n join   paste  这个 paste 就要比 join 简单多了！相对于 join 必须要比对两个文件的数据相关性， paste 就直接“将两行贴在一起，且中间以 [tab] 键隔开”而已！简单的使用方法：\n expand  这玩意儿就是在将 [tab] 按键转成空白键啦～可以这样玩：\n split  如果你有文件太大，导致一些携带式设备无法复制的问题，嘿嘿！找 split 就对了！ 他可以帮你将一个大文件，依据文件大小或行数来分区，就可以将大文件分区成为小文件了！ 快速又有效啊！真不错～\n xargs  xargs 是在做什么的呢？就以字面上的意义来看， x 是加减乘除的乘号，args 则是 arguments （参数） 的意思，所以说，这个玩意儿就是在产生某个指令的参数的意思！ xargs 可以读入 stdin 的数据，并且以空白字符或断行字符作为分辨，将 stdin 的数据分隔成为 arguments 。 因为是以空白字符作为分隔，所以，如果有一些文件名或者是其他意义的名词内含有空白字符的时候， xargs 可能就会误判了～他的用法其实也还满简单的！就来看一看先！\n –  上面这个例子是说：“我将 /home 里面的文件给他打包，但打包的数据不是纪录到文件，而是传送到 stdout； 经过管线后，将 tar -cvf – /home 传送给后面的 tar -xvf – ”。后面的这个 – 则是取用前一个指令的 stdout， 因此，我们就不需要使用 filename 了！这是很常见的例子喔！注意注意！\n","date":"2019-06-12","img":"","permalink":"https://helixs.github.io/posts/2019-06-12-bash-shell-%E6%95%B0%E6%8D%AE%E6%B5%81%E9%87%8D%E5%AF%BC%E5%90%91%E4%B8%8E%E7%AE%A1%E9%81%93%E7%9A%84%E7%AE%80%E5%8D%95%E8%AE%A4%E8%AF%86/","series":null,"tags":null,"title":"Bash Shell 数据流重导向与管道的简单认识"},{"categories":["linux常用配置"],"content":"编辑命令  Ctrl + a ：移到命令行首 Ctrl + e ：移到命令行尾 Ctrl + f ：按字符前移（右向） Ctrl + b ：按字符后移（左向） Alt + f ：按单词前移（右向） Alt + b ：按单词后移（左向） Ctrl + xx：在命令行首和光标之间移动 Ctrl + u ：从光标处删除至命令行首 Ctrl + k ：从光标处删除至命令行尾 Ctrl + w ：从光标处删除至字首 Alt + d ：从光标处删除至字尾 Ctrl + d ：删除光标处的字符 Ctrl + h ：删除光标前的字符 Ctrl + y ：粘贴至光标后 Alt + c ：从光标处更改为首字母大写的单词 Alt + u ：从光标处更改为全部大写的单词 Alt + l ：从光标处更改为全部小写的单词 Ctrl + t ：交换光标处和之前的字符 Alt + t ：交换光标处和之前的单词 Alt + Backspace：与 Ctrl + w 相同类似，分隔符有些差别  重新执行命令  Ctrl + r：逆向搜索命令历史 Ctrl + g：从历史搜索模式退出 Ctrl + p：历史中的上一条命令 Ctrl + n：历史中的下一条命令 Alt + .：使用上一条命令的最后一个参数  控制命令  Ctrl + l：清屏 Ctrl + o：执行当前命令，并选择上一条命令 Ctrl + s：阻止屏幕输出 Ctrl + q：允许屏幕输出 Ctrl + c：终止命令 Ctrl + z：挂起命令  Bang (!) 命令  !!：执行上一条命令 !blah：执行最近的以 blah 开头的命令，如 !ls !blah:p：仅打印输出，而不执行 !$：上一条命令的最后一个参数，与 Alt + . 相同 !$:p：打印输出 !$ 的内容 !*：上一条命令的所有参数 !*:p：打印输出 !* 的内容 ^blah：删除上一条命令中的 blah ^blah^foo：将上一条命令中的 blah 替换为 foo ^blah^foo^：将上一条命令中所有的 blah 都替换为 foo  vi/vim常用快捷键","date":"2019-06-11","img":"","permalink":"https://helixs.github.io/posts/2019-06-11-bash-shell%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/","series":null,"tags":null,"title":"Bash Shell常用快捷键"},{"categories":["linux常用配置","开发环境"],"content":" 第一部份：一般指令模式可用的按钮说明，光标移动、复制贴上、搜寻取代等  \u0026lt;td\u0026gt; 光标向左移动一个字符 \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 光标向下移动一个字符 \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 光标向上移动一个字符 \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 光标向右移动一个字符 \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 屏幕“向下”移动一页，相当于 [Page Down]按键 （常用） \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 屏幕“向上”移动一页，相当于 [Page Up] 按键 （常用） \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 屏幕“向下”移动半页 \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 屏幕“向上”移动半页 \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 光标移动到非空白字符的下一列 \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 光标移动到非空白字符的上一列 \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 那个 n 表示“数字”，例如 20 。按下数字后再按空白键，光标会向右移动这一列的 n 个字符。例如 20\u0026lt;space\u0026gt; 则光标会向后面移动 20 个字符距离。 \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 这是数字“ 0 ”：移动到这一列的最前面字符处 （常用） \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 移动到这一列的最后面字符处（常用） \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 光标移动到这个屏幕的最上方那一列的第一个字符 \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 光标移动到这个屏幕的中央那一列的第一个字符 \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 光标移动到这个屏幕的最下方那一列的第一个字符 \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 移动到这个文件的最后一列（常用） \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; n 为数字。移动到这个文件的第 n 列。例如 20G 则会移动到这个文件的第 20 列（可配合 :set nu） \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 移动到这个文件的第一列，相当于 1G 啊！ （常用） \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; n 为数字。光标向下移动 n 列（常用） \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 向光标之下寻找一个名称为 word 的字串。例如要在文件内搜寻 vbird 这个字串，就输入 /vbird 即可！ （常用） \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 向光标之上寻找一个字串名称为 word 的字串。 \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 这个 n 是英文按键。代表“\u0026lt;u\u0026gt;重复前一个搜寻的动作\u0026lt;/u\u0026gt;”。举例来说， 如果刚刚我们执行 /vbird 去向下搜寻 vbird 这个字串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字串！ \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 这个 N 是英文按键。与 n 刚好相反，为“反向”进行前一个搜寻动作。 例如 /vbird 后，按下 N 则表示“向上”搜寻 vbird 。 \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; n1 与 n2 为数字。在第 n1 与 n2 列之间寻找 word1 这个字串，并将该字串取代为 word2 ！举例来说，在 100 到 200 列之间搜寻 vbird 并取代为 VBIRD 则：“:100,200s/vbird/VBIRD/g”。（常用） \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 从第一列到最后一列寻找 word1 字串，并将该字串取代为 word2 ！（常用） \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 从第一列到最后一列寻找 word1 字串，并将该字串取代为 word2 ！且在取代前显示提示字符给使用者确认 （confirm） 是否需要取代！（常用） \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 在一列字当中，x 为向后删除一个字符 （相当于 [del] 按键）， X 为向前删除一个字符（相当于 [backspace] 亦即是倒退键） （常用） \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， “10x”。 \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 删除光标所在的那一整列（常用） \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; n 为数字。删除光标所在的向下 n 列，例如 20dd 则是删除 20 列 （常用） \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 删除光标所在到第一列的所有数据 \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 删除光标所在到最后一列的所有数据 \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 删除光标所在处，到该列的最后一个字符 \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 那个是数字的 0 ，删除光标所在处，到该列的最前面一个字符 \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 复制光标所在的那一列（常用） \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; n 为数字。复制光标所在的向下 n 列，例如 20yy 则是复制 20 列（常用） \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 复制光标所在列到第一列的所有数据 \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 复制光标所在列到最后一列的所有数据 \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 复制光标所在的那个字符到该列行首的所有数据 \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 复制光标所在的那个字符到该列行尾的所有数据 \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; p 为将已复制的数据在光标下一列贴上，P 则为贴在光标上一列！ 举例来说，我目前光标在第 20 列，且已经复制了 10 列数据。则按下 p 后， 那 10 列数据会贴在原本的 20 列之后，亦即由 21 列开始贴。但如果是按下 P 呢？ 那么原本的第 20 列会被推到变成 30 列。 （常用） \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 将光标所在列与下一列的数据结合成同一列 \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 重复删除多个数据，例如向下删除 10 列，[ 10cj ] \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 复原前一个动作。（常用） \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 重做上一个动作。（常用） \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 不要怀疑！这就是小数点！意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点“.”就好了！ （常用） \u0026lt;/td\u0026gt;   第二部份：一般指令模式切换到编辑模式的可用的按钮说明  \u0026lt;td\u0026gt; 进入插入模式（Insert mode）：i 为“从目前光标所在处插入”， I 为“在目前所在列的第一个非空白字符处开始插入”。 （常用） \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 进入插入模式（Insert mode）：a 为“从目前光标所在的下一个字符处开始插入”， A 为“从光标所在列的最后一个字符处开始插入”。（常用） \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 进入插入模式（Insert mode）：这是英文字母 o 的大小写。o 为“在目前光标所在的下一列处插入新的一列”； O 为在目前光标所在处的上一列插入新的一列！（常用） \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 进入取代模式（Replace mode）：r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；（常用） \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 退出编辑模式，回到一般指令模式中（常用） \u0026lt;/td\u0026gt;   第三部份：一般指令模式切换到命令行界面的可用按钮说明  \u0026lt;td\u0026gt; 将编辑的数据写入硬盘文件中（常用） \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 若文件属性为“只读”时，强制写入该文件。不过，到底能不能写入， 还是跟你对该文件的文件权限有关啊！ \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 离开 vi （常用） \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 若曾修改过文件，又不想储存，使用 ! 为强制离开不储存盘案。 \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 储存后离开，若为 :wq! 则为强制储存后离开 （常用） \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 这是大写的 Z 喔！若文件没有更动，则不储存离开，若文件已经被更动过，则储存后离开！ \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 将编辑的数据储存成另一个文件（类似另存新文件） \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 在编辑的数据中，读入另一个文件的数据。亦即将 “filename” 这个文件内容加到光标所在列后面 \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 将 n1 到 n2 的内容储存成 filename 这个文件。 \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 暂时离开 vi 到命令行界面下执行 command 的显示结果！例如 “:! ls /home”即可在 vi 当中察看 /home 下面以 ls 输出的文件信息！ \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 显示行号，设置之后，会在每一列的字首显示该列的行号 \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 与 set nu 相反，为取消行号！ \u0026lt;/td\u0026gt;          来自鸟哥的linux私房菜","date":"2019-06-04","img":"","permalink":"https://helixs.github.io/posts/2019-06-04-vi-vim%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/","series":null,"tags":null,"title":"Vi/Vim常用快捷键"},{"categories":["C"],"content":" 结果：\n红色是输入部分，**printf默认不会加回车，puts会在后面加入回车。**定义的inputs数组的最大只有10，我所输入的所有字符都打印出来了，所以gets函数并没有检查也无法检查inputs所占用的空间和范围，毕竟读取字符串也只能按照\\0结尾。\n然后再来看看fgets()多了最大值和字符从那个地方获取。地方我们用默认就行了，毕竟不太懂。仔细数一数打印出来了多少个，其实是29个,看来第30个添加结束标志\\0。末尾的样子就是I\\0了\n所以我们以后输入字符串最好用fgets不要用gets。\n ==看看输入字符后完整内存看看\n结果\n就算少输几位后面也就是0 10 0 0 0，fgets无论你怎么输入都会在\\0后面加入\\n ascii为10，所以我们以后最好在判断\\0的\\n情况咯。\n ","date":"2019-05-30","img":"","permalink":"https://helixs.github.io/posts/2019-05-30-c%E8%AF%AD%E8%A8%80stdio%E4%B8%ADfgets%E5%92%8Cgetsputs%E7%9A%84%E5%8C%BA%E5%88%AB/","series":null,"tags":null,"title":"C语言stdio中fgets和gets、puts的区别"},{"categories":["电影生活"],"content":"如果你想无拘无束，天天看自己喜欢的美剧，请耐心看完这篇文章。因为如果你不学会这个技能，总有一天你只能看删减版。\n先介绍一下你看的美剧从哪里来。\n从美国电视，流媒体（Hulu，Netflix，亚马逊）来，国外有专门的兴趣小组从电视及流媒体录制片源然后在国外各大资源站传播，传播方式以BT为主。\n顶级渠道是0 day次级是PT，再次是BT。但是因为网络的发展，这三个渠道的传播速度已经基本相同，普通人也能第一时间获取美剧片源。\n那么重点来了在海盗湾淡出历史舞台后，哪个是最大的BT资源站？\n请百度rarbg（浏览这个网站务必安装广告拦截插件）,哈哈顺便一句google是不会让你搜到它的，度娘可以搜到，纯国外网友建立，你想要的游戏，电影，美剧，XXX，基本都能找到。不过都是无字幕纯英文版，即生肉。\nrarbg是一个大型综合BT交流网站，没想到互联网发展这么多年还是原始的最好用吧？\n你想用迅雷是可以的，但是如果迅雷因为XXX原因不能下载，请换其他软件，比如qbittorrent，utorrent(下面classic版本才是客户端,web版本是在线观看)，比特彗星等等。\n因为rarbg里基本都是老外，所以你连接的BT链也是跨国传播，速度比较随缘。其实一般来说开始会慢，等等会快。如果等了很久也很慢，那只能是无缘了。\n这时候可以试试把磁力链接放进度盘离线，相信我以后没有好心人再给你传度盘了。\n好了生肉你会下了，字幕怎么办。\n第一，各大字幕组微博，欢迎关注。\n第二，字幕网站，比如字幕库，subhd等等。\n如果你连外挂字幕都不会….百度一下很简单的。\n生肉加外挂字幕，感觉又回到十几年前了不是？\n切记，盗版始终有盗版的风险，追求正版是对视频的支持。我们只是需要未删减版对不？\n源自–ttmeiju微信公众号-酸梅电影\n","date":"2019-05-28","img":"","permalink":"https://helixs.github.io/posts/2019-05-28-%E8%88%92%E8%88%92%E6%9C%8D%E6%9C%8D%E7%9C%8B%E5%92%8Cbt%E6%9C%AA%E5%88%A0%E5%87%8F%E7%9A%84%E7%BE%8E%E5%89%A7/","series":null,"tags":null,"title":"舒舒服服看和bt未删减的美剧"},{"categories":["Android开发"],"content":"一、回顾一下以前的做法 以前我们在处理后台任务时，一般都是使用Service(含IntentService）或者线程/线程池，而Service不受页面生命周期影响，可以常驻后台，所以很适合做一些定时、延时任务，或者其他一些肉眼不可见的神秘勾当。 在处理一些复杂需求时，比如监听网络环境自动暂停重启后台上传下载这类变态任务，我们需要用Service结合Broadcast一起来做,非常的麻烦，再加上传输进度的回调，让人想疯！\n当然大量的后台任务过度消耗了设备的电量，比如多种第三方推送的service都在后台常驻，不良App后台自动上传用户隐私也带来了隐私安全问题。\n二、谷歌开始专项整顿  6.0 (API 级 23) 引入了Doze机制和应用程序待机 。当屏幕关闭且设备静止时, 打盹模式会限制应用程序的行为。应用程序待机将未使用的应用程序置于限制其网络访问、作业和同步的特殊状态。 Android 7.0 (API 级 24) 有限的隐性广播和Doze-on-the-go . Android 8.0 (API 级 26) 进一步限制了后台行为 , 例如在后台获取位置并释放缓存的 wakelocks。  尤其在Android O（8.0）中，谷歌对于后台的限制几乎可以称之为变态：\n Android 8.0 有一项复杂功能；系统不允许后台应用创建后台服务。 因此，Android 8.0 引入了一种全新的方法，即 Context.startForegroundService()，以在前台启动新服务。 在系统创建服务后，应用有五秒的时间来调用该服务的 startForeground() 方法以显示新服务的用户可见通知。 如果应用在此时间限制内未调用 startForeground()，则系统将停止服务并声明此应用为 ANR。\n 而且加入了对静态广播的限制：\n Android 8.0 让这些限制更为严格。 针对 Android 8.0 的应用无法继续在其清单中为隐式广播注册广播接收器。 隐式广播是一种不专门针对该应用的广播。 例如，ACTION_PACKAGE_REPLACED 就是一种隐式广播，因为它将发送到注册的所有侦听器，让后者知道设备上的某些软件包已被替换。 不过，ACTION_MY_PACKAGE_REPLACED 不是隐式广播，因为不管已为该广播注册侦听器的其他应用有多少，它都会只发送到软件包已被替换的应用。 应用可以继续在它们的清单中注册显式广播。 应用可以在运行时使用 Context.registerReceiver() 为任意广播（不管是隐式还是显式）注册接收器。 需要签名权限的广播不受此限制所限，因为这些广播只会发送到使用相同证书签名的应用，而不是发送到设备上的所有应用。 在许多情况下，之前注册隐式广播的应用使用 JobScheduler 作业可以获得类似的功能。\n 于此同时，官方推荐用5.0推出的JobScheduler替换Service + Broadcast的方案。\n并且在Android O，后台Service启动后的5秒内，如果不转为前台Service就会ANR!\n三、官方的推荐（qiang zhi）做法    场景 推荐     需系统触发，不必完成 ThreadPool + Broadcast   需系统触发，必须完成，可推迟 WorkManager   需系统触发，必须完成，立即 ForegroundService + Broadcast   不需系统触发，不必完成 ThreadPool   不需系统触发，必须完成，可推迟 WorkManager   不需系统触发，必须完成，立即 ForegroundService    四、WorkManager的推出  WorkManager 是一个 Android 库, 它在工作的触发器 (如适当的网络状态和电池条件) 满足时, 优雅地运行可推迟的后台工作。WorkManager 尽可能使用框架 JobScheduler , 以帮助优化电池寿命和批处理作业。在 Android 6.0 (API 级 23) 下面的设备上, 如果 WorkManager 已经包含了应用程序的依赖项, 则尝试使用Firebase JobDispatcher 。否则, WorkManager 返回到自定义 AlarmManager 实现, 以优雅地处理您的后台工作。\n 也就是说，WorkManager可以自动维护后台任务，同时可适应不同的条件，同时满足后台Service和静态广播，内部维护着JobScheduler，而在6.0以下系统版本则可自动切换为AlarmManager，好神奇！\n五、WorkManager详解 1.引入 2.重要的类解析 2.1 Worker  Worker是一个抽象类，用来指定需要执行的具体任务。我们需要继承Worker类，并实现它的doWork方法：\n向任务添加参数   在Request中传参： \u0026lt;span class=\u0026ldquo;hljs-attribute\u0026rdquo;\u0026gt;val\u0026lt;/span\u0026gt; data=Data.Builder() .putInt(\u0026lt;span class=\u0026ldquo;hljs-string\u0026rdquo;\u0026gt;\u0026ldquo;A\u0026rdquo;\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026ldquo;hljs-number\u0026rdquo;\u0026gt;1\u0026lt;/span\u0026gt;) .putString(\u0026lt;span class=\u0026ldquo;hljs-string\u0026rdquo;\u0026gt;\u0026ldquo;B\u0026rdquo;\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026ldquo;hljs-string\u0026rdquo;\u0026gt;\u0026ldquo;2\u0026rdquo;\u0026lt;/span\u0026gt;) .build() val request2 = PeriodicWorkRequestBuilder\u0026lt;MyWorker\u0026gt;(\u0026lt;span class=\u0026ldquo;hljs-number\u0026rdquo;\u0026gt;24\u0026lt;/span\u0026gt;,TimeUnit.SECONDS) .setInputData(data) .build()   在Worker中使用： \u0026lt;span class=\u0026ldquo;hljs-class\u0026rdquo;\u0026gt;\u0026lt;span class=\u0026ldquo;hljs-keyword\u0026rdquo;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026ldquo;hljs-title\u0026rdquo;\u0026gt;MyWorker\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026ldquo;hljs-title\u0026rdquo;\u0026gt;Worker\u0026lt;/span\u0026gt;() {\u0026lt;/span\u0026gt;\n  val tag = javaClass.simpleName override fun doWork(): Result { val A = inputData.getInt(\u0026amp;lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;A\u0026quot;\u0026amp;lt;/span\u0026gt;,\u0026amp;lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026amp;lt;/span\u0026gt;) val B = inputData.getString(\u0026amp;lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;B\u0026quot;\u0026amp;lt;/span\u0026gt;) \u0026amp;lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026amp;lt;/span\u0026gt; Worker.Result.SUCCESS }  } 当然除了上述代码中的方法之外，我们也可以重写父级的getExtras()，并在此方法中把参数写死再返回也是可以的。\n这里WorkManager就有一个不是很人性的地方了，那就是WorkManager不支持序列化传值！这一点让我怎么说啊，intent和Bundle都支持序列化传值，为什么偏偏这货就不行？那么如果传一个复杂对象还要先拆解吗?\n任务的返回值 很类似很类似的，任务的返回值也很简单：\ndoWork要求最后返回一个Result，这个Result是一个枚举，它有几个固定的值：\n FAILURE 任务失败。 RETRY 遇到暂时性失败，此时可使用WorkRequest.Builder.setBackoffCriteria(BackoffPolicy, long, TimeUnit)来重试。 SUCCESS 任务成功。  看到这里我就很奇怪，官方不推荐我们使用枚举，但是自己却一直在用，什么意思？\n2.2WorkRequest  也是一个抽象类，可以对Work进行包装，同时装裱上一系列的约束（Constraints），这些Constraints用来向系统指明什么条件下，或者什么时候开始执行任务。\nWorkManager向我们提供了WorkRequest的两个子类：\n OneTimeWorkRequest 单次任务。 PeriodicWorkRequest 周期任务。  从代码中可以看到，我们应该使用不同的构造器来创建对应的WorkRequest。\n接下来我们看看都有哪些约束：\n public boolean requiresBatteryNotLow ()：执行任务时电池电量不能偏低。 public boolean requiresCharging ()：在设备充电时才能执行任务。 public boolean requiresDeviceIdle ()：设备空闲时才能执行。 public boolean requiresStorageNotLow ()：设备储存空间足够时才能执行。  addContentUriTrigger 指定是否在(Uri指定的)内容更新时执行本次任务（只能用于Api24及以上版本）。瞄了一眼源码发现了一个ContentUriTriggers，这什么东东？\n特么惊呆了，居然是个HashSet，而HashSet的核心是个HashMap啊，谷歌声明不建议用HashMap，当然也就不建议用HashSet，可是官方自己在背地里面干的这些勾当啊…\nsetRequiredNetworkType 指定任务执行时的网络状态。其中状态见下表：\n|枚举|状态| |-|-| |NOT_REQUIRED|不需要网络| |CONNECTED|任何可用网络| |UNMETERED|需要不计量网络，如WiFi| |NOT_ROAMING|需要非漫游网络| |METERED|需要计量网络，如4G|\nsetRequiresBatteryNotLow 指定设备电池电量低于阀值时是否启动任务，默认false。\nsetRequiresCharging 指定设备在充电时是否启动任务。\nsetRequiresDeviceIdle 指明设备是否为空闲时是否启动任务。\nsetRequiresStorageNotLow 指明设备储存空间低于阀值时是否启动任务。\n给任务加约束： 给任务加标签分组 上述代码我给两个相同任务的request都加上了标签，使他们成为了一个组：A组。这样的好处是以后可以直接控制整个组就行了，组内的每个成员都会受到影响。\n2.3 WorkManager  经过上面的操作，相信我们已经能够成功创建request了，接下来我们就需要把任务放进任务队列，我们使用WorkManager。\nWorkManager是个单例，它负责调度任务并且监听任务状态。\n当我们的request入列后，WorkManager会给它分配一个work ID，之后我们可以使用这个work id来取消或者停止任务：\n注意：WorkManager并不一定能结束任务，因为任务有可能已经执行完毕了。\n同时，WorkManager还提供了其他结束任务的方法：\n cancelAllWork():取消所有任务。 cancelAllWorkByTag(tag:String):取消一组带有相同标签的任务。 cancelUniqueWork(uniqueWorkName:String):取消唯一任务。  2.4WorkStatus  当WorkManager把任务加入队列后，会为每个WorkRequest对象提供一个LiveData（如果这个东东不了解的话赶紧去学）。 LiveData持有WorkStatus;通过观察该 LiveData, 我们可以确定任务的当前状态, 并在任务完成后获取所有返回的值。\n我们来看这个WorkStatus到底都包涵什么，我们点进去看它的源码：\n我们需要关注的只有State和Data这两个属性，首先看State:\n这特么又一个枚举。看过代码之后，State枚举其实就是用来给我们做最后的结果判断的。但是要注意其中有个已挂起BLOCKED，这是啥子情况？通过看它的注释，我们得知，如果WorkRequest的约束没有通过，那么这个任务就会处于挂起状态。\n接下来，Data当然就是我们在任务中doWork的返回值了\n看到这里，我感觉谷歌大佬的设计思维还是非常之强的，把状态和返回值同时输出，非常方便我们做判断的同时来取值，并且这样的设计就可以达到‘多次返回’的效果，有时间一定要去看一下源码，先立个flag！\n3. 任务链 在很多场景中，我们需要把不同的任务弄成一个队列，比如在用户注册的时候，我们要先验证手机短信验证码，验证成功后再注册，注册成功后再调登陆接口实现自动登陆。类似这样相似的逻辑比比皆是，实话说笔者以前都是在service里面用rxjava来实现的。但是现在service在Android8.0版本以上系统不能用了怎么办？当然还是用我们今天学到的WorkManager来实现，接下来我们就一起看一下WorkManager的任务链。\n3.1链式启动-并发 这样等同于WorkManager把一个个的WorkRequest enqueue进队列，但是这样写明显更整齐！同时队列中的任务是并行的。\n3.2 then操作符-串发 上述代码的意思就是先1，1成功后再2，2成功后再3，这期间如果有任何一个任务失败（返回Worker.WorkerResult.FAILURE),则整个队列就会被中断。\n在任务链的串行中，也就是两个任务使用了then操作符连接，那么上一个任务的返回值就会自动转为下一个任务的参数！\n3.3 combine操作符-组合 现在我们有个复杂的需求：共有A、B、C、D、E这五个任务，要求AB串行，CD串行，但两个串之间要并发，并且最后要把两个串的结果汇总到E。\n我们看到这种复杂的业务逻辑，往往都会吓一跳，但是牛X的谷歌提供了combine操作符专门应对这种奇葩逻辑，不得不说：谷歌是我亲哥！\n4. 唯一链 什么是唯一链，就是同一时间内队列里不能存在相同名称的任务。\n从上面代码我们可以看到，首先与之前不同的是，这次我们用的是beginUniqueWork方法，这个方法的最后一个参数是一个可变长度的数组，那就证明这一定是一根链条。\n然后我们看这个方法的第一个参数，要求输入一个名称，这个名称就是用来标识任务的唯一性。那如果两个不同的任务我们给了相同的名称也是可以的，但是这两个任务在队列中只能存活一个。\n最后我们再来看第二个参数ExistingWorkPolicy,点进去果然又双叒是枚举：\n REPLACE：如果队列里面已经存在相同名称的任务，并且该任务处于挂起状态则替换之。 KEEP：如果队列里面已经存在相同名称的任务，并且该任务处于挂起状态，则什么也不做。 APPEND：如果队列里面已经存在相同名称的任务，并且该任务处于挂起状态，则会缓存新任务。当队列中所有任务执行完毕后，以这个新任务做为序列的第一个任务。  原文出处","date":"2019-05-27","img":"","permalink":"https://helixs.github.io/posts/2019-05-27-workmanager%E8%AF%A6%E8%A7%A3/","series":null,"tags":null,"title":"WorkManager详解"},{"categories":["python"],"content":"刚刚学习python又找不到练手的地方，所以闲来无事写了一个腾讯云活动查询的小爬虫，比较简单，也算是练手的\n当前时段正在进行的活动\n   ","date":"2019-05-24","img":"","permalink":"https://helixs.github.io/posts/2019-05-24-%E8%85%BE%E8%AE%AF%E4%BA%91%E7%A7%92%E6%9D%80%E6%B4%BB%E5%8A%A8%E4%BF%A1%E6%81%AF%E6%9F%A5%E8%AF%A2%E8%84%9A%E6%9C%AC/","series":null,"tags":null,"title":"腾讯云秒杀活动信息查询脚本"},{"categories":["编程语言"],"content":"表达式全集 \u0026lt;th width=\u0026quot;90%\u0026quot;\u0026gt; 描述 \u0026lt;/th\u0026gt;  \u0026lt;td\u0026gt; 将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，“\u0026lt;code\u0026gt;n\u0026lt;/code\u0026gt;”匹配字符“\u0026lt;code\u0026gt;n\u0026lt;/code\u0026gt;”。“\u0026lt;code\u0026gt;\\n\u0026lt;/code\u0026gt;”匹配一个换行符。串行“\u0026lt;code\u0026gt;\\\\\u0026lt;/code\u0026gt;”匹配“\u0026lt;code\u0026gt;\\\u0026lt;/code\u0026gt;”而“\u0026lt;code\u0026gt;\\(\u0026lt;/code\u0026gt;”则匹配“\u0026lt;code\u0026gt;(\u0026lt;/code\u0026gt;”。 \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配“\u0026lt;code\u0026gt;\\n\u0026lt;/code\u0026gt;”或“\u0026lt;code\u0026gt;\\r\u0026lt;/code\u0026gt;”之后的位置。 \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，$也匹配“\u0026lt;code\u0026gt;\\n\u0026lt;/code\u0026gt;”或“\u0026lt;code\u0026gt;\\r\u0026lt;/code\u0026gt;”之前的位置。 \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 匹配前面的子表达式零次或多次。例如，zo*能匹配“\u0026lt;code\u0026gt;z\u0026lt;/code\u0026gt;”以及“\u0026lt;code\u0026gt;zoo\u0026lt;/code\u0026gt;”。*等价于{0,}。 \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 匹配前面的子表达式一次或多次。例如，“\u0026lt;code\u0026gt;zo+\u0026lt;/code\u0026gt;”能匹配“\u0026lt;code\u0026gt;zo\u0026lt;/code\u0026gt;”以及“\u0026lt;code\u0026gt;zoo\u0026lt;/code\u0026gt;”，但不能匹配“\u0026lt;code\u0026gt;z\u0026lt;/code\u0026gt;”。+等价于{1,}。 \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 匹配前面的子表达式零次或一次。例如，“\u0026lt;code\u0026gt;do(es)?\u0026lt;/code\u0026gt;”可以匹配“\u0026lt;code\u0026gt;does\u0026lt;/code\u0026gt;”或“\u0026lt;code\u0026gt;does\u0026lt;/code\u0026gt;”中的“\u0026lt;code\u0026gt;do\u0026lt;/code\u0026gt;”。?等价于{0,1}。 \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; n是一个非负整数。匹配确定的n次。例如，“\u0026lt;code\u0026gt;o{2}\u0026lt;/code\u0026gt;”不能匹配“\u0026lt;code\u0026gt;Bob\u0026lt;/code\u0026gt;”中的“\u0026lt;code\u0026gt;o\u0026lt;/code\u0026gt;”，但是能匹配“\u0026lt;code\u0026gt;food\u0026lt;/code\u0026gt;”中的两个o。 \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; n是一个非负整数。至少匹配n次。例如，“\u0026lt;code\u0026gt;o{2,}\u0026lt;/code\u0026gt;”不能匹配“\u0026lt;code\u0026gt;Bob\u0026lt;/code\u0026gt;”中的“\u0026lt;code\u0026gt;o\u0026lt;/code\u0026gt;”，但能匹配“\u0026lt;code\u0026gt;foooood\u0026lt;/code\u0026gt;”中的所有o。“\u0026lt;code\u0026gt;o{1,}\u0026lt;/code\u0026gt;”等价于“\u0026lt;code\u0026gt;o+\u0026lt;/code\u0026gt;”。“\u0026lt;code\u0026gt;o{0,}\u0026lt;/code\u0026gt;”则等价于“\u0026lt;code\u0026gt;o*\u0026lt;/code\u0026gt;”。 \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; m和n均为非负整数，其中n\u0026lt;=m。最少匹配n次且最多匹配m次。例如，“\u0026lt;code\u0026gt;o{1,3}\u0026lt;/code\u0026gt;”将匹配“\u0026lt;code\u0026gt;fooooood\u0026lt;/code\u0026gt;”中的前三个o。“\u0026lt;code\u0026gt;o{0,1}\u0026lt;/code\u0026gt;”等价于“\u0026lt;code\u0026gt;o?\u0026lt;/code\u0026gt;”。请注意在逗号和两个数之间不能有空格。 \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 当该字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“\u0026lt;code\u0026gt;oooo\u0026lt;/code\u0026gt;”，“\u0026lt;code\u0026gt;o+?\u0026lt;/code\u0026gt;”将匹配单个“\u0026lt;code\u0026gt;o\u0026lt;/code\u0026gt;”，而“\u0026lt;code\u0026gt;o+\u0026lt;/code\u0026gt;”将匹配所有“\u0026lt;code\u0026gt;o\u0026lt;/code\u0026gt;”。 \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 匹配除“\u0026lt;code\u0026gt;\\\u0026lt;/code\u0026gt;\u0026lt;code\u0026gt;n\u0026lt;/code\u0026gt;”之外的任何单个字符。要匹配包括“\u0026lt;code\u0026gt;\\\u0026lt;/code\u0026gt;\u0026lt;code\u0026gt;n\u0026lt;/code\u0026gt;”在内的任何字符，请使用像“\u0026lt;code\u0026gt;(.|\\n)\u0026lt;/code\u0026gt;”的模式。 \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 匹配pattern并获取这一匹配。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0…$9属性。要匹配圆括号字符，请使用“\u0026lt;code\u0026gt;\\(\u0026lt;/code\u0026gt;”或“\u0026lt;code\u0026gt;\\)\u0026lt;/code\u0026gt;”。 \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 匹配pattern但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用或字符“\u0026lt;code\u0026gt;(|)\u0026lt;/code\u0026gt;”来组合一个模式的各个部分是很有用。例如“\u0026lt;code\u0026gt;industr(?:y|ies)\u0026lt;/code\u0026gt;”就是一个比“\u0026lt;code\u0026gt;industry|industries\u0026lt;/code\u0026gt;”更简略的表达式。 \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，“\u0026lt;code\u0026gt;Windows(?=95|98|NT|2000)\u0026lt;/code\u0026gt;”能匹配“\u0026lt;code\u0026gt;Windows2000\u0026lt;/code\u0026gt;”中的“\u0026lt;code\u0026gt;Windows\u0026lt;/code\u0026gt;”，但不能匹配“\u0026lt;code\u0026gt;Windows3.1\u0026lt;/code\u0026gt;”中的“\u0026lt;code\u0026gt;Windows\u0026lt;/code\u0026gt;”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如“\u0026lt;code\u0026gt;Windows(?!95|98|NT|2000)\u0026lt;/code\u0026gt;”能匹配“\u0026lt;code\u0026gt;Windows3.1\u0026lt;/code\u0026gt;”中的“\u0026lt;code\u0026gt;Windows\u0026lt;/code\u0026gt;”，但不能匹配“\u0026lt;code\u0026gt;Windows2000\u0026lt;/code\u0026gt;”中的“\u0026lt;code\u0026gt;Windows\u0026lt;/code\u0026gt;”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始 \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 反向肯定预查，与正向肯定预查类拟，只是方向相反。例如，“\u0026lt;code\u0026gt;(?\u0026amp;lt;=95|98|NT|2000)Windows\u0026lt;/code\u0026gt;”能匹配“\u0026lt;code\u0026gt;2000Windows\u0026lt;/code\u0026gt;”中的“\u0026lt;code\u0026gt;Windows\u0026lt;/code\u0026gt;”，但不能匹配“\u0026lt;code\u0026gt;3.1Windows\u0026lt;/code\u0026gt;”中的“\u0026lt;code\u0026gt;Windows\u0026lt;/code\u0026gt;”。 \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 反向否定预查，与正向否定预查类拟，只是方向相反。例如“\u0026lt;code\u0026gt;(?\u0026amp;lt;!95|98|NT|2000)Windows\u0026lt;/code\u0026gt;”能匹配“\u0026lt;code\u0026gt;3.1Windows\u0026lt;/code\u0026gt;”中的“\u0026lt;code\u0026gt;Windows\u0026lt;/code\u0026gt;”，但不能匹配“\u0026lt;code\u0026gt;2000Windows\u0026lt;/code\u0026gt;”中的“\u0026lt;code\u0026gt;Windows\u0026lt;/code\u0026gt;”。 \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 匹配x或y。例如，“\u0026lt;code\u0026gt;z|food\u0026lt;/code\u0026gt;”能匹配“\u0026lt;code\u0026gt;z\u0026lt;/code\u0026gt;”或“\u0026lt;code\u0026gt;food\u0026lt;/code\u0026gt;”。“\u0026lt;code\u0026gt;(z|f)ood\u0026lt;/code\u0026gt;”则匹配“\u0026lt;code\u0026gt;zood\u0026lt;/code\u0026gt;”或“\u0026lt;code\u0026gt;food\u0026lt;/code\u0026gt;”。 \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 字符集合。匹配所包含的任意一个字符。例如，“\u0026lt;code\u0026gt;[abc]\u0026lt;/code\u0026gt;”可以匹配“\u0026lt;code\u0026gt;plain\u0026lt;/code\u0026gt;”中的“\u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt;”。 \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 负值字符集合。匹配未包含的任意字符。例如，“\u0026lt;code\u0026gt;[^abc]\u0026lt;/code\u0026gt;”可以匹配“\u0026lt;code\u0026gt;plain\u0026lt;/code\u0026gt;”中的“\u0026lt;code\u0026gt;p\u0026lt;/code\u0026gt;”。 \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 字符范围。匹配指定范围内的任意字符。例如，“\u0026lt;code\u0026gt;[a-z]\u0026lt;/code\u0026gt;”可以匹配“\u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt;”到“\u0026lt;code\u0026gt;z\u0026lt;/code\u0026gt;”范围内的任意小写字母字符。 \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 负值字符范围。匹配任何不在指定范围内的任意字符。例如，“\u0026lt;code\u0026gt;[^a-z]\u0026lt;/code\u0026gt;”可以匹配任何不在“\u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt;”到“\u0026lt;code\u0026gt;z\u0026lt;/code\u0026gt;”范围内的任意字符。 \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 匹配一个单词边界，也就是指单词和空格间的位置。例如，“\u0026lt;code\u0026gt;er\\b\u0026lt;/code\u0026gt;”可以匹配“\u0026lt;code\u0026gt;never\u0026lt;/code\u0026gt;”中的“\u0026lt;code\u0026gt;er\u0026lt;/code\u0026gt;”，但不能匹配“\u0026lt;code\u0026gt;verb\u0026lt;/code\u0026gt;”中的“\u0026lt;code\u0026gt;er\u0026lt;/code\u0026gt;”。 \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 匹配非单词边界。“\u0026lt;code\u0026gt;er\\B\u0026lt;/code\u0026gt;”能匹配“\u0026lt;code\u0026gt;verb\u0026lt;/code\u0026gt;”中的“\u0026lt;code\u0026gt;er\u0026lt;/code\u0026gt;”，但不能匹配“\u0026lt;code\u0026gt;never\u0026lt;/code\u0026gt;”中的“\u0026lt;code\u0026gt;er\u0026lt;/code\u0026gt;”。 \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 匹配由x指明的控制字符。例如，\\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“\u0026lt;code\u0026gt;c\u0026lt;/code\u0026gt;”字符。 \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 匹配一个数字字符。等价于[0-9]。 \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 匹配一个非数字字符。等价于[^0-9]。 \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 匹配一个换页符。等价于\\x0c和\\cL。 \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 匹配一个换行符。等价于\\x0a和\\cJ。 \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 匹配一个回车符。等价于\\x0d和\\cM。 \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 匹配任何空白字符，包括空格、制表符、换页符等等。等价于[ \\f\\n\\r\\t\\v]。 \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 匹配任何非空白字符。等价于[^ \\f\\n\\r\\t\\v]。 \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 匹配一个制表符。等价于\\x09和\\cI。 \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 匹配一个垂直制表符。等价于\\x0b和\\cK。 \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 匹配包括下划线的任何单词字符。等价于“\u0026lt;code\u0026gt;[A-Za-z0-9_]\u0026lt;/code\u0026gt;”。 \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 匹配任何非单词字符。等价于“\u0026lt;code\u0026gt;[^A-Za-z0-9_]\u0026lt;/code\u0026gt;”。 \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 匹配n，其中n为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，“\u0026lt;code\u0026gt;\\x41\u0026lt;/code\u0026gt;”匹配“\u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt;”。“\u0026lt;code\u0026gt;\\x041\u0026lt;/code\u0026gt;”则等价于“\u0026lt;code\u0026gt;\\x04\u0026amp;1\u0026lt;/code\u0026gt;”。正则表达式中可以使用ASCII编码。. \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 匹配num，其中num是一个正整数。对所获取的匹配的引用。例如，“\u0026lt;code\u0026gt;(.)\\1\u0026lt;/code\u0026gt;”匹配两个连续的相同字符。 \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 标识一个八进制转义值或一个向后引用。如果\\n之前至少n个获取的子表达式，则n为向后引用。否则，如果n为八进制数字（0-7），则n为一个八进制转义值。 \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 标识一个八进制转义值或一个向后引用。如果\\nm之前至少有nm个获得子表达式，则nm为向后引用。如果\\nm之前至少有n个获取，则n为一个后跟文字m的向后引用。如果前面的条件都不满足，若n和m均为八进制数字（0-7），则\\nm将匹配八进制转义值nm。 \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 如果n为八进制数字（0-3），且m和l均为八进制数字（0-7），则匹配八进制转义值nml。 \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; 匹配n，其中n是一个用四个十六进制数字表示的Unicode字符。例如，\\u00A9匹配版权符号（©）。 \u0026lt;/td\u0026gt;   常用正则表达式 \u0026lt;td width=\u0026quot;90%\u0026quot;\u0026gt; /^[a-z0-9_-]{3,16}$/ \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; /^[a-z0-9_-]{6,18}$/ \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; /^#?([a-f0-9]{6}|[a-f0-9]{3})$/ \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; /^([a-z0-9_\\.-]+)@([\\da-z\\.-]+)\\.([a-z\\.]{2,6})$/\u0026lt;br /\u0026gt; /^[a-z\\d]+(\\.[a-z\\d]+)*@([\\da-z](-[\\da-z])?)+(\\.{1,2}[a-z]+)+$/ \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; /^(https?:\\/\\/)?([\\da-z\\.-]+)\\.([a-z\\.]{2,6})([\\/\\w \\.-]*)*\\/?$/ \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; /((2[0-4]\\d|25[0-5]|[01]?\\d\\d?)\\.){3}(2[0-4]\\d|25[0-5]|[01]?\\d\\d?)/\u0026lt;br /\u0026gt; /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/ \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; /^\u0026lt;([a-z]+)([^\u0026lt;]+)*(?:\u0026gt;(.*)\u0026lt;\\/\\1\u0026gt;|\\s+\\/\u0026gt;)$/ \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; (?\u0026lt;!http:|\\S)//.*$ \u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt; /^[\\u2E80-\\u9FFF]+$/ \u0026lt;/td\u0026gt;                                              ","date":"2019-05-23","img":"","permalink":"https://helixs.github.io/posts/2019-05-23-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AC%A6%E5%8F%B7%E8%A1%A8/","series":null,"tags":null,"title":"正则表达式符号表"},{"categories":["Android开发"],"content":"今天有个需求，web页面有个视频是用标签进行播放的，点击放大按钮进行全屏播放。默认情况下，的确可以实现播放功能，但是放大按钮是无法点击的状态。所以我们要进行一下适配了。\n注意事项\n 启动硬件加速 重写WebChromeClient-onShowCustomView方法 横竖屏切换的适配情况 Activity destory情况  1、硬件加速\n\u0026lt;activity \u0026hellip; android:hardwareAccelerated=\u0026ldquo;true\u0026rdquo; /\u0026gt;2、我们重写onShowCustomView\n此方法是通知我们当前的页面将进入全屏模式，也就是我们点击那个小全屏图标的时候，参数当中是一个view，需要将这个view添加到activity中的布局中，我们就直接添加到Webview上，毕竟Webview是个FrameLayout。\n实现了上面的方法后，video标签上的全屏按钮就有效果了，点击的时候，会撑满当前的WebView的大小（当然，如果实现全屏的话，那你的webview也要撑满全屏才是哦）。这个简易的全屏方式就实现了。\n我们也可以将这个全屏模式的view添加到别的layout上面，这个可以在webview不是全屏的页面上使用，具体就不介绍了，大家应该都会\n如果有特殊的退出全屏时的操作可以实现这个方法。\n3、横竖屏的适配操作\n如果页面全屏的时候需要有横屏的要求，需要加入兼容性的配置，最后不要让应用进行自动横竖屏，view的哪些东西保存状态是个麻烦，我们手动请求横竖屏，那么就可以躲避横竖屏自动切换所带来的生命周期干扰了。\n当屏幕方向变化的时候会回调Activity的onConfigurationChanged方法，而不会进行生命周期的变化。\n基本上我们的全屏功能就完成啦，切换时候的addview和removeView等等需要根据自己的情况实现\n4、退出的WebActivity的时候记得调用webview.destory()，异步进程可能导致视频还有声音在播放。\n谢谢大家\n参考–\nandroid webview中视频播放及全屏Android 横竖屏切换WebView 支持 Html5 video 进行全屏播放","date":"2019-05-22","img":"","permalink":"https://helixs.github.io/posts/2019-05-22-android-webview%E8%A7%86%E9%A2%91%E5%85%A8%E5%B1%8F%E6%92%AD%E6%94%BE%E6%A0%87%E7%AD%BE/","series":null,"tags":null,"title":"Android WebView视频全屏播放"},{"categories":["vps工具"],"content":"基于总所周知的原因，获取开发者资料也很是麻烦，顺便做个记录，怕以后忘记。下面所有的xxxxx 替换为 shdowockslibev的版本呢比较的轻量级，用docker的方式安装最是省心。也怪自己不太会docker的使用，就直接用原生吧，以下都是基于centos7的\n打开它的github，找到centos 添加libev的源。顺便复制一下这个，创建文件librehat-xxxxx-epel-7.repo\n放入/etc/yum.repos.d/\n或者直接\n 如果出现\nError: Package: xxxxxxx-libev-3.2.0-2.el7.x86_64 (librehat-xxxxx)\nRequires: libsodium \u0026gt;= 1.0.4\nError: Package: xxxxxx-libev-3.2.0-2.el7.x86_64 (librehat-xxxxx)\nRequires: mbedtls\n好像是udns源没有启用上，部分的vps可能会出现这个情况\n解决办法github或者\n成功后再执行安装操作。\n试试呢\n加上bbr那么效果更好了\n","date":"2019-05-17","img":"","permalink":"https://helixs.github.io/posts/2019-05-17-centos7%E5%AE%89%E8%A3%85shadows-libev/","series":null,"tags":null,"title":"Centos7安装sha*dow***s-Libev"},{"categories":["未分类"],"content":"\u0026lt;p\u0026gt; Android 4.4 为什么能够实现沉浸式的效果呢？因为在Android 4.4 新增了一个重要的属性：\u0026lt;code\u0026gt;FLAG_TRANSLUCENT_STATUS\u0026lt;/code\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;pre\u0026gt;\u0026lt;code class=\u0026quot;hljs java copyable\u0026quot;\u0026gt; \u0026amp;lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/** * Window flag: request a translucent status bar with minimal system-provided * background protection. * * \u0026amp;lt;p\u0026amp;gt;This flag can be controlled in your theme through the * {\u0026amp;lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;@link\u0026amp;lt;/span\u0026gt; android.R.attr#windowTranslucentStatus} attribute; this attribute * is automatically set for you in the standard translucent decor themes * such as * {\u0026amp;lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;@link\u0026amp;lt;/span\u0026gt; android.R.style#Theme_Holo_NoActionBar_TranslucentDecor}, * {\u0026amp;lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;@link\u0026amp;lt;/span\u0026gt; android.R.style#Theme_Holo_Light_NoActionBar_TranslucentDecor}, * {\u0026amp;lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;@link\u0026amp;lt;/span\u0026gt; android.R.style#Theme_DeviceDefault_NoActionBar_TranslucentDecor}, and * {\u0026amp;lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;@link\u0026amp;lt;/span\u0026gt; android.R.style#Theme_DeviceDefault_Light_NoActionBar_TranslucentDecor}.\u0026amp;lt;/p\u0026amp;gt; * * \u0026amp;lt;p\u0026amp;gt;When this flag is enabled for a window, it automatically sets * the system UI visibility flags {\u0026amp;lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;@link\u0026amp;lt;/span\u0026gt; View#SYSTEM_UI_FLAG_LAYOUT_STABLE} and * {\u0026amp;lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;@link\u0026amp;lt;/span\u0026gt; View#SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN}.\u0026amp;lt;/p\u0026amp;gt; */\u0026amp;lt;/span\u0026gt; \u0026amp;lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026amp;lt;/span\u0026gt; \u0026amp;lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026amp;lt;/span\u0026gt; \u0026amp;lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;final\u0026amp;lt;/span\u0026gt; \u0026amp;lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;int\u0026amp;lt;/span\u0026gt; FLAG_TRANSLUCENT_STATUS = \u0026amp;lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x04000000\u0026amp;lt;/span\u0026gt;;\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt; \u0026lt;blockquote\u0026gt; \u0026lt;p\u0026gt; 解释：设置状态栏透明，并且变为全屏模式。上面的解释已经说得很清楚了，当window的这个属性有效的时候，会自动设置 system ui visibility的标志\u0026lt;code\u0026gt;SYSTEM_UI_FLAG_LAYOUT_STABLE\u0026lt;/code\u0026gt;和\u0026lt;code\u0026gt;SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN\u0026lt;/code\u0026gt; 。 \u0026lt;/p\u0026gt; \u0026lt;/blockquote\u0026gt; \u0026lt;p\u0026gt; 有两种方式实现这个属性： \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; 可以在代码中设置，如下： \u0026lt;/p\u0026gt; \u0026lt;pre\u0026gt;\u0026lt;code class=\u0026quot;hljs java copyable\u0026quot;\u0026gt;activity.getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt; \u0026lt;p\u0026gt; 当然也可以在theme 中设置属性\u0026lt;code\u0026gt;windowTranslucentStatus\u0026lt;/code\u0026gt;,如下： \u0026lt;/p\u0026gt; \u0026lt;pre\u0026gt;\u0026lt;code class=\u0026quot;hljs java copyable\u0026quot;\u0026gt;android:windowTranslucentStatus\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;  \u0026lt;div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p\u0026gt; 实现沉浸式添加如下代码： \u0026lt;/p\u0026gt; \u0026lt;pre\u0026gt;\u0026lt;code class=\u0026quot;hljs java copyable\u0026quot;\u0026gt;getWindow().addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);  \u0026lt;span class=\u0026ldquo;hljs-comment\u0026rdquo;\u0026gt;//注意要清除 FLAG_TRANSLUCENT_STATUS flag\u0026lt;/span\u0026gt; getWindow().clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS); getWindow().setStatusBarColor(getResources().getColor(android.R.color.holo_red_light)); \u0026lt;div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p\u0026gt; \u0026lt;strong\u0026gt;图片延伸到状态栏\u0026lt;/strong\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; 在Android 5.0 使图片延伸到状态栏，只需设置\u0026lt;code\u0026gt;windowTranslucentStatus\u0026lt;/code\u0026gt;,将 statusBarColor 设置为透明即可： \u0026lt;/p\u0026gt; \u0026lt;pre\u0026gt;\u0026lt;code class=\u0026quot;hljs java copyable\u0026quot;\u0026gt;\u0026amp;lt;style name=\u0026quot;ImageTranslucentTheme\u0026quot; parent=\u0026quot;Theme.AppCompat.DayNight.NoActionBar\u0026quot;\u0026amp;gt; \u0026amp;lt;item name=\u0026quot;android:windowTranslucentNavigation\u0026quot;\u0026amp;gt;true\u0026amp;lt;/item\u0026amp;gt; \u0026amp;lt;item name=\u0026quot;android:windowTranslucentStatus\u0026quot;\u0026amp;gt;true\u0026amp;lt;/item\u0026amp;gt; \u0026amp;lt;!-- 设置statusBarColor 为透明--\u0026amp;gt; \u0026amp;lt;item name=\u0026quot;android:statusBarColor\u0026quot;\u0026amp;gt;@android:color/transparent\u0026amp;lt;/item\u0026amp;gt; \u0026amp;lt;/style\u0026amp;gt;\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;pre class=\u0026quot;pure-highlightjs\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;java\u0026quot;\u0026gt; activity.getWindow().addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS); activity.getWindow().clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS); activity.getWindow().setStatusBarColor(calculateStatusColor(color, statusBarAlpha));   \u0026lt;div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p\u0026gt; \u0026lt;strong\u0026gt;2.3 Android 6.0 + 实现状态栏字色和图标浅黑色\u0026lt;/strong\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; 使用沉浸式的时候会遇到一个问题，那就是\u0026lt;strong\u0026gt;Android 系统状态栏的字色和图标颜色为白色，当我的主题色或者图片接近白色或者为浅色的时候，状态栏上的内容就看不清了。\u0026lt;/strong\u0026gt; ，这个问题在Android 6.0的时候得到了解决。Android 6.0 新添加了一个属性\u0026lt;code\u0026gt;SYSTEM_UI_FLAG_LIGHT_STATUS_BAR\u0026lt;/code\u0026gt; \u0026lt;/p\u0026gt;\u0026lt;figure\u0026gt;\u0026lt;figcaption\u0026gt;\u0026lt;/figcaption\u0026gt;\u0026lt;/figure\u0026gt; \u0026lt;blockquote\u0026gt; \u0026lt;p\u0026gt; 解释：为setSystemUiVisibility(int)方法添加的Flag,请求status bar 绘制模式，它可以兼容亮色背景的status bar 。要在设置了\u0026lt;code\u0026gt;FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS\u0026lt;/code\u0026gt;flag ,同时清除了\u0026lt;code\u0026gt;FLAG_TRANSLUCENT_STATUS\u0026lt;/code\u0026gt;flag 才会生效。 \u0026lt;/p\u0026gt; \u0026lt;/blockquote\u0026gt; \u0026lt;p\u0026gt; 添加如下代码： \u0026lt;/p\u0026gt; \u0026lt;pre\u0026gt;\u0026lt;code class=\u0026quot;hljs java copyable\u0026quot;\u0026gt;\u0026amp;lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026amp;lt;/span\u0026gt; (Build.VERSION.SDK_INT \u0026amp;gt;= Build.VERSION_CODES.M) {  //不然会出现灰色状态栏 \u0026lt;span class=\u0026ldquo;hljs-preprocessor\u0026rdquo;\u0026gt;getWindow().clearFlags\u0026lt;/span\u0026gt;(WindowManager\u0026lt;span class=\u0026ldquo;hljs-preprocessor\u0026rdquo;\u0026gt;.LayoutParams\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026ldquo;hljs-preprocessor\u0026rdquo;\u0026gt;.FLAG\u0026lt;/span\u0026gt;_TRANSLUCENT_STATUS)\u0026lt;span class=\u0026ldquo;hljs-comment\u0026rdquo;\u0026gt;;\u0026lt;/span\u0026gt; getWindow().getDecorView().setSystemUiVisibility( View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN|View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR); }","date":"2019-03-27","img":"","permalink":"https://helixs.github.io/posts/2019-03-27-android%E6%B2%89%E6%B5%B8%E7%8A%B6%E6%80%81%E6%A0%8F/","series":null,"tags":null,"title":"Android沉浸状态栏"},{"categories":["Android开发"],"content":"  \u0026lt;div class=\u0026quot;blockcode\u0026quot;\u0026gt; \u0026lt;div id=\u0026quot;code_zsS\u0026quot;\u0026gt; \u0026lt;ol\u0026gt; \u0026lt;li\u0026gt; D: \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; cd adb \u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;p\u0026gt; 以此切换到D:/adb工作目录，此时可通过输入 \u0026lt;/p\u0026gt; \u0026lt;div class=\u0026quot;blockcode\u0026quot;\u0026gt; \u0026lt;div id=\u0026quot;code_FvG\u0026quot;\u0026gt; \u0026lt;ol\u0026gt; \u0026lt;li\u0026gt; adb version \u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;p\u0026gt; 根据提示信息确定是否可正常使用，如图即为正常的情况。 \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; \u0026lt;span style=\u0026quot;font-size: medium;\u0026quot;\u0026gt;\u0026lt;span style=\u0026quot;color: #0000ff;\u0026quot;\u0026gt;\u0026lt;strong\u0026gt;三、我可以用ADB和Fastboot干什么，怎么做？\u0026lt;/strong\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; 在做任何事情之前，我们都需要连接手机到电脑端，并开启USB调试模式，通过命令查看是否连接正常。\u0026lt;br /\u0026gt; 如果处在开机状态或recovery下，命令为： \u0026lt;/p\u0026gt; \u0026lt;div class=\u0026quot;blockcode\u0026quot;\u0026gt; \u0026lt;div id=\u0026quot;code_dsO\u0026quot;\u0026gt; \u0026lt;ol\u0026gt; \u0026lt;li\u0026gt; adb devices \u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;p\u0026gt; Fastboot下，命令为 \u0026lt;/p\u0026gt; \u0026lt;div class=\u0026quot;blockcode\u0026quot;\u0026gt; \u0026lt;div id=\u0026quot;code_V9r\u0026quot;\u0026gt; \u0026lt;ol\u0026gt; \u0026lt;li\u0026gt; fastboot devices \u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;p\u0026gt; 根据返回信息确认是否连接正常，若返回信息左侧显示为一序列号，右侧显示device或recovery或sideload或fastboot均为正常情况，分别代表此时设备所处的状态，如： \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; \u0026lt;strong\u0026gt;\u0026lt;span style=\u0026quot;font-size: medium;\u0026quot;\u0026gt;\u0026lt;span style=\u0026quot;color: #f4a460;\u0026quot;\u0026gt;\u0026lt;1\u0026gt;ADB工具\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/strong\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; 最常用的，我们可以通过ADB，我们可以进行通过USB端进行ROM刷机包刷机操作。\u0026lt;br /\u0026gt; 将手机进入Recovery模式，可看到，由于一加三由于出厂Android版本为6.0，为遵循Google新的安全规范，已经对data分区进行了加密，在官方Recovery下已经看不到曾经熟悉的从内置存储中升级的选项，这时候就可以选择从USB端进行升级选项，借助强大的ADB完成系统升级。具体命令为： \u0026lt;/p\u0026gt; \u0026lt;div class=\u0026quot;blockcode\u0026quot;\u0026gt; \u0026lt;div id=\u0026quot;code_RO4\u0026quot;\u0026gt; \u0026lt;ol\u0026gt; \u0026lt;li\u0026gt; adb sideload \u0026lt;file_location\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;p\u0026gt; \u0026lt;em\u0026gt;复制代码\u0026lt;/em\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;p\u0026gt; 其中，\u0026lt;file_location\u0026gt;应为刷机包所在位置，如果较为复杂，可以讨巧地选择拖拽方式，利用鼠标拖拽将外部ZIP包拖拽入窗口中 \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; 回车即可等待ADB自动完成刷机包推送和更新操作。 \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; 此外，我们还可以用ADB工具进行安装APK，推送文件到系统等等。在此只提供相关命令，不再提供截图演示\u0026lt;br /\u0026gt; （1）安装APK \u0026lt;/p\u0026gt; \u0026lt;div class=\u0026quot;blockcode\u0026quot;\u0026gt; \u0026lt;div id=\u0026quot;code_nJp\u0026quot;\u0026gt; \u0026lt;ol\u0026gt; \u0026lt;li\u0026gt; adb install \u0026lt;apk文件路径\u0026gt;（可拖拽） \u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;p\u0026gt; （2）卸载软件 \u0026lt;/p\u0026gt; \u0026lt;div class=\u0026quot;blockcode\u0026quot;\u0026gt; \u0026lt;div id=\u0026quot;code_t9c\u0026quot;\u0026gt; \u0026lt;ol\u0026gt; \u0026lt;li\u0026gt; adb uninstall \u0026lt;软件名\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;p\u0026gt; （3）从电脑上发送文件到设备 \u0026lt;/p\u0026gt; \u0026lt;div class=\u0026quot;blockcode\u0026quot;\u0026gt; \u0026lt;div id=\u0026quot;code_n0l\u0026quot;\u0026gt; \u0026lt;ol\u0026gt; \u0026lt;li\u0026gt; adb push \u0026lt;本地路径\u0026gt; \u0026lt;远程路径\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;p\u0026gt; （4）从设备上下载文件到电脑 \u0026lt;/p\u0026gt; \u0026lt;div class=\u0026quot;blockcode\u0026quot;\u0026gt; \u0026lt;div id=\u0026quot;code_XFt\u0026quot;\u0026gt; \u0026lt;ol\u0026gt; \u0026lt;li\u0026gt; adb pull \u0026lt;远程路径\u0026gt; \u0026lt;本地路径\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;p\u0026gt; （5）重启到recovery \u0026lt;/p\u0026gt; \u0026lt;div class=\u0026quot;blockcode\u0026quot;\u0026gt; \u0026lt;div id=\u0026quot;code_iPZ\u0026quot;\u0026gt; \u0026lt;ol\u0026gt; \u0026lt;li\u0026gt; adb reboot recovery \u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;p\u0026gt; （6）重启到fastboot \u0026lt;/p\u0026gt; \u0026lt;div class=\u0026quot;blockcode\u0026quot;\u0026gt; \u0026lt;div id=\u0026quot;code_C27\u0026quot;\u0026gt; \u0026lt;ol\u0026gt; \u0026lt;li\u0026gt; adb reboot bootloader \u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;p\u0026gt; （7）重启手机至系统 \u0026lt;/p\u0026gt; \u0026lt;div class=\u0026quot;blockcode\u0026quot;\u0026gt; \u0026lt;div id=\u0026quot;code_J2E\u0026quot;\u0026gt; \u0026lt;ol\u0026gt; \u0026lt;li\u0026gt; adb reboot \u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;p\u0026gt; \u0026lt;strong\u0026gt;\u0026lt;span style=\u0026quot;font-size: medium;\u0026quot;\u0026gt;\u0026lt;span style=\u0026quot;color: #f4a460;\u0026quot;\u0026gt;\u0026lt;2\u0026gt;Fastboot工具\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/strong\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; Fastboot工具与ADB工具使用方法相同，只是相关实现命令与作用不同，总的来说，fastboot具有 为设备解锁，刷写img刷机包，格式化系统分区，启动（运行）img文件（通常用于不刷写测试recovery）等功能，相关命令如下： \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; （1）进行设备的解锁 \u0026lt;/p\u0026gt;  \u0026lt;div class=\u0026quot;blockcode\u0026quot;\u0026gt; \u0026lt;div id=\u0026quot;code_bxH\u0026quot;\u0026gt; \u0026lt;ol\u0026gt; \u0026lt;li\u0026gt; fastboot oem unlock ////////请先备份再执行 \u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;p\u0026gt; （2）进行设备的重上锁 \u0026lt;/p\u0026gt; \u0026lt;div class=\u0026quot;blockcode\u0026quot;\u0026gt; \u0026lt;div id=\u0026quot;code_oyI\u0026quot;\u0026gt; \u0026lt;ol\u0026gt; \u0026lt;li\u0026gt; fastboot oem lock \u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;p\u0026gt; （3）刷写IMG刷机包 \u0026lt;/p\u0026gt; \u0026lt;div class=\u0026quot;blockcode\u0026quot;\u0026gt; \u0026lt;div id=\u0026quot;code_V3S\u0026quot;\u0026gt; \u0026lt;ol\u0026gt; \u0026lt;li\u0026gt; fastboot flash \u0026lt;分区名\u0026gt; \u0026lt;IMG路径\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;p\u0026gt; 例如，刷写recovery时，输入的命令为 \u0026lt;/p\u0026gt; \u0026lt;div class=\u0026quot;blockcode\u0026quot;\u0026gt; \u0026lt;div id=\u0026quot;code_afP\u0026quot;\u0026gt; \u0026lt;ol\u0026gt; \u0026lt;li\u0026gt; fastboot flash recovery \u0026lt;recovery的img文件路径\u0026gt;（可拖拽入窗口） \u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;p\u0026gt; 注：主要的分区有\u0026lt;span style=\u0026quot;color: #0000ff;\u0026quot;\u0026gt; \u0026lt;strong\u0026gt;recovery（恢复模式）\u0026lt;/strong\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;strong\u0026gt; \u0026lt;span style=\u0026quot;color: #008000;\u0026quot;\u0026gt;system（系统分区）\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color: #8b0000;\u0026quot;\u0026gt;boot（引导分区，存放内核和ramdisk）\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color: #ffa500;\u0026quot;\u0026gt;data（数据分区）\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color: #ff00ff;\u0026quot;\u0026gt;cache（缓存分区）\u0026lt;/span\u0026gt;\u0026lt;/strong\u0026gt;等\u0026lt;br /\u0026gt; （4）格式化（清除）分区 \u0026lt;/p\u0026gt; \u0026lt;div class=\u0026quot;blockcode\u0026quot;\u0026gt; \u0026lt;div id=\u0026quot;code_UmC\u0026quot;\u0026gt; \u0026lt;ol\u0026gt; \u0026lt;li\u0026gt; fastboot erase \u0026lt;分区名\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;p\u0026gt; （5）启动IMG镜像（可用于测试我们下载的recovery是否可用或效果如何而不直接将其刷入手机） \u0026lt;/p\u0026gt; \u0026lt;div class=\u0026quot;blockcode\u0026quot;\u0026gt; \u0026lt;div id=\u0026quot;code_hbK\u0026quot;\u0026gt; \u0026lt;ol\u0026gt; \u0026lt;li\u0026gt; fastboot boot \u0026lt;IMG路径\u0026gt;（可拖拽入窗口） \u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;p\u0026gt; （6）启动到系统 \u0026lt;/p\u0026gt; \u0026lt;div class=\u0026quot;blockcode\u0026quot;\u0026gt; \u0026lt;div id=\u0026quot;code_DsB\u0026quot;\u0026gt; \u0026lt;ol\u0026gt; \u0026lt;li\u0026gt; fastboot reboot \u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;p\u0026gt; 基本的命令大概就是这些，平常可能用到的也大概只有这些命令。 \u0026lt;/p\u0026gt;    ","date":"2019-03-19","img":"","permalink":"https://helixs.github.io/posts/2019-03-19-adb_fastboot%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","series":null,"tags":null,"title":"Adb_fastboot常用命令"},{"categories":["未分类"],"content":"今天在代码中设置button的minheight，发现没有效果。结果发现代码中设置minHeight实际上对应的是text的绘制最小区域，要使用minimumHeight\n ","date":"2019-03-11","img":"","permalink":"https://helixs.github.io/posts/2019-03-11-androidbutton%E8%AE%BE%E7%BD%AEminheight%E5%92%8Cminwidth%E6%97%A0%E6%95%88%E7%9A%84%E9%97%AE%E9%A2%98/","series":null,"tags":null,"title":"AndroidButton设置minHeight和minWidth无效的问题"},{"categories":["未分类"],"content":" ","date":"2019-03-06","img":"","permalink":"https://helixs.github.io/posts/2019-03-06-%E5%AE%9E%E7%8E%B0%E5%9C%A8gridlayoutmanager%E4%B8%AD%E5%AE%BD%E9%AB%98%E4%B8%80%E8%87%B4%E7%9A%84item/","series":null,"tags":null,"title":"实现在gridLayoutManager中宽高一致的item"},{"categories":["linux常用配置"],"content":"卸载阿里云盾监控： 删除残留： 屏蔽云盾 IP，用包过滤屏蔽如下IP： 卸载云监控Java版本插件： sudo /usr/local/cloudmonitor/wrapper/bin/cloudmonitor.sh remove\nsudo rm -rf /usr/local/cloudmonitor","date":"2019-03-06","img":"","permalink":"https://helixs.github.io/posts/2019-03-06-%E5%8D%B8%E8%BD%BD%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%91%E6%8E%A7%E6%9C%8D%E5%8A%A1/","series":null,"tags":null,"title":"卸载阿里云监控服务"},{"categories":["Android开发"],"content":"我们从屏幕截图或者从imageView中获得bitmap大多都是从以下代码获取\n但是这些方法在api28的时候都过期了，虽然可以用不过在api26之后google放了个PixelCopy这个类，他是直接从指定的window上获取surface对象 在通过native方法获取的。\n\u0026lt;div\u0026gt; 还有它不是直接在view上获取，而是在window上，所以要确定要位置，不然获取的地方不单单是你绘制的那个区域了，所以我们要把控好位置和距离，这个是缺点如果图像层叠的话那就没办法了，盖住的部分肯定无法获取，这是缺点。不过也带来了优点，如果像获取某个区域块的图像，更是一种好方法。 如果不行那就还是用老的方法吧。 \u0026lt;/div\u0026gt; ","date":"2019-02-28","img":"","permalink":"https://helixs.github.io/posts/2019-02-28-android%E4%BB%8Eview%E4%B8%AD%E8%8E%B7%E5%8F%96bitmap/","series":null,"tags":null,"title":"Android从view中获取bitmap"},{"categories":["未分类"],"content":"Android图像处理——Paint之Xfermode https://blog.csdn.net/allen315410/article/details/45077165 ","date":"2019-02-26","img":"","permalink":"https://helixs.github.io/posts/2019-02-26-%E8%87%AA%E5%AE%9A%E4%B9%89view%E7%BB%98%E5%88%B6%E7%AD%89%E7%9B%B8%E5%85%B3%E4%BB%8B%E7%BB%8D%E5%9C%B0%E5%9D%80/","series":null,"tags":null,"title":"自定义View绘制等相关介绍地址"},{"categories":["Android开发"],"content":"上一篇文章已经转载了大神的，总结一下基本的加载使用方式\n ","date":"2019-02-26","img":"","permalink":"https://helixs.github.io/posts/2019-02-26-bitmap%E5%8A%A0%E8%BD%BD%E4%B9%8B%E5%9F%BA%E6%9C%AC%E7%9A%84%E4%BD%BF%E7%94%A8/","series":null,"tags":null,"title":"Bitmap加载之基本的使用"},{"categories":["Android开发"],"content":"https://juejin.im/entry/59b6419d5188257e82675716  Bitmap图像处理的最重要类之一。用它可以获取图像文件信息，进行图像颜色变换、剪切、旋转、缩放等操作，并可以指定格式保存图像文件\n ____\nBitmap中有两个内部枚举类：Config和CompressFormat，\nConfig是用来设置颜色配置信息的，\nCompressFormat是用来设置压缩方式的。\n__\nConfig解析：\n Bitmap.Config.ALPHA_8：颜色信息只由透明度组成，占8位。 Bitmap.Config.ARGB_4444：颜色信息由透明度与R（Red），G（Green），B（Blue）四部分组成，每个部分都占4位，总共占16位。 Bitmap.Config.ARGB_8888：颜色信息由透明度与R（Red），G（Green），B（Blue）四部分组成，每个部分都占8位，总共占32位。是Bitmap默认的颜色配置信息，也是最占空间的一种配置。 Bitmap.Config.RGB_565：颜色信息由R（Red），G（Green），B（Blue）三部分组成，R占5位，G占6位，B占5位，总共占16位。   通常我们优化Bitmap时，当需要做性能优化或者防止OOM（Out Of Memory），我们通常会使用Bitmap.Config.RGB_565这个配置，因为Bitmap.Config.ALPHA_8只有透明度，显示一般图片没有意义，Bitmap.Config.ARGB_4444显示图片不清楚，Bitmap.Config.ARGB_8888占用内存最多。\n CompressFormat解析：\n Bitmap.CompressFormat.JPEG：表示以JPEG压缩算法进行图像压缩，压缩后的格式可以是”.jpg”或者”.jpeg”，是一种有损压缩。 Bitmap.CompressFormat.PNG：表示以PNG压缩算法进行图像压缩，压缩后的格式可以是”.png”，是一种无损压缩。 Bitmap.CompressFormat.WEBP：表示以WebP压缩算法进行图像压缩，压缩后的格式可以是”.webp”，是一种有损压缩，质量相同的情况下，WebP格式图像的体积要比JPEG格式图像小40%。美中不足的是，WebP格式图像的编码时间“比JPEG格式图像长8倍”。  itmap.createBitmap(Bitmap source, int x, int y, int width, int height)\n根据源Bitmap对象source，创建出source对象裁剪后的图像的Bitmap。x,y分别代表裁剪时，x轴和y轴的第一个像素，width，height分别表示裁剪后的图像的宽度和高度。 注意：x+width要小于等于source的宽度，y+height要小于等于source的高度。\nBitmap.createBitmap(Bitmap source, int x, int y, int width, int height,Matrix m, boolean filter)\n这个方法只比上面的方法多了m和filter这两个参数，m是一个Matrix（矩阵）对象，可以进行缩放，旋转，移动等动作，filter为true时表示source会被过滤，仅仅当m操作不仅包含移动操作，还包含别的操作时才适用。其实上面的方法本质上就是调用这个方法而已。\n public static Bitmap createBitmap(Bitmap source, int x, int y, int width, int height) { return createBitmap(source, x, y, width, height, null, false); }  Bitmap缩放，旋转，移动，倾斜图像其实就是通过Bitmap.createBitmap(Bitmap source, int x, int y, int width, int height,Matrix m, boolean filter)方法实现的，只是在实现这些功能的同时还可以实现图像的裁剪。\n// 定义矩阵对象 Matrix matrix = new Matrix(); // 缩放图像 matrix.postScale(0.8f, 0.9f); // 向左旋转（逆时针旋转）45度，参数为正则向右旋转（顺时针旋转） matrix.postRotate(-45); //移动图像 //matrix.postTranslate(100,80); Bitmap bitmap = Bitmap.createBitmap(source, 0, 0, source.getWidth(), source.getHeight(), matrix, true);  Matrix的postScale和postRotate方法还有多带两个参数的重载方法postScale(float sx, float sy, float px, float py)和postRotate(float degrees, float px, float py)，后两个参数px和py都表示以该点为中心进行操作。\n注意：虽然Matrix还可以调用postSkew方法进行倾斜操作，但是却不可以在此时创建Bitmap时使用。\nbitmap=BitmapFactory.decodeResource(getResources(),R.drawable.feng); File file=new File(getFilesDir(),\u0026quot;lavor.jpg\u0026quot;); if(file.exists()){ file.delete(); } try { FileOutputStream outputStream=new FileOutputStream(file); bitmap.compress(Bitmap.CompressFormat.JPEG,90,outputStream); outputStream.flush(); outputStream.close(); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } bitmap.recycle();//释放bitmap的资源，这是一个不可逆转的操作     方法 介绍     setRotate(float degrees, float px, float py) 对图片进行旋转   setScale(float sx, float sy) 对图片进行缩放   setTranslate(float dx, float dy) 对图片进行平移   postTranslate(centerX, centerY) 在上一次修改的基础上进行再次修改 set 每次操作都是最新的 会覆盖上次的操作     //显示原图 ImageView iv_src = (ImageView) findViewById(R.id.iv_src); //显示副本 ImageView iv_copy = (ImageView) findViewById(R.id.iv_copy); //[1]先把tomcat.png 图片转换成bitmap 显示到iv_src Bitmap srcBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.tomcat); //[1.1]操作图片 // srcBitmap.setPixel(20, 30, Color.RED); iv_src.setImageBitmap(srcBitmap); //[2]创建原图的副本 //[2.1]创建一个模板 相当于 创建了一个大小和原图一样的 空白的白纸 Bitmap copybiBitmap = Bitmap.createBitmap(srcBitmap.getWidth(), srcBitmap.getHeight(), srcBitmap.getConfig()); //[2.2]想作画需要一个画笔 Paint paint = new Paint(); //[2.3]创建一个画布 把白纸铺到画布上 Canvas canvas = new Canvas(copybiBitmap); //[2.4]开始作画 Matrix matrix = new Matrix(); //[2.5]对图片进行旋转 //matrix.setRotate(20, srcBitmap.getWidth()/2, srcBitmap.getHeight()/2); //[2.5]对图片进行 // matrix.setScale(0.5f, 0.5f); //[2.6]对图片进行平移 // matrix.setTranslate(30, 0); //[2.7]镜面效果 如果2个方法一起用 // matrix.setScale(-1.0f, 1); //post是在上一次修改的基础上进行再次修改 set 每次操作都是最新的 会覆盖上次的操作 // matrix.postTranslate(srcBitmap.getWidth(), 0); //[2,7]倒影效果 matrix.setScale(1.0f, -1); //post是在上一次修改的基础上进行再次修改 set 每次操作都是最新的 会覆盖上次的操作 matrix.postTranslate(0, srcBitmap.getHeight()); canvas.drawBitmap(srcBitmap,matrix , paint); //[3]把copybimap显示到iv_copy上 iv_copy.setImageBitmap(copybiBitmap);   创建位图对象从不同的来源,包括文件、流, 和字节数组。\n    方法 说明     decodeFile(String pathName, Options opts) 从文件读取图片   decodeFile(String pathName) 从文件读取图片   decodeFileDescriptor(FileDescriptor fd) 从文件读取文件 与decodeFile不同的是这个直接调用JNI函数进行读取 效率比较高   decodeFileDescriptor(FileDescriptor fd, Rect outPadding, Options opts) 同上   decodeStream(InputStream is) 从输入流读取图片   decodeStream(InputStream is, Rect outPadding, Options opts) 从输入流读取图片   decodeStream(InputStream is, Rect outPadding, Options opts) 从资源文件读取图片   decodeResource(Resources res, int id) 从资源文件读取图片   decodeResource(Resources res, int id, Options opts) 从资源文件读取图片   decodeByteArray(byte[] data, int offset, int length) 从数组读取图片   decodeByteArray(byte[] data, int offset, int length, Options opts) 从数组读取图片     BitmapFactory.decodeResource 加载的图片可能会经过缩放，该缩放目前是放在 java 层做的，效率比较低，而且需要消耗 java 层的内存。因此，如果大量使用该接口加载图片，容易导致OOM错误\nBitmapFactory.decodeStream 不会对所加载的图片进行缩放，相比之下占用内存少，效率更高。\n这两个接口各有用处，如果对性能要求较高，则应该使用 decodeStream；如果对性能要求不高，且需要 Android 自带的图片自适应缩放功能，则可以使用 decodeResource。\n   1）从资源文件读取图片\nBitmap bitmap= BitmapFactory.decodeResource(getResources(),R.drawable.after19); iv.setImageBitmap(bitmap);\n  2）从输入流中读取图片\nFileInputStream fis=new FileInputStream(new File(getFilesDir()+\u0026quot;/psb.jpg\u0026quot;)); Bitmap bitmap= BitmapFactory.decodeStream(fis); iv.setImageBitmap(bitmap);\n  3）从数组中读取图片\npublic static Bitmap readBitmapFromByteArray(byte[] data, int width, int height) { BitmapFactory.Options options = new BitmapFactory.Options(); options.inJustDecodeBounds = true; BitmapFactory.decodeByteArray(data, 0, data.length, options); float srcWidth = options.outWidth; float srcHeight = options.outHeight; int inSampleSize = 1;\n if (srcHeight \u0026gt; height || srcWidth \u0026gt; width) { if (srcWidth \u0026gt; srcHeight) { inSampleSize = Math.round(srcHeight / height); } else { inSampleSize = Math.round(srcWidth / width); } } options.inJustDecodeBounds = false; options.inSampleSize = inSampleSize; return BitmapFactory.decodeByteArray(data, 0, data.length, options);  }\n    1）保存本地图片\npublic static void writeBitmapToFile(String filePath, Bitmap b, int quality) { try { File desFile = new File(filePath); FileOutputStream fos = new FileOutputStream(desFile); BufferedOutputStream bos = new BufferedOutputStream(fos); b.compress(Bitmap.CompressFormat.JPEG, quality, bos); bos.flush(); bos.close(); } catch (IOException e) { e.printStackTrace(); } }\n  2）图片缩放\npublic static Bitmap bitmapScale(Bitmap bitmap, float scale) { Matrix matrix = new Matrix(); matrix.postScale(scale, scale); // 长和宽放大缩小的比例 Bitmap resizeBmp = Bitmap.createBitmap(bitmap, 0, 0, bitmap.getWidth(), bitmap.getHeight(), matrix, true); return resizeBmp; }\n  3）对 bitmap 进行裁剪\npublic Bitmap bitmapClip(Context context , int id , int x , int y){ Bitmap map = BitmapFactory.decodeResource(context.getResources(), id); map = Bitmap.createBitmap(map, x, y, 120, 120); return map; }\n     Option参数类方法 说明     public boolean inJustDecodeBounds 如果设置为true，不获取图片，不分配内存，但会返回图片的高度宽度信息   public int inSampleSize 图片缩放的倍数   public int outWidth 获取图片的宽度值   public int outHeight 获取图片的高度值   public int inDensity 用于位图的像素压缩比   public int inTargetDensity 用于目标位图的像素压缩比（要生成的位图）   public byte[] inTempStorage 创建临时文件，将图片存储   public boolean inScaled 设置为true时进行图片压缩，从inDensity到inTargetDensity   public boolean inDither 如果为true,解码器尝试抖动解码   public Bitmap.Config inPreferredConfig 设置解码器这个值是设置色彩模式，默认值是ARGB_8888，在这个模式下，一个像素点占用4bytes空间，一般对透明度不做要求的话，一般采用RGB_565模式，这个模式下一个像素点占用2bytes   public String outMimeType 设置解码图像   public boolean inPurgeable 当存储Pixel的内存空间在系统内存不足时是否可以被回收   public boolean inInputShareable inPurgeable为true情况下才生效，是否可以共享一个InputStream   public boolean inPreferQualityOverSpeed 为true则优先保证Bitmap质量其次是解码速度   public boolean inMutable 配置Bitmap是否可以更改，比如：在Bitmap上隔几个像素加一条线段   public int inScreenDensity 当前屏幕的像素密度    https://www.jianshu.com/p/384a70897ba6 https://www.jianshu.com/p/98c88f9ceafa   ","date":"2019-02-26","img":"","permalink":"https://helixs.github.io/posts/2019-02-26-android-bitmap%E6%9C%80%E5%85%A8%E9%9D%A2%E8%AF%A6%E8%A7%A3/","series":null,"tags":null,"title":"Android Bitmap最全面详解"},{"categories":["Android开发"],"content":"使用 FragmentPagerAdapter 时，ViewPager 中的所有 Fragment 实例常驻内存，当 Fragment 变得不可见时仅仅是视图结构的销毁，即调用了 onDestroyView 方法。由于 FragmentPagerAdapter 内存消耗较大，所以适合少量静态页面的场景。\n使用 FragmentStatePagerAdapter 时，当 Fragment 变得不可见，不仅视图层次销毁，实例也被销毁，即调用了 onDestroyView 和 onDestroy 方法，仅仅保存 Fragment 状态。相比而言， FragmentStatePagerAdapter 内存占用较小，所以适合大量动态页面，比如我们常见的新闻列表类应用。\n不管是哪种情况，他们的view都是有可能被销毁的。关键点是在于view的保存和fragment的显示隐藏状态\n 二 、当使用FragmentPagerAdapter动态删除和添加的问题 看下面的源码\ninstantiateItem在执行时会FragmentManager里面查找是否已存在对应的fragment，如果不存在，才会执行getItem 。所以会无效\n两个解决方法\n1使用FragmentPagerStateAdapter\n2覆写getItemId()\n  未完待续\n感谢http://yifeng.studio/2016/12/23/android-fragment-and-viewpager-attentions/ ","date":"2019-02-15","img":"","permalink":"https://helixs.github.io/posts/2019-02-15-viewpagerfragment%E7%9A%84%E6%87%92%E5%8A%A0%E8%BD%BD/","series":null,"tags":["fragment"],"title":"Viewpager+fragment的懒加载"},{"categories":["编程语言"],"content":"\u0008今天开始仔细研究kotlin的泛型，顺便把java的泛型也温习一下。\n =============================================\n在kotlin中亦是如此\nin：很像\u0026lt;? super T\u0026gt; out很像\u0026lt;? extends T\u0026gt; 不过他们限制的更加严格，变量类型中无法加入\u0026lt;? extends T\u0026gt;和\u0026lt;？super T\u0026gt; 在类型定义的时候已经限制好了\n参考资料\nhttps://www.kotlincn.net/docs/reference/generics.html https://zhuanlan.zhihu.com/p/27672091 https://www.jianshu.com/p/a41cb479b278      ","date":"2019-01-28","img":"","permalink":"https://helixs.github.io/posts/2019-01-28-java%E5%92%8Ckotlin%E4%B8%AD%E6%B3%9B%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6%E8%8D%89%E7%A8%BF/","series":null,"tags":null,"title":"Java和kotlin中泛型通配符（草稿）"},{"categories":["Android开发"],"content":"前前后后google不知道每年推出N中新东西，每次看了看就忘记了，还是回忆一下ConstraintLayout这个约束布局了。\n 布局在2016年就已经推出了，并且在当年的IO大会上重点讲解了它的特点：\n  解决复杂布局嵌套过多，影响性能的问题。 相对定位，和RelativeLayout大致相同，也同样支持Baseline基线定位。 角度定位，更加玄学了。角度和距离定位了（想象一下在直角坐标系中中心点O距离点A的角度和距离了）。 支持按照比例偏移。 尺寸方面，match_parent尽量少用，直接0dp往上干。并且更好的支持比例约束。 链式布局，可以想象在Flex布局中justify-content，不过没有flex那么强大啦，也只有3个属性选择。 Optimizer，当控件设置尺寸为0dp的时候布局会进行二次测量，不可避免的会进行耗时操作，所以要进行处理。 Barrier，屏障，相当于一个阈值吧，不过我这样形容不恰当。 Group，可以将控件进行分组，而直接在这个组上面设置属性，那么组当中所带入的属性会直接传到属于这个组的控件上面。感觉这个设计特别棒，如统一的颜色和统一的显示隐藏等。 Placeholder，占位符，也很吊，可以动态控制显示的控件。不需要我们每次动态setVisibility了。 Guideline，辅助线，执行复杂布局中这个是很有效的东西哦。   上面就是这个ConstraintLayout的一些特性了。下面就慢慢的介绍一下它的具体使用方式\nConstraintLayout  1public class ConstraintLayout extends ViewGroup  java.lang.Object\n android.view.View\n android.view.ViewGroup\n android.support.constraint.ConstraintLayout\n    1、相对约束 RelativeLayout用的还算熟练吧，不过我自己基本不用，为啥？大家应该都知道，要些一堆的align,to….等等和一大堆的ID，没有很好的层级关系和组关系。不喜欢麻烦的我往往喜欢使用一大堆LinearLayout和FrameLayout进行嵌套。层次倒是很清楚了哈。这样往往写的代码量也很多，嵌套也很多。\n我们先看看在ConstraintLayout中相对约束的基本使用\n如layout_constraintLeft_toLeftOf=”parent” ：意思就是当前控件左边的约束是在父控件的左边，当然parent也可以是某个控件，依次类推基本的实现方式就是这样了。其实使用layout_constraintStart_toStartOf和上面是一样的效果，不过基本上被start和end替代了，因为有些语言是从右往左读的啦就是RTL-\u0026gt;right to left，如阿拉伯语。哈哈是不是古时候的汉语也是从右往左呢。如果做国际化是有这个需求啦。\nlayout_constraintBaseline_toBaselineOf 这个是基线对齐哦。\n2、角度定位 1\u0026lt;Button 2 android:id=\u0026#34;@+id/btn1\u0026#34; 3 android:layout_width=\u0026#34;wrap_content\u0026#34; 4 android:layout_height=\u0026#34;wrap_content\u0026#34; /\u0026gt; 5 6\u0026lt;Button 7 android:id=\u0026#34;@+id/btn2\u0026#34; 8 android:layout_width=\u0026#34;wrap_content\u0026#34; 9 android:layout_height=\u0026#34;wrap_content\u0026#34; 10 app:layout_constraintCircle=\u0026#34;@+id/btn1\u0026#34; 11 app:layout_constraintCircleAngle=\u0026#34;120\u0026#34; 12 app:layout_constraintCircleRadius=\u0026#34;150dp\u0026#34; /\u0026gt; 角度定位是按照控件的中心点来的，在Y轴正方向上取长度为150dp的线段绕着点btn1中心顺时针旋转120度后就是btn2中心位置。\n3、MARGIN ConstraintLayout中的margin和普通布局一样的，需要注意的是必须是控件已经完全约束了才能使margin这个属性有效果。\n这里主要说一下goneMargin\n1 \u0026lt;Button 2 android:id=\u0026#34;@+id/btn1\u0026#34; 3 android:layout_width=\u0026#34;wrap_content\u0026#34; 4 android:layout_height=\u0026#34;wrap_content\u0026#34; /\u0026gt; 5 6\u0026lt;Button 7 android:id=\u0026#34;@+id/btn2\u0026#34; 8 android:layout_width=\u0026#34;wrap_content\u0026#34; 9 android:layout_height=\u0026#34;wrap_content\u0026#34; 10 app:layout_goneMarginTop=\u0026#34;10\u0026#34; 11 app:layout_constraintCircle=\u0026#34;@+id/btn1\u0026#34; 12 app:layout_constraintCircleAngle=\u0026#34;120\u0026#34; 13 app:layout_constraintCircleRadius=\u0026#34;150dp\u0026#34; /\u0026gt; 如果当btn1被gone掉了，btn2依然可以距离btn1底部10dp。\n4、比例偏移 我们偏移常常用的是margin具体的大小。ConstraintLayout可以按照比例偏移\n1\u0026lt;Button 2 android:id=\u0026#34;@+id/btn1\u0026#34; 3 app:layout_constraintStart_toStartOf=\u0026#34;parent\u0026#34; 4 app:layout_constraintTop_toTopOf=\u0026#34;parent\u0026#34; 5 android:layout_width=\u0026#34;wrap_content\u0026#34; 6 android:background=\u0026#34;@color/design_default_color_primary\u0026#34; 7 android:layout_height=\u0026#34;wrap_content\u0026#34; /\u0026gt; 8 9\u0026lt;Button 10 android:layout_width=\u0026#34;wrap_content\u0026#34; 11 app:layout_constraintTop_toTopOf=\u0026#34;parent\u0026#34; 12 app:layout_constraintStart_toStartOf=\u0026#34;@id/btn1\u0026#34; 13 app:layout_constraintEnd_toEndOf=\u0026#34;@id/btn2\u0026#34; 14 android:layout_height=\u0026#34;wrap_content\u0026#34; /\u0026gt; 15 16\u0026lt;Button 17 android:id=\u0026#34;@+id/btn2\u0026#34; 18 app:layout_constraintEnd_toEndOf=\u0026#34;parent\u0026#34; 19 app:layout_constraintTop_toTopOf=\u0026#34;parent\u0026#34; 20 android:layout_width=\u0026#34;wrap_content\u0026#34; 21 android:background=\u0026#34;@color/design_default_color_primary\u0026#34; 22 android:layout_height=\u0026#34;wrap_content\u0026#34; /\u0026gt; 按照上面的方式：\n默认是居中的，我们修改一下:\n1\u0026lt;Button 2 android:id=\u0026#34;@+id/btn1\u0026#34; 3 app:layout_constraintStart_toStartOf=\u0026#34;parent\u0026#34; 4 app:layout_constraintTop_toTopOf=\u0026#34;parent\u0026#34; 5 android:layout_width=\u0026#34;wrap_content\u0026#34; 6 android:background=\u0026#34;@color/design_default_color_primary\u0026#34; 7 android:layout_height=\u0026#34;wrap_content\u0026#34; /\u0026gt; 8 9\u0026lt;Button 10 android:layout_width=\u0026#34;wrap_content\u0026#34; 11 app:layout_constraintTop_toTopOf=\u0026#34;parent\u0026#34; 12 app:layout_constraintStart_toStartOf=\u0026#34;@id/btn1\u0026#34; 13 app:layout_constraintHorizontal_bias=\u0026#34;0.3\u0026#34; 14 app:layout_constraintEnd_toEndOf=\u0026#34;@id/btn2\u0026#34; 15 android:layout_height=\u0026#34;wrap_content\u0026#34; /\u0026gt; 16 17\u0026lt;Button 18 android:id=\u0026#34;@+id/btn2\u0026#34; 19 app:layout_constraintEnd_toEndOf=\u0026#34;parent\u0026#34; 20 app:layout_constraintTop_toTopOf=\u0026#34;parent\u0026#34; 21 android:layout_width=\u0026#34;wrap_content\u0026#34; 22 android:background=\u0026#34;@color/design_default_color_primary\u0026#34; 23 android:layout_height=\u0026#34;wrap_content\u0026#34; /\u0026gt; 是这样的:\n看到了吧，我们可以按照比例来放置约束条件，是不是不错呢。我们以前的话是不是还要在外面放入LinearLayout加入weight呢。\n5、尺寸约束 如果你的控件想撑满parent的宽或者高，就不要使用match_parent了，直接设置0dp便是，前提是加上约束条件。如果直接用match_parent会超过屏幕显示哦，gg了。\nlayout_constraintDimensionRatio这个属性是设置宽高比例。如果当宽或高其中一个设置为0dp的时候，\n可以设置layout_constraintDimensionRatio=”1:1″，就是宽高1:1。\n当然也可以设置别的比例，很方便:\n layout_constraintDimensionRatio=”H,2:3″ 高宽比\nlayout_constraintDimensionRatio=”W,3:2″ 宽高比\n 6、链式布局   1.如果使用链式布局需要遵循这种要求\n即链的两边都要有约束，且链上的控件只与相邻控件有约束条件\n  2.链头\n链头即第一个控件是链属性设置的位置，水平方向上的开头或者垂直方向上的顶部第一个。链的属性都在这上面设置。\n  3.链属性\n通过在链头设置layout_constraintHorizontal_chainStyle和layout_constraintVertical_chainStyle分别设置水平和垂直方向上的链样式。并且提供了三种属性\n CHAIN_SPREAD 默认属性，元素相互展开 CHAIN_SPREAD_INSIDE 元素也是相互展开，但是链的两端贴紧约束，不会展开 CHAIN_PACKED 将元素们紧紧贴在一起，就是一坨。    其中Weighted Chain是当width为0dp时候加入layout_constraintHorizontal_weight权重比例来的。而Packed Cain with Bias 是加入了layout_constraintHorizontal_bias出现的比例。\n  7、OPTIMIZER 就是当控件中使用了0dp的宽或者高的时候会进行2次测量，这时候就需要优化，不过我感觉真不知道怎么用，还需要多看看 layout_optimizationLevel\n none : no optimizations are applied standard : Default. Optimize direct and barrier constraints only direct : optimize direct constraints barrier : optimize barrier constraints chain : optimize chain constraints (experimental) dimensions : optimize dimensions measures (experimental), reducing the number of measures of match constraints elements  8、BARRIER 屏障 当我们有ABC三个控件，C在AB的右边，但AB的宽度不一样，我们要让C永远都在A或者B的右边怎么办\n1\u0026lt;TextView 2 android:id=\u0026#34;@+id/TextView1\u0026#34; 3 android:layout_width=\u0026#34;wrap_content\u0026#34; 4 android:layout_height=\u0026#34;wrap_content\u0026#34; /\u0026gt; 5 6\u0026lt;TextView 7 android:id=\u0026#34;@+id/TextView2\u0026#34; 8 android:layout_width=\u0026#34;wrap_content\u0026#34; 9 android:layout_height=\u0026#34;wrap_content\u0026#34; 10 app:layout_constraintTop_toBottomOf=\u0026#34;@+id/TextView1\u0026#34; /\u0026gt; 11 12\u0026lt;android.support.constraint.Barrier 13 android:id=\u0026#34;@+id/barrier\u0026#34; 14 android:layout_width=\u0026#34;wrap_content\u0026#34; 15 android:layout_height=\u0026#34;wrap_content\u0026#34; 16 app:barrierDirection=\u0026#34;right\u0026#34; 17 app:constraint_referenced_ids=\u0026#34;TextView1,TextView2\u0026#34; /\u0026gt; 18 19\u0026lt;TextView 20 android:id=\u0026#34;@+id/TextView3\u0026#34; 21 android:layout_width=\u0026#34;wrap_content\u0026#34; 22 android:layout_height=\u0026#34;wrap_content\u0026#34; 23 app:layout_constraintLeft_toRightOf=\u0026#34;@+id/barrier\u0026#34; /\u0026gt; app:barrierDirection为屏障所在的位置，可设置的值有：bottom、end、left、right、start、top ,app:constraint_referenced_ids为屏障引用的控件，可设置多个(用“,”隔开)\n10、占位符 我们通过Placeholder控件，将其中其他一个控件进行绑定，转移到这里来，通过content属性\n11、GUIDELINE 辅助线 通过guideline可以实现较为复杂的布局，并且这个不会显示在屏幕上。主要属性是\n  android:orientation layout_constraintGuide_begin layout_constraintGuide_end layout_constraintGuide_percent   遇到的问题 1.当ConstrainLayout布局高度固定，子布局是动态高度，要求子布局不超过父布局，所以子布局高度warp_conent，但是怎么加约束高度到了还是会超过父布局，比如子布局当中有个RecyclerView或者Scrollview等等。用两个属性：\n  app:layout_constrainedHeight=\u0026ldquo;true\u0026rdquo; app:layout_constrainedWidth=\u0026ldquo;true\u0026rdquo;   意思就是约束宽高。\n","date":"2019-01-22","img":"","permalink":"https://helixs.github.io/posts/android/2019-01-22-android%E5%B8%83%E5%B1%80%E4%B9%8Bconstraintlayout%E7%9A%84%E4%B8%80%E4%BA%9B%E7%89%B9%E6%80%A7/","series":null,"tags":null,"title":"Android布局之ConstraintLayout的一些特性"},{"categories":["vps工具"],"content":"什么是BBR：  TCP BBR是谷歌出品的TCP拥塞控制算法。BBR目的是要尽量跑满带宽，并且尽量不要有排队的情况。BBR可以起到单边加速TCP连接的效果。\n  Google提交到Linux主线并发表在ACM queue期刊上的TCP-BBR拥塞控制算法。继承了Google“先在生产环境上部署，再开源和发论文”的研究传统。TCP-BBR已经再YouTube服务器和Google跨数据中心的内部广域网(B4)上部署。由此可见出该算法的前途。\n  TCP-BBR的目标就是最大化利用网络上瓶颈链路的带宽。一条网络链路就像一条水管，要想最大化利用这条水管，最好的办法就是给这跟水管灌满水。\n BBR解决了两个问题：\n 在有一定丢包率的网络链路上充分利用带宽。非常适合高延迟，高带宽的网络链路。 降低网络链路上的buffer占用率，从而降低延迟。非常适合慢速接入网络的用户。  以上来自http://blog.51cto.com/zero01/2064660  通过上面我们大概知道bbr就是想办法给你加大带宽流量的和速锐那种暴力发包是两回事。google的这个bbr算法已经集成到linux4.9内核以上，即便你的系统是最新版但是大多数情况下云服务厂商默认都还是使用的3.x，所以我们要升级内核并且切换到该内核上面，最后再开启bbr。\n1#查看使用的内核版本，如果是4.9+的话就可以跳过了 2uname -a 然后我们进入http://elrepo.org/tiki/tiki-index.php 查看最新的rpm源，按照上面的方法进行源设置\n1#导入源 2rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org 3#设置源 4rpm -Uvh https://www.elrepo.org/elrepo-release-7.0-3.el7.elrepo.noarch.rpm 最新的教程已经不需要上面的这样了直接install\n1yum install https://www.elrepo.org/elrepo-release-7.0-3.el7.elrepo.noarch.rpm 然后，进入http://elrepo.org/tiki/kernel-ml 查看安装方法\n1yum --enablerepo=elrepo-kernel install kernel-ml 2#使用这个看不懂的命令进入查看已经安装的内核 3egrep ^menuentry /etc/grub2.cfg | cut -f 2 -d \\\u0026#39; 10 : CentOS Linux (4.20.2-1.el7.elrepo.x86_64) 7 (Core) 21 : CentOS Linux 7 Rescue 22d9950eefb24f96aca762064cd277d2 (3.10.0-957.1.3.el7.x86_64) 32 : CentOS Linux (3.10.0-957.1.3.el7.x86_64) 7 (Core) 43 : CentOS Linux (3.10.0-693.11.6.el7.x86_64) 7 (Core) 54 : CentOS Linux (3.10.0-693.el7.x86_64) 7 (Core) 65 : CentOS Linux (0-rescue-00a62363617944e08db8db894ba6145e) 7 (Core) 我这里已经安装了4.20的内核版本了，还得切换到这个内核\n1#因为是第0个所以是0 2grub2-set-default 0 3#重启 4reboot 1//查看内核版本 2uname - r 34.20.2-1.el7.elrepo.x86_64 4#没问题 5vim /etc/sysctl.conf 6#最后一行加入 7net.core.default_qdisc = fq 8net.ipv4.tcp_congestion_control = bbr 9#wq 10sysctl -p 11#net.core.default_qdisc = fq 12#net.ipv4.tcp_congestion_control = bbr 13sysctl net.ipv4.tcp_available_congestion_control 14#net.ipv4.tcp_available_congestion_control = reno cubic bbr 15lsmod | grep bbr 16#tcp_bbr 20480 1  基本上就成功啦。\n","date":"2019-01-16","img":"","permalink":"https://helixs.github.io/posts/linux/2019-01-16-centos%E5%BC%80%E5%90%AFbbr/","series":null,"tags":["bbr","centos"],"title":"Centos开启bbr"},{"categories":["开发环境"],"content":" 我们使用idea写kotlin代码的时候有很多类型都是自己判断了，不用像java一样强制定义类型，可是当我们写了一个变量或者赋值变量的时候能看到val或者是var的类型\n 比如我们现在想要这样一个代码\n1val rect= getMatrixRectF() 默认情况下我并不知道rect是个什么类型，然后我们就打开idea的设置了\nSetting-\u0026gt;Editor-\u0026gt;Appearance-\u0026gt;show parameter name hints-\u0026gt;Configure-\u0026gt;Language=Kotlin\n全部选中即可\n","date":"2019-01-15","img":"","permalink":"https://helixs.github.io/posts/android/2019-01-15-idea%E6%98%BE%E7%A4%BAkotlin%E7%9A%84%E6%8E%A8%E6%96%AD%E7%B1%BB%E5%9E%8B/","series":null,"tags":null,"title":"Idea显示kotlin的推断类型"},{"categories":["Android开发"],"content":" 今天android项目里有个需求，一个textview中要显示最多8个字符，英文算一个，中文算两个。满满以为直接用一下这种方法判断了\n 1public static String getDisplay(String data, int maxLength) { 2 if (TextUtils.isEmpty(data)) { 3 return data; 4 } 5 if (CheckUtil.isStringLength(data) \u0026lt;= maxLength) { 6 return data; 7 } 8 int length = 0; 9 StringBuilder stringBuilder = new StringBuilder(); 10 for (int i = 0; i \u0026lt; data.length(); i++) { 11 if (length \u0026gt;= maxLength) { 12 stringBuilder.append(\u0026#34;...\u0026#34;); 13 break; 14 } 15 String temp = data.substring(i, i + 1); 16 if (temp.matches(\u0026#34;[\\u4e00-\\u9fa5]\u0026#34;)) { 17 length += 2; 18 stringBuilder.append(temp); 19 } else { 20 length += 1; 21 stringBuilder.append(temp); 22 } 23 } 24 return stringBuilder.toString(); 25 26} 27 结果测试加入了emoji表情，直接截取0-7会在部分手机上出现？等无法识别的情况，然后是查了查emoji是基于Unicode编码来的，也就是说随便一个emoji组成的字符长度最少是两位,所以我直接截取了表情的一半那肯定就是不行了，然后具体查了查编码的历史从ascii到utf-8等等，这里https://www.cnblogs.com/gavin-num1/p/5170247.html 。\n然后找到了java的api主要关于unicode有以下几个方法\n  int\tcodePointAt(int index)\n返回指定索引处的字符（Unicode 代码点）。\n   int\tcodePointBefore(int index)\n返回指定索引之前的字符（Unicode 代码点）。\n   int codePointCount(int beginIndex, int endIndex)\n返回此 String 的指定文本范围中的 Unicode 代码点数。\n   int\toffsetByCodePoints(int index, int codePointOffset)\n返回此 String 中从给定的 index 处偏移 codePointOffset 个代码点的索引。\n  我们现在截取的字符数量是8位，然后我们就找到在0到7位中的unicode编码，这样汉字和emoji就一起解决了。\n1String newString = \u0026#34;1??1??\u0026#34;; 2System.out.println(newString.substring(0, newString.offsetByCodePoints(0, newString.codePointCount(0, 7)))); 3 4//print: 1??1? 是不是比上一个代码实现的简单的多。\n","date":"2019-01-14","img":"","permalink":"https://helixs.github.io/posts/android/2019-01-14-java%E5%85%B3%E4%BA%8E%E5%88%A4%E6%96%ADemoji%E4%BD%8D%E6%95%B0%E5%92%8C%E6%88%AA%E5%8F%96%E7%9A%84%E4%B8%80%E4%BA%9B%E5%A4%84%E7%90%86/","series":null,"tags":null,"title":"Java关于判断emoji位数和截取的一些处理"},{"categories":["Android开发"],"content":"今天在android项目中导入了kotlin的支持，可是怎么运行也运行不起来\nProgram type already present: javax.annotation.CheckReturnValue  等等 包冲突了，检查不同的library的版本，然后清空缓存重试\n","date":"2018-12-26","img":"","permalink":"https://helixs.github.io/posts/android/2018-12-26-android%E9%A1%B9%E7%9B%AE%E5%BC%95%E5%85%A5kotlin%E5%8C%85%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98/","series":null,"tags":null,"title":"Android项目引入kotlin包冲突问题"},{"categories":["Android开发"],"content":"今天做项目的时候用到了Transition动画。也就是android5.0中出现的。基本的使用方式我们都知道是用TransitionName在两个activity中进行绑定。\n现在的场景是activityA中有个recyclerview，点击item的时候跳转到activityB。B中是一个类似全屏的viewpager。item中的图片元素共享的viewpager指定的Item上。并且viewpager可以动态删除item，返回的A的时候item也要同步数量。\n想想实现功能应该不难。难的地方在于两个页面的item数量不一样，共享元素view的位置可能也不一样。如果B当中已经改变了item的数量和选中的viewpager的position的位置，A那边的共享元素该如何改变呢。现在开始展现真正的轮子了。\n1、基本使用 设置两个activity的style中 android:windowContentTransitions 为true\n1 \u0026lt;style name=\u0026#34;TransparentTheme\u0026#34; parent=\u0026#34;Theme.AppCompat.Light.NoActionBar\u0026#34;\u0026gt; 2 \u0026lt;item name=\u0026#34;android:windowTranslucentNavigation\u0026#34;\u0026gt;false\u0026lt;/item\u0026gt; 3 \u0026lt;item name=\u0026#34;android:windowTranslucentStatus\u0026#34;\u0026gt;true\u0026lt;/item\u0026gt; 4 \u0026lt;item name=\u0026#34;android:windowContentTransitions\u0026#34;\u0026gt;true\u0026lt;/item\u0026gt; 5 \u0026lt;item name=\u0026#34;android:windowIsTranslucent\u0026#34;\u0026gt;false\u0026lt;/item\u0026gt; 6 \u0026lt;item name=\u0026#34;android:windowNoTitle\u0026#34;\u0026gt;true\u0026lt;/item\u0026gt; 7\u0026lt;/style\u0026gt; 共享元素关键点是绑定的view和view的TransitionName，那么我们就要给itemView设置transitionName了。这里我们使用url给item设置TransitionName，如果item的url一样那么可以自己想想，保持唯一就行了。\n1ViewCompat.setTransitionName(holder.itemView, ims.get(position).url); ViewCompat是support兼容类。不然就要写一堆判断了很是烦。\n启动activity绑定transitionView,将list和选中的item传入\n1 ActivityOptionsCompat options = 2 ActivityOptionsCompat.makeSceneTransitionAnimation(A.this, 3 holder.itemView, ViewCompat.getTransitionName(holder.itemView)); 4Intent intent = new Intent(A.this, B.class); 5intent.putExtra(B.INTENT_SELECT_POSITION, imgs.get(holder.getAdapterPosition())); 6intent.putParcelableArrayListExtra(B.INTENT_IMGS, imgs); 7ActivityCompat.startActivityForResult(A.this, intent, REQUEST_CODE_PREVIEW, options.toBundle()); 之后我们到了B的Activity，这里我们不要为viewpager的每个itemview设置transitionName，我们直接给viewpager设置transitionName，以为viewpager选中页的两边都会加载view，处理起来稍微有点麻烦，直接设置viewpager的transitionName反而方便连贯。\n1//currentItem是我从上个页面传进来的Item 2ViewCompat.setTransitionName(viewPager, currentItem.url); 3//.... 4//设置选中的item 5viewPager.setCurrentItem(i); 1@Override 2public void onBackPressed() { 3 checkFinish(RESULT_OK); 4} 5/** 6* 通过转场动画finish 7*/ 8private void checkFinish(int resultCode) { 9 Intent intent = new Intent(); 10 intent.putParcelableArrayListExtra(INTENT_IMGS, imgs); 11 setResult(resultCode, intent); 12 supportFinishAfterTransition(); 13} 2、进阶使用 基本的点击返回效果我们就搞好了，可是还是会出现动画不连贯的效果。一头雾水的搜了一下\n1//如果共享元素需要通过AsyncTask，一个Loader，或其他类似的进行数据加载在被调用的 2//Activity决定它们最终的表现，数据被分发返回到主线程之前框架可以开始过渡。 3supportPostponeEnterTransition()//暂时阻止共享元素过渡 4supportStartPostponedEnterTransition//确认元素都已经摆放完成恢复过度 因为viewpager.setCurrentItem之后UI毕竟是在默认300ms完成绘制。所以我们要等待viewpager完全展示完成才能进行过渡动画的渲染。\n1@Override 2protected void onCreate(Bundle savedInstanceState) { 3 super.onCreate(savedInstanceState); 4 supportPostponeEnterTransition(); 5 ....//更新ui 6 //监听viewpager布局树已经绘制完成 7 viewPager.getViewTreeObserver().addOnGlobalLayoutListener(new 8 ViewTreeObserver.OnGlobalLayoutListener() { 9 @Override 10 public void onGlobalLayout() { 11 viewPager.getViewTreeObserver().removeOnGlobalLayoutListener(this); 12 //释放 13 supportStartPostponedEnterTransition(); 14 } 15 }); 16} 这样我们的连贯效果就实现了。\n3、完成实现 因为我们知道B页面是带有删除和翻页功能的，所以我们就要进行页面之间切换时候的ui数据整理。我试着在onActivityResult中用supportPostponeEnterTransition和supportStartPostponedEnterTransition实现数据的变换，发现效果并没有实现，onActivityResult在过渡动画后才调用。所以还是搜索一下\n1/** 2* Called when an activity you launched with an activity transition exposes this 3* Activity through a returning activity transition, giving you the resultCode 4* and any additional data from it. This method will only be called if the activity 5* set a result code other than {@link #RESULT_CANCELED} and it supports activity 6* transitions with {@link Window#FEATURE_ACTIVITY_TRANSITIONS}. 7* 8* \u0026lt;p\u0026gt;The purpose of this function is to let the called Activity send a hint about 9* its state so that this underlying Activity can prepare to be exposed. A call to 10* this method does not guarantee that the called Activity has or will be exiting soon. 11* It only indicates that it will expose this Activity\u0026#39;s Window and it has 12* some data to pass to prepare it.\u0026lt;/p\u0026gt; 13* 14* @param resultCode The integer result code returned by the child activity 15* through its setResult(). 16* @param data An Intent, which can return result data to the caller 17* (various data can be attached to Intent \u0026#34;extras\u0026#34;). 18*/ 19public void onActivityReenter(int resultCode, Intent data) { 20 //当你使用了过度动画返回时候就会调用此方法，通过supportPostponeEnterTransition和supportStartPostponedEnterTransition可以延缓动画的发生 21//只要resultCode不是RESULT_CANCELED并且 Window#FEATURE_ACTIVITY_TRANSITIONS这个已经在theme里设置了 22 23} 我们这么干\n1@Override 2public void onActivityReenter(int resultCode, Intent data) { 3 if (resultCode == RESULT_OK \u0026amp;\u0026amp; data != null) { 4 //针对classloader回收 我这里出现了这个问题，如果没有请忽略 5 data.setExtrasClassLoader(getClass().getClassLoader()); 6 ArrayList\u0026lt;String\u0026gt; limgs = data.getParcelableArrayListExtra(B.INTENT_IMGS); 7 imgs = limgs; 8 adapter.setIms(imgs); 9 adapter.notifyDataSetChanged(); 10 supportPostponeEnterTransition(); 11 binding.recyclerview.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() { 12 @Override 13 public void onGlobalLayout() { 14 recyclerview.getViewTreeObserver().removeOnGlobalLayoutListener(this); 15 supportStartPostponedEnterTransition(); 16 } 17 }); 18 } 19 20 super.onActivityReenter(resultCode, data); 21} 满怀希望的试一试。结果懵逼，切换了还是没效果。。。==。B页面的共享viewpager的TransitionName还是原来的。我们要在返回的时候设置viewpager的TransitionName为当前选中的item的url。\nB中\n1/** 2* 通过转场动画finish 3*/ 4private void checkFinish(int resultCode) { 5 Intent intent = new Intent(); 6 setEnterShareCallback(currentItem); 7 intent.putParcelableArrayListExtra(INTENT_IMGS, imgs); 8 setResult(resultCode, intent); 9 supportFinishAfterTransition(); 10} 11 12private void setEnterShareCallback(String url) { 13//设置共享元素们的回调 14 setEnterSharedElementCallback(new SharedElementCallback() { 15 @Override 16 public void onMapSharedElements(List\u0026lt;String\u0026gt; names, Map\u0026lt;String, View\u0026gt; sharedElements) { 17 sharedElements.clear(); 18 names.clear(); 19 if (currentItem==null){ 20 return; 21 } 22 names.add(url); 23 sharedElements.put(url,viewPager); 24 } 25 }); 26} 这里具体可以参考 https://blog.csdn.net/mr_wrong1/article/details/49669275 哈哈 。可以了。不过最后一步中，感觉只需要设置viewpager的TransitionName就行了，没试过。有时间再试试吧。\n4、遇到的问题 项目加载网络图片会出现一些问题。如果使用glide的话要禁用动画加载dontAnimate。 还有部分时候会出现viewpager翻页会出现返回动画失效的问题,我们在返回的时候需要进行view的替换\n1@Override 2protected void onCreate(Bundle savedInstanceState) { 3 setExitSharedElementCallback(new SharedElementCallback() { 4 @Override 5 public void onMapSharedElements(List\u0026lt;String\u0026gt; names, Map\u0026lt;String, View\u0026gt; sharedElements) { 6 //isBack为成员变量 如果启动B页面设置为false,onActivityReenter后为true 7 if (isBack) { 8 names.clear(); 9 names.add(shareName); 10 sharedElements.clear(); 11 sharedElements.put(shareName, shareView); 12 } 13 } 14 }); 15} 16public void onActivityReenter(){ 17//更新adapter 18//....... 19recyclerview.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() { 20 @Override 21 public void onGlobalLayout() { 22 notifyCallView(data); 23 recyclerview.getViewTreeObserver().removeOnGlobalLayoutListener(this); 24 supportStartPostponedEnterTransition(); 25 } 26 }); 27} 28private void notifyCallView(Intent data) { 29 30 //遍历recyclerview.getchildCount 从B页面返回的url值 31 //..... 32 shareName = url; 33 shareView = viewHolder.itemView; 34 35} 5、Glide在共享元素动画时会gif会停止播放 我们实现了recyclerView到viewpager的转换，用glide加载gif，viewpager中并不能正常播放，把动画关了就可以，初步猜想是因为，我们在viewpager的istantiateItem中用glide直接去into了，此时共享元素动画是处于暂停状态，所以我们的gif也被迫暂停，当然我这只是猜想。可以等viewpager加载完成之后再into，或者延迟加载。\n","date":"2018-12-11","img":"","permalink":"https://helixs.github.io/posts/android/2018-12-11-android-recyclerview%E7%82%B9%E5%87%BB%E8%B7%B3%E8%BD%AC%E5%88%B0viewpager%E5%85%B1%E4%BA%AB%E5%85%83%E7%B4%A0%E5%8A%A8%E7%94%BB/","series":null,"tags":null,"title":"Android Recyclerview点击跳转到viewpager共享元素动画"},{"categories":["开发环境"],"content":"最近不知道怎么的从git上下来代码好慢，访问github没啥问题，找了一下原来是http://github.global.ssl.fastly.Net这个被我们伟大的墙把限制邪恶的资本主义限制了。\n前提是你要开代理，正常情况下ss for windows的http和socks5都是共用的1080端口，mac 版本的ng要设置http端口，这里以1080为例。网上基本上都是全局的设置\n1git config --global http.proxy http://127.0.0.1:1080 2git config --global https.proxy http://127.0.0.1:1080 果然是立竿见影，可是如果是访问内网或者国内的git仓局要么找不到要么就很慢，这个可是不行的，所以我们只能针对github进行代理\n1git config --global http.https://github.com.proxy http://127.0.0.1:1080 2git config --global https.https://github.com.proxy http://127.0.0.1:1080 上面是走http代理，下面是走sock5代理\n1git config --global http.https://github.com.proxy socks5://127.0.0.1:1080 2git config --global https.https://github.com.proxy socks5://127.0.0.1:1080 取消代理如下\n1git config --global --unset http.proxy 2git config --global --unset https.proxy 我们也可以进行再git配置文件下，默认在用户目录.gitconfig\n1#全局代理 最好不用 2#[https] 3#\tproxy = https://127.0.0.1:8118 4#[http]\t 5#\tproxy = http://127.0.0.1:8118 6#http代理，端口自己改 7[http \u0026#34;https://github.com\u0026#34;] 8\tproxy = http://127.0.0.1:8118 9[https \u0026#34;https://github.com\u0026#34;] 10\tproxy = http://127.0.0.1:8118 11#sock5代理，感觉比http快很多 可能是错觉吧 12#[http \u0026#34;https://github.com\u0026#34;] 13#\tproxy = socks5://127.0.0.1:1080 14#[https \u0026#34;https://github.com\u0026#34;] 15#\tproxy = socks5://127.0.0.1:1080 感谢 https://www.zhihu.com/question/27159393 ","date":"2018-11-30","img":"","permalink":"https://helixs.github.io/posts/linux/2018-11-30-git-%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86-%E8%A7%A3%E5%86%B3%E8%AE%BF%E9%97%AEgithub%E7%AD%89%E8%AE%BF%E9%97%AE%E8%BF%87%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98/","series":null,"tags":null,"title":"Git 配置代理 解决访问github等访问过慢的问题"},{"categories":["vps工具"],"content":"下载并编译aria2 最新版本 1wget https://github.com/aria2/aria2/releases/download/release-1.34.0/aria2-1.34.0.tar.gz 2tar -zxvf aria2-1.34.0.tar.gz 3cd aria2-1.34.0 4 #安装GNU编译器套件  5yum install gcc* 6./configure 7make 8make install 9cd src 10cd src cp aria2c /usr/bin 新建aria2.conf配置文件 1vim /etc/aria2/aria2.conf 1# 文件的保存路径(可使用绝对路径或相对路径), 默认: 当前启动位置 2dir=/home/download 3# 启用磁盘缓存, 0为禁用缓存, 需1.16以上版本, 默认:16M 4#disk-cache=32M 5# 文件预分配方式, 能有效降低磁盘碎片, 默认:prealloc 6# 预分配所需时间: none \u0026lt; falloc ? trunc \u0026lt; prealloc 7# falloc和trunc则需要文件系统和内核支持 8# NTFS建议使用falloc, EXT3/4建议trunc, MAC 下需要注释此项 9#file-allocation=trunc 10# 断点续传 11continue=true 12 13#https 14#rpc-secure=true  15rpc-certificate=/etc/letsencrypt/live/xxxxxx/fullchain.pem 16rpc-private-key=/etc/letsencrypt/live/xxxxxxx/privkey.pem 17 18## 下载连接相关 ## 19 20# 最大同时下载任务数, 运行时可修改, 默认:5 21max-concurrent-downloads=5 22# 同一服务器连接数, 添加时可指定, 默认:1 23max-connection-per-server=8 24# 最小文件分片大小, 添加时可指定, 取值范围1M -1024M, 默认:20M 25# 假定size=10M, 文件为20MiB 则使用两个来源下载; 文件为15MiB 则使用一个来源下载 26min-split-size=10M 27# 单个任务最大线程数, 添加时可指定, 默认:5 28split=16 29# 整体下载速度限制, 运行时可修改, 默认:0 30#max-overall-download-limit=0 31# 单个任务下载速度限制, 默认:0 32#max-download-limit=0 33# 整体上传速度限制, 运行时可修改, 默认:0 34#max-overall-upload-limit=0 35# 单个任务上传速度限制, 默认:0 36#max-upload-limit=0 37# 禁用IPv6, 默认:false 38disable-ipv6=true 39 40## 进度保存相关 ## 41 42# 从会话文件中读取下载任务 43input-file=/etc/aria2/aria2.session 44# 在Aria2退出时保存`错误/未完成`的下载任务到会话文件 45save-session=/etc/aria2/aria2.session 46# 定时保存会话, 0为退出时才保存, 需1.16.1以上版本, 默认:0 47save-session-interval=60 48 49## RPC相关设置 ## 50 51# 启用RPC, 默认:false 52enable-rpc=true 53# 允许所有来源, 默认:false 54rpc-allow-origin-all=true 55# 允许非外部访问, 默认:false 56rpc-listen-all=true 57# 事件轮询方式, 取值:[epoll, kqueue, port, poll, select], 不同系统默认值不同 58#event-poll=select 59# RPC监听端口, 端口被占用时可以修改, 默认:6800 60#rpc-listen-port=6800 61# 设置的RPC授权令牌, v1.18.4新增功能, 取代 --rpc-user 和 --rpc-passwd 选项 62rpc-secret=passswwswssw 63# 设置的RPC访问用户名, 此选项新版已废弃, 建议改用 --rpc-secret 选项 64#rpc-user= 65# 设置的RPC访问密码, 此选项新版已废弃, 建议改用 --rpc-secret 选项 66#rpc-passwd= 67 68## BT/PT下载相关 ## 69 70# 当下载的是一个种子(以.torrent结尾)时, 自动开始BT任务, 默认:true 71#follow-torrent=true 72# BT监听端口, 当端口被屏蔽时使用, 默认:6881-6999 73listen-port=51413 74# 单个种子最大连接数, 默认:55 75#bt-max-peers=55 76# 打开DHT功能, PT需要禁用, 默认:true 77enable-dht=true 78# 打开IPv6 DHT功能, PT需要禁用 79#enable-dht6=false 80# DHT网络监听端口, 默认:6881-6999 81#dht-listen-port=6881-6999 82# 本地节点查找, PT需要禁用, 默认:false 83#bt-enable-lpd=false 84# 种子交换, PT需要禁用, 默认:true 85enable-peer-exchange=false 86# 每个种子限速, 对少种的PT很有用, 默认:50K 87#bt-request-peer-speed-limit=50K 88# 客户端伪装, PT需要 89peer-id-prefix=-TR2770- 90user-agent=Transmission/2.77 91# 当种子的分享率达到这个数时, 自动停止做种, 0为一直做种, 默认:1.0 92seed-ratio=0 93# 强制保存会话, 即使任务已经完成, 默认:false 94# 较新的版本开启后会在任务完成后依然保留.aria2文件 95#force-save=true 96# BT校验相关, 默认:true 97#bt-hash-check-seed=true 98# 继续之前的BT任务时, 无需再次校验, 默认:false 99bt-seed-unverified=true 100# 保存磁力链接元数据为种子文件(.torrent文件), 默认:false 101bt-save-metadata=true 102#强制加密, 防迅雷必备 103#bt-require-crypto=true 104 105bt-tracker=udp://tracker.coppersurfer.tk:6969/announce,udp://tracker.internetwarriors.net:1337/announce,http://tracker.internetwarriors.net:1337/announce,udp://tracker.opentrackr.org:1337/announce,udp://9.rarbg.to:2710/announce,udp://exodus.desync.com:6969/announce,udp://tracker.vanitycore.co:6969/announce,udp://explodie.org:6969/announce,http://tracker.vanitycore.co:6969/announce,http://explodie.org:6969/announce,udp://tracker1.itzmx.com:8080/announce,http://tracker1.itzmx.com:8080/announce,udp://ipv4.tracker.harry.lu:80/announce,udp://open.stealth.si:80/announce,udp://denis.stalker.upeer.me:6969/announce,udp://tracker.torrent.eu.org:451/announce,udp://tracker.tiny-vps.com:6969/announce,udp://tracker.port443.xyz:6969/announce,udp://retracker.lanta-net.ru:2710/announce,udp://open.demonii.si:1337/announce,http://tracker.port443.xyz:6969/announce,udp://zephir.monocul.us:6969/announce,udp://tracker.iamhansen.xyz:2000/announce,udp://thetracker.org:80/announce,http://tracker.city9x.com:2710/announce,http://torrent.nwps.ws:80/announce,udp://tracker.cypherpunks.ru:6969/announce,udp://tracker.cyberia.is:6969/announce,https://tracker.fastdownload.xyz:443/announce,https://opentracker.xyz:443/announce,http://tracker.cypherpunks.ru:6969/announce,http://opentracker.xyz:80/announce,http://open.trackerlist.xyz:80/announce,udp://tracker4.itzmx.com:2710/announce,udp://tracker2.itzmx.com:6961/announce,udp://tracker.uw0.xyz:6969/announce,udp://tracker.btsync.gq:233/announce,udp://pubt.in:2710/announce,http://tracker4.itzmx.com:2710/announce,http://tracker2.itzmx.com:6961/announce,http://tracker.torrentyorg.pl:80/announce,http://tracker.btsync.gq:233/announce,http://t.nyaatracker.com:80/announce,http://retracker.mgts.by:80/announce,http://open.acgnxtracker.com:80/announce,wss://tracker.openwebtorrent.com:443/announce,wss://tracker.fastcast.nz:443/announce,wss://tracker.btorrent.xyz:443/announce,wss://ltrackr.iamhansen.xyz:443/announce,udp://tracker.swateam.org.uk:2710/announce,udp://tracker.kamigami.org:2710/announce,udp://tracker.justseed.it:1337/announce,udp://torrentclub.tech:6969/announce,udp://packages.crunchbangplusplus.org:6969/announce,udp://amigacity.xyz:6969/announce,https://1337.abcvg.info:443/announce,http://tracker.tfile.me:80/announce.php,http://tracker.tfile.me:80/announce,http://tracker.tfile.co:80/announce,http://torrentclub.tech:6969/announce,http://share.camoe.cn:8080/announce,http://private.minimafia.nl:443/announce,http://prestige.minimafia.nl:443/announce,http://peersteers.org:80/announce,http://open.acgtracker.com:1096/announce,http://amigacity.xyz:6969/announce,http://agusiq-torrents.pl:6969/announce, 测试\n1aria2c --conf-path=/etc/aria2/aria2.conf 1#配置www权限 2vim /etc/sudoers 1 #root ALL=(ALL:ALL) ALL 这行下面添加上 2www ALL=NOPASSWD:/usr/bin/aria2c, /etc/aria2/aria2.conf 以www身份运行aria2\n1 sudo -u www aria2c --conf-path=/etc/aria2/aria2.conf -D 2#或者 3su - www -c aria2c --conf-path=/etc/aria2/aria2.conf -D 配置开机自启动：\n1vim /etc/rc.local 1#在 exit 0 前面加上 2sudo -u www aria2c --conf-path=/etc/aria2/aria2.conf -D 以上教程来自https://forum.cloudreve.org/d/87/14 配置成系统服务\n1vim /etc/init.d/aria2c 2---------- 3#!/bin/sh 4### BEGIN INIT INFO 5# Provides: aria2 6# Required-Start: $remote_fs $network 7# Required-Stop: $remote_fs $network 8# Default-Start: 2 3 4 5 9# Default-Stop: 0 1 6 10# Short-Description: Aria2 Downloader 11### END INIT INFO 12case \u0026#34;$1\u0026#34; in 13start) 14 echo -n \u0026#34;Starting aria2c\u0026#34; 15 /usr/local/bin/aria2c --conf-path=/etc/aria2/aria2.conf -D 16 ;; 17stop) 18 echo -n \u0026#34;Shutting down aria2c \u0026#34; 19 killall aria2c ;; 20restart) 21 killall aria2c 22 /usr/local/bin/aria2c --conf-path=/etc/aria2/aria2.conf -D 23 ;; 24esac 25exit 26 赋予aria2c文件可执行权限\n1chmod 755 /etc/init.d/aria2c 2service aria2c start 来自https://archive.ls12.me/centos-aria2c.html 如果遇到多用户权限问题可以这样操作https://www.jianshu.com/p/955e933eb191 ","date":"2018-11-21","img":"","permalink":"https://helixs.github.io/posts/linux/2018-11-21-aria2%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/","series":null,"tags":null,"title":"Centos7 Aria2 安装配置"},{"categories":["wordpress"],"content":"最近在学习linux基础，打算搭个blog做个笔记。因为练手的需要，在瓦工上租借了一年的VPS，毕竟是双十一特价\n (PS：国内环境太差了，1Mbps还贵的不行，还要传身份证备案，当初在百度云和华为云注册了一下，隔三差五给我来个电话，发营销短信，我也是受不了了。虽然我不是做WF的事情，国内的隐私已经不是隐私了)。\n  我装的系统是centos7，vps内存就那么点，就打算使用nginx替代apache了。又得知nginx主要是用来处理静态网页比较给力，对用php开发的wordpress是天生的不支持。所以就要通过nginx将php的动态请求转发到php-fpm解析器，处理完成后再通过nginx回馈给client，大概就是这个过程。\n看看wordpress官网 的最新版本，我下载的是4.9.8版本。然后开看看这个版本的最低环境要求 :\n PHP 7.2或更高版本。 MySQL 5.6或更高版本_或_ MariaDB 版本10.0或更高版本(内存怪兽)。 HTTPS 支持(这个看自己需求了)  1、安装php 7.x 安装phpCentos7仓库默认的版本还是php5.6，所有我们要找到php的最新源。 删除老的php版本\n1$ yum remove php* 2CentOS/RHEL 7.x: 3$ rpm -Uvh https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm 4$ rpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm 5$ yum install php70w 6$ yum install php70w php70w-fpm php70w-bcmath php70w-gd php70w-mbstring php70w-mcrypt php70w-mysql 7... 8软件包：php70w-mcrypt-7.0.32-1.w7.x86_64 (webtatic) 9需要：libmcrypt.so.4()(64bit) 10... 突然mcrypt属啥玩意儿不关，主要是libmcrypt.so.4()(64bit)这个玩意儿应该就是本机缺少了这个函数库了。\n1$ yum install libmcrypt libmcrypt-devel 2没有可用软件包 libmcrypt libmcrypt-devel。 3 4#搜索一下：基本都是复制粘贴一个东西：来安装epel源 5$ yum -y install epel-release 6Loading mirror speeds from cached hostfile 7* base: mirror.fileplanet.com 8* elrepo-kernel: repos.lax-noc.com 9* extras: mirror.fileplanet.com 10* updates: mirror.fileplanet.com 11* webtatic: us-east.repo.webtatic.com 12软件包 epel-release-7-11.noarch 已安装并且是最新版本 13无须任何处理 WTF，怎么这样。再搜索都是一样的爬虫复制粘贴结果。都是指向的 华中科技大学开源镜像站 网上基本都是找的5.x的源，然后翻翻翻找了epel-release-latest.rpm源\n1$ wget http://mirrors.hust.edu.cn/epel/epel-release-latest-7.noarch.rpm 2$ rpm -ivh epel-release-latest-7.noarch.rpm 3$ yum update 4$ yum install epel-release 5#MMP:软件包 epel-release-7-11.noarch 已安装并且是最新版本 6#怪事，可能是我新手吧，不懂这些依赖关系，干脆卸载重装 7$ yum remove epel-release 8$ yum install epel-release 9#再来 10$ yum install libmcrypt libmcrypt-devel 11#靠居然可以了。 12$ rpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm 13$ yum install php70w php70w-fpm php70w-bcmath php70w-gd php70w-mbstring php70w-mcrypt php70w-mysql php组件基本安装完成。\n2、安装数据库 我选择MariaDB 和MySql差不多的用法。和php一样。MariaDB在centos7中的默认源是与MySql(5.5)一致的5.5版本，看来我们又要添加新的源了。 MariaDB做的很好，很方便的把源信息分享出来，我们选择centos7(x86_64)的版本。 新建文件MariaDB.repo或者相似的，放入/etc/yum.repos.d/下面。然后使用vi粘贴源信息，如下面\n1# MariaDB 10.1 CentOS repository list – created 2018-11-12 10:07 UTC2# http://downloads.mariadb.org/mariadb/repositories/3[mariadb] name = MariaDB4baseurl = http://yum.mariadb.org/10.1/centos7-amd645gpgkey=https://yum.mariadb.org/RPM-GPG-KEY-MariaDB6gpgcheck=1修改完成后\n1$ yum install MariaDB-server MariaDB-client 2$ systemctl start mariadb 设置数据库\n1$ mysql\\_secure\\_installation 2# Enter current password for root (enter for none): 输入当前的root密码(默认空)，直接回车 3# Set root password? [Y/n] 设置新密码，y 4# Remove anonymous users? [Y/n] 移除匿名用户，y 5# Disallow root login remotely? [Y/n] 禁止root用户远程登录，y 6# Remove test database and access to it? [Y/n] 移除测试数据库，y 7# Reload privilege tables now? [Y/n] y 8$ mysql -u ‘数据库用户’ -p 9#因为是我用的是root所以就填的root了，然后输入数据库用户的密码就是你刚才设置的 10$ CREATE DATABASE wordpress (名字随意，初始化进入wordpress的时候是要选择这个的) 11$ exit 这样我们的数据库配置基本上就完成了\n3、配置wordpress+nginx+php-fpm 1$ yum install nginx 2#(版本自己选择) 3$ weget https://wordpress.org/latest.zip 4$ unzip wordpress-xxxxx.zip 5$ mv wordpress/* /usr/share/nginx/html/ 6#我放的是默认的nginx的html目录，其他的可以自己行放入 7#配置nginx  8$vi /etc/nginx/nginx.conf 配置nginx\n1server{2 listen 80 default_server;3 listen [::]:80 default_server;4 server_name _;5 root /usr/share/nginx/html6 index index.php index.html index.htm;7 # Load configuration files for the default server block.8 include /etc/nginx/default.d/*.conf;9 location ~ \\.php$ {10 try_files $uri =404;11 fastcgi_pass 127.0.0.1:9000;#主要是这个是php-fpm的默认端口地址12 fastcgi_index index.php;13 fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;14 include fastcgi_params;15 }16}wq保存\n配置php-fpm\n1 2$ cd /etc/php-fpm.d/ 3$ vi www.conf 4#我们找到user和group，默认是apache，所以我们改成nginx，以及lisen就用默认的 5:wq 6$ systemctl restart php-fpm 7$ systemctl restart nginx 8#如果都成功了我们就打开浏览器输入ip回车，没啥问题的话我们就可以看到wordpress的初始化配置，其主要的就是配置数据库，数据库名称就是我们刚才建立的数据库名称wordpress,用户名和密码是数据库的用户名和密码，我这里用的是root密码就是自己设置的密码。 9#如果出问题请检查数据库名称是否创建，数据库名称对应是否正确，用户名密码是否正确。 10#一切就绪之后我们创建了管理员账号和密码就一切OK了。 11#玩几下的时候发现更换出题或者写入文件的时候 12#wordpress 需要访问您网页服务器的权限。 请输入您的 FTP 登录XXXX 13#晕，怎么会这样，不会真的还要我创建ftp服务吧。不行google一下 14清一色的 15#1、chmod-R777 16#2、wp-config.php里加入下面代码: 17# define(“FS_METHOD”, “direct”); 18# define(“FS_CHMOD_DIR”, 0777); 19# define(“FS_CHMOD_FILE”, 0777); 20#才不行，想一下，wordpress没有写入权限，就说明wordpress网站目录的所有者不给予运行wordpress的php-fpm权限。 21$ ll /usr/share/nginx/html/ 22#目录的所有者是root，因为对linux的权限不是很清楚，所以我以为既然启动的nginx的用户是root，启动php-fpm的用户也是root，不会出现这个问题啊。那么我们还是查看进程吧 23$ ps aux|grep nginx 24$ ps aux|grep php-fpm 25#他们的主进程用户的确是root 26#然后发现php-fpm子进程中多了很多的nginx用户，对了。我们不是在www.conf中指定用户和用户组是nginx吗，那么网站的目录的所有者是root，nginx用户子进程的确是写入root用户的目录的，所以我们把目录所有者指定给nginx 27$ chown -R nginx /usr/share/nginx/html 28#对我一个小白来说一个wordpress网站基本就搭完成了。 对我一个小白来说一个wordpress网站基本就搭完成了。\n感谢 https://blog.csdn.net/notebook034/article/details/51584993 ","date":"2018-11-12","img":"","permalink":"https://helixs.github.io/posts/linux/2018-11-12-wordpress+nginx%E6%90%AD%E5%BB%BA%E5%85%A8%E8%BF%87%E7%A8%8B/","series":null,"tags":null,"title":"WordPress+Nginx搭建全过程"},{"categories":["linux常用配置"],"content":"防火墙 启动防火墙\n1 systemctl start firewalld 关闭防火墙\n1systemctl stop firewalld 查看防火墙状态\n1systemctl status firewalld 开机禁用防火墙\n1systemctl disable firewalld 开机启用防火墙\n1systemctl enable firewalld 开放指定端口 1firewall-cmd --zone=public --add-port=80/tcp --permanent 关闭指定端口\n1firewall-cmd --zone=public --remove-port=80/tcp --permanent 重启防火墙 1firewall-cmd --reload –zone 作用域\n–add-port=80/tcp 添加端口，格式为：端口/通讯协议\n–permanent 永久生效，没有此参数重启后失效\n查看防火墙规则 1firewall-cmd --list-all 查看开放端口\n1firewall-cmd --list-ports  SSH 1vim /etc/ssh/sshd_config 找到下面 Port 大部分默认端口为22 改成你想要的端口如 1234\n保存 :wq\n1systemctl restart sshd 部分云机器上会出现下面这种错误\nJob for sshd.service failed because the control process exited with error code. See \u0026quot;systemctl status sshd.service\u0026quot; and \u0026quot;journalctl -xe\u0026quot; for details.\n执行\n1journalctl -xe 可能会出现 error: Bind to port 1234 on 0.0.0.0 failed: Permission denied. May 29 11:06:10 MyCloudServer sshd[8742]: error: Bind to port 1234 on :: failed: Permission denied.\n搜了一下是selinux安全策略搞鬼，可能是限制了ssh的端口号\n1semanage port -l | grep ssh 1#得到了限制的ssh端口号是22 果然没错 2ssh_port_t tcp 22 将端口号添加到selinux规则里面\n1semanage port -a -t ssh_port_t -p tcp 1234 2semanage port -l | grep ssh ssh_port_t tcp 1234, 22\n重启sshd\n1systemctl restart sshd 看看是不是成功了呢。\n如果找不到semanager执行下面后，在进行上面的操作\n1yum provides semanage 2yum install policycoreutils-python.x86_64 3#查询selinux是否是enable的状态 4/usr/sbin/sestatus -v ","date":"2018-10-30","img":"","permalink":"https://helixs.github.io/posts/linux/2018-10-31-centos7-%E9%98%B2%E7%81%AB%E5%A2%99%E7%AB%AF%E5%8F%A3%E9%85%8D%E7%BD%AE%E5%92%8Cssh%E7%AB%AF%E5%8F%A3%E9%85%8D%E7%BD%AE-/","series":null,"tags":null,"title":"Centos7 防火墙端口配置和SSH端口配置"},{"categories":null,"content":"","date":"0001-01-01","img":"","permalink":"https://helixs.github.io/contact/","series":null,"tags":null,"title":"联系我们"}]